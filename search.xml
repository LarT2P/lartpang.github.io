<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[上网背后的流程]]></title>
    <url>%2Fee%2F%E4%B8%8A%E7%BD%91%E8%83%8C%E5%90%8E%E7%9A%84%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[当一个用户在地址栏输入www.baidu.com过程： https://www.cnblogs.com/lidong94/p/8309130.html 域名解析 --&gt; 发起TCP的3次握手 --&gt; 建立TCP连接后发起http请求 --&gt; 服务器响应http请求，浏览器得到html代码 --&gt; 浏览器解析html代码，并请求html代码中的资源 --&gt; 浏览器对页面进行渲染呈现给用户 --&gt; 传输完成，TCP挥手 域名解析 浏览器先检查自身缓存中有没有被解析过的这个域名对应的ip地址，如果有，解析结束。同时域名被缓存的时间也可通过TTL属性来设置。浏览器会按照一定的频率缓存DNS记录。 如果浏览器缓存中没有，浏览器会检查操作系统缓存中有没有对应的已解析过的结果。 如果在Windows系统的DNS缓存也没有找到，那么尝试读取hosts文件（位于C:32），看看这里面有没有该域名对应的IP地址，如果有则解析成功。 如果在hosts文件中也没有找到对应的条目，便会查找路由器缓存，如果没有就 会真正的请求本地域名服务器（LDNS）来解析这个域名。 浏览器就会发起一个DNS的系统调用，就会向本地配置的首选DNS服务器（一般是电信运营商提供的，也可以使用像Google提供的DNS服务器）发起域名解析请求（通过的是UDP协议向DNS的53端口发起请求，这个请求是递归的请求，也就是运营商的DNS服务器必须得提供给我们该域名的IP地址）。 运营商的DNS服务器首先查找自身的缓存，找到对应的条目，且没有过期，则解析成功。如果没有找到对应的条目，则有运营商的DNS代我们的浏览器发起迭代DNS解析请求。 7 它首先是会找根域的DNS的IP地址（这个DNS服务器都内置13台根域的DNS的IP地址），找到根域的DNS地址，就会向其发起请求（请问www.baidu.com这个域名的IP地址是多少啊？），根域发现这是一个顶级域com域的一个域名，于是就告诉运营商的DNS我不知道这个域名的IP地址，但是我知道com域的IP地址，你去找它去 于是运营商的DNS就得到了com域的IP地址，又向com域的IP地址发起了请求（请问www.baidu.com这个域名的IP地址是多少?）,com域这台服务器告诉运营商的DNS我不知道www.baidu.com这个域名的IP地址，但是我知道baidu.com这个域的DNS地址，你去找它去. 于是运营商的DNS又向baidu.com这个域名的DNS地址（这个一般就是由域名注册商提供的，像万网，新网等）发起请求。 这个时候baidu.com域的DNS服务器一查，在这里，于是就把找到的结果发送给运营商的DNS服务器，这个时候运营商的DNS服务器就拿到了www.baidu.com这个域名对应的IP地址。LDNS缓存这个域名和对应的ip。 运营商的DNS服务器返回给用户Windows系统内核。 内核又把结果返回给浏览器 浏览器拿到了www.baidu.com 对应的IP地址。 域名解析过程至此结束了。 浏览器缓存，系统缓存，路由器缓存，IPS服务器缓存，根域名服务器缓存，顶级域名服务器缓存，主域名服务器缓存。 发起TCP的3次握手 TCP/IP协议是Internet最基本的协议、Internet国际互联网络的基础，由网络层的IP协议和传输层的TCP协议组成。通俗而言：TCP负责发现传输的问题，一有问题就发出信号，要求重新传输，直到所有数据安全正确地传输到目的地。而IP是给因特网的每一台联网设备规定一个地址。 拿到域名对应的IP地址之后，User-Agent（一般是指浏览器）会根据url中输入的端口向服务器的WEB程序（常用的有httpd,nginx等）发起TCP的连接请求。这个连接请求经过网络中层层的路由到达机房路由之后，防火墙判断当前端口是否开放，如果开放则进入到服务器网卡，然后是进入到内核的TCP/IP协议栈（用于识别该连接请求，解封包，一层一层的剥开），最终到达WEB程序（本文就以Nginx为例），最终建立了TCP/IP的连接。 连接建立阶段： 客户端的应用进程主动打开，并向服务端发出请求报文段。其首部中：SYN=1,seq=x。 服务器应用进程被动打开。若同意客户端的请求，则发回确认报文，其首部中：SYN=1,ACK=1,ack=x+1,seq=y。 客户端收到确认报文之后，通知上层应用进程连接已建立，并向服务器发出确认报文，其首部：ACK=1,ack=y+1。当服务器收到客户端的确认报文之后，也通知其上层应用进程连接已建立。 至此，TCP连接就建立了，客户端和服务器可以愉快地玩耍了。只要通信双方没有一方发出连接释放的请求，连接就将一直保持。 建立TCP连接后发起http请求 进过TCP3次握手之后，浏览器发起了http的请求，使用的http的方法 GET 方法，请求的URL是 http://www.baidu.com/ ,协议是HTTP/1.0 服务器响应http请求，浏览器得到html代码 服务器端WEB程序接收到http请求以后，就开始处理该请求，处理之后就返回给浏览器html文件。 服务器返回给客户端http响应包（200 ok 响应的MIME类型是text/html），代表这一次客户端发起的http请求已成功响应。200 代表是的 响应成功的状态码。 浏览器解析html代码，并请求html代码中的资源（如js、css、图片等） 浏览器拿到index.html文件后，就开始解析其中的html代码，遇到js/css/image等静态资源时，就向服务器端去请求下载（会使用多线程下载，每个浏览器的线程数不一样），这个时候就用上keep-alive特性了，建立一次HTTP连接，可以请求多个资源，下载资源的顺序就是按照代码里的顺序，但是由于每个资源大小不一样，而浏览器又多线程请求请求资源，所以实际顺序并不一定是代码里面的顺序。 浏览器在请求静态资源时（在未过期的情况下），向服务器端发起一个http请求（询问自从上一次修改时间到现在有没有对资源进行修改），如果服务器端返回304状态码（告诉浏览器服务器端没有修改），那么浏览器会直接读取本地的该资源的缓存文件。 浏览器对页面进行渲染呈现给用户 最后，浏览器利用自己内部的工作机制，把请求到的静态资源和html代码进行渲染，渲染之后呈现给用户。 传输完成，TCP挥手 若是不再传输数据，应用进程就会通知TCP释放连接。 https://blog.csdn.net/sinat_21455985/article/details/53508115 断开连接端可以是Client端，也可以是Server端。假设Client端发起中断连接请求： 客户端先发送FIN报文（第24帧），用来关闭主动方到被动关闭方的数据传送，也就是客户端告诉服务器：我已经不会再给你发数据了(当然，在fin包之前发送出去的数据，如果没有收到对应的ack确认报文，客户端依然会重发这些数据)，但此时客户端还可以接受数据。 Server端接到FIN报文后，但是如果还有数据没有发送完成，则不必急着关闭Socket，可以继续发送数据。所以服务器端先发送ACK（第25帧），告诉Client端：请求已经收到了，但是我还没准备好，请继续等待停止的消息。这个时候Client端就进入FIN_WAIT状态，继续等待Server端的FIN报文。 当Server端确定数据已发送完成，则向Client端发送FIN报文（第26帧），告诉Client端：服务器这边数据发完了，准备好关闭连接了。 Client端收到FIN报文后，就知道可以关闭连接了，但是他还是不相信网络，所以发送ACK后进入TIME_WAIT状态（第27帧）， Server端收到ACK后，就知道可以断开连接了。Client端等待了2MSL后依然没有收到回复，则证明Server端已正常关闭，最后，Client端也可以关闭连接了至此，TCP连接就已经完全关闭了！]]></content>
      <categories>
        <category>记录与总结</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[这些衰败的日子]]></title>
    <url>%2Flife%2F%E8%BF%99%E4%BA%9B%E8%A1%B0%E8%B4%A5%E7%9A%84%E6%97%A5%E5%AD%90%2F</url>
    <content type="text"><![CDATA[想换主题了。 一 突然心血来潮，想换主题了。搜了将近一个小时，打算用这个了。 https://github.com/rujews/maupassant-hugo 可是，hugo的基本配置，有点蛋疼啊。。折腾的心烦。 好想换回hexo了。 安安心心写点东西。 二 愈发的懒惰了，根本不想重新再搭一遍博客，费时费力，这个Jane已经很不错了，只是可能觉得略微有些偏窄，没有侧栏设计，三段式的布局。 头 -&gt; 体 -&gt; 脚 不过功能很全面，不想再改动了。 没时间，没心情，没动力了。 三 最近一直在linux下学习CS231n课程，电脑配置的劣势凸显的无比明显，jupyter notebook使用在浏览器上，本身就比较耗费资源，尤其我用的还是Chrome。 尤其在读取样本数据集的时候... 不过话说回来，Chrome用起来，在linux上确实比windows上好用些。字体发虚的问题并没有出现，清晰流畅（这个稍微有点不贴切，还是有点卡顿的），但是比firefox用起来还是好用些。 学习主要看了知乎上的《智能单元》的专栏，将以前的笔记进行了翻译，适当的也添加了自己的补充。很不错。 看的有些细节还是有些疑惑，都复制并添加补充了自己的思考和引用。希望对于自己的日后的学习能起到更多的帮助。 四 在学习课程的时候，相关的作业基于python，作业在忙第二次的，现在做到了卷积网络的部分。前面的作业还没有使用到框架，还是在手动练习，熟悉各个环节和流程的时候，这个时候趁手的编辑器和给力的补全提示操作就很重要了。 先把功能提升的首要考虑放在了jupyter notebook上了，因为作业的主文件是.ipynb文件，通过交互式的编辑方式，调用很多具体的函数的.py文件，以及类的.py文件，来实现代码的交流沟通。查了好久，知道了有一个jupyter notebook插件包，里面提供了多种功能的插件，翻译，补全的自动提示（默认需要tab），高亮选中的部分等等，各种。当然，也安装了主题，有一个主题包 jupyterthemes，提供了数种皮肤主题，默认不显示菜单，后来查了issue，原来需要指定一个额外的参数来应用主题。 用它来写notebook文件可以，但是写py文件却不是很合适，很不方便。 开始是在gnome默认的终端模拟器里，使用另一个标签页来使用vim。 vim也是配置了好久，才基本上实现了需求。但是，总是有些想法，想要使用一种能平铺的终端，最后选择了tilix。 但是vim用着还是不痛快，我考虑了Sublime text3，本身很不错，轻量但是又可以很给力，配合插件系统，很给力，但是有一个要命的问题，总是卡着闪退。 为了稳定，我又尝试了VSCode，但是，更大的卡顿的问题又来了。有时候卡死，没办法，只好另寻他路，最后，还是落在了emacs上，但是又不想使用evil，找到了一个使用原生键位的配置，很不错，尤其是主题用的是doom的配色主题。 对于python需要安装一个语言系统服务包，但是一时脑热，装到了子环境里，导致正常启动的emacs，在主环境里没法检测到这个，会报错，为此我还到作者那里提了个issue，尴尬。最后巧合下发现了这个问题，即时修改了issue。 五 这一路来，最坑的还是输入法了，最一开始并未想过换输入法，本以为ubuntu18.04自带的ibus拼音输入法感觉不错，可以一用，没想到，时间长了自己还是崩了。 此时只好想要试试搜狗输入法，但是各种问题，坑的一笔，没办法，最后还是选择了稍逊一筹的谷歌拼音输入法，还是省事些。 后来帮同学收拾了下，没想到倒也简单。只是最好不要直接双击利用ubuntu软件商店来安装，还是使用指令安装吧： sudo dpkg -i sogou....deb sudo apt install -f 我就动了心思。 没想到，到了我的机子上就坑的一笔，多番测试，还是重新装了下fcitx和搜狗，才搞定了。 测试了好久，知道了不可以取消具体的fcitx的高级选项，需要保证各项都保持好原本的状态，但是最好把那个简单的界面取消，一来确实鸡肋，因为其中大多选项选不了，二来最好把输入法的状态栏显示出来。 六 看了下《云图》，因为《如懿传》尚未更新。 裴斗娜，周迅，这就够了。 裴斗娜 裴斗娜 裴斗娜周迅 裴斗娜，之前看过她的《秘密森林》，善良、可爱，但又不失智商。笑起来和新垣结衣有着同样的魅力。 迅哥，唉，这个优秀的演员。 七 2018年9月17日23:20:53 今天重新装了下emacs。ubuntu自带的版本还是25.2，最新的正式版都是26.1了，没办法，只好编译安装了。找了好多资料，才算安上了。 wget http://mirrors.ustc.edu.cn/gnu/emacs/emacs-26.1.tar.xz tar xvf emacs-26.1.tar.xz cd ...(emacs解包路径) sudo aptitude install libgtk2.0-dev sudo apt-get install libxpm-dev libjpeg-dev libgif-dev libtiff5-dev 最好先把各种配置依赖项安装好，可以先执行一下下面的指令，会在最后提示各种依赖问题，可以查找方式解决 ./configure --prefix=/usr/local/emacs make -j4 # j的选项依赖cpu核心数 sudo make install 把emacs的安装目录加入环境变量 vim ~/.profile 添加下面这行 export PATH=&quot;$PATH:/usr/local/emacs/bin&quot; 然后执行 source /home/bboysoul/.profile 创建emacs的图标 cd /usr/local/emacs/share/applications 把下面这个文件复制到 cp emacs.desktop /usr/share/applications/ 之后注销重新登录一下就可以找到图标了]]></content>
      <categories>
        <category>生活与思考</category>
      </categories>
      <tags>
        <tag>生活</tag>
        <tag>琐事</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如懿，如意]]></title>
    <url>%2Flife%2F%E5%A6%82%E6%87%BF%E5%A6%82%E6%84%8F%2F</url>
    <content type="text"><![CDATA[最近一直在看《如懿传》，如懿深陷冷宫，不知后续如何... 最近一直在看《如懿传》，如懿深陷冷宫，不知后续如何... 如懿 周迅一直是我极其喜欢的一个演员，从12年的《听风者》，到后来的《龙门飞甲》、《撒娇女人最好命》、《如果·爱》，以及如《表演者言》之类的节目，都可以感觉出来她是一个很特别的演员。 最初认识到这么一个演员的时候，是在小时候看《格言》杂志，有一篇她的文章，回忆她当年表演之路上的种种规划和努力（翻了下，找到了这篇文章——《想想十年后的自己》 十八岁之前，我是个不晓得本人想要什么的人，那时我天天就在浙江艺术学校里随着同窗唱唱歌，跳舞蹈。偶然有导演来找我拍戏，我就会很高兴地去拍，无论多小的角色。假如没有老师跟我的那次谈话，那么兴许直到今天，依然不人知道周迅是谁。... 当然，这是一篇“鸡汤文”，但是真情实感在其中，总会有能产生共鸣的时候。当年我就颇为感动，记下了这个特别的演员。 这本杂志中还提到了周迅，是讲她的《画皮》。 话说，这本杂志是《格言》杂志的第一百期的纪念刊，很厚，收录了不少文章，许多是我现在回想起来还是颇为感动的。 后来，生活水平好了些，用上了“大锅”天线，可以搜到很多以前看不到的频道，尤其是中央六台（真是好频道啊，哈哈，有多少美好的回忆~），于是便接触到了《听风者》。这是梁朝伟和迅哥一起演的一部谍战片。 周迅真漂亮啊！ 周迅 周迅 不行了，受不了了~ 这个电影，看完以后真心不舒服，极度难受，迅哥在中途就挂了，死得好惨，只记得那个镜头，一地的鲜红。豆瓣上，很多人都有同感。 这部电影，让我知道了周迅，知道了这个声音如此特别，笑容又如此可爱，而且又可以如此帅气的演员。 后来也没怎么有机会找她的电影去看，直到徐老怪的《龙门飞甲》，又一次让我看到了那个独特的周迅，帅，真的帅！ 周迅 不过此时我还不识陈坤，耀眼啊~ 陈坤 剧情记不得了，但是这部片子，算是老怪3D技术试水之作，不能不说技术上十分出彩。 机缘巧合之下，看了《撒娇女人最好命》，这个片子里，迅哥好可爱。而在最近，又看了陈可辛的《如果·爱》，感觉迅哥真的是美极了。 周迅 这么多年来，从最一开始认识了周迅这个人，到现在渐渐对她有了更多的更立体地了解，发现周迅是一个很有理想、而且很有实力的一个演员。 对她的喜爱愈发落实在心里。 《如懿传》终于开播了，拖了好久，前途不明。 但是，有周迅，我还是愿意看一下。 迅哥现在43了，依旧年轻、帅气、可爱。 这个不老的精灵，真的希望她可以永远幸福。]]></content>
      <categories>
        <category>电影与艺术</category>
      </categories>
      <tags>
        <tag>影视</tag>
        <tag>随感</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开心麻花]]></title>
    <url>%2Flife%2F%E5%BC%80%E5%BF%83%E9%BA%BB%E8%8A%B1%E5%87%A0%E9%83%A8%E7%94%B5%E5%BD%B1%2F</url>
    <content type="text"><![CDATA[前天看了一下开心麻花的几部片子，很逗，一口气看了三部。 先看的 羞羞的铁拳 ，印象最深的上山练功那一部分。 第一次爆笑是在秀念大师兄(王成思 Chengsi Wang)示范飞身插广告的那一段，纵身一跃，以为可以潇洒自在，结果飞来横祸，惨死街头…… 漫天的广告纸，见证着大师兄的陨落…… 突然镜头转切到祠堂祭奠，笑意再也忍不住了，哈哈！ 还有一段是山上众人看电视，第一次出现的镜头，众人凝视电视，第二次出现的时候，才发现还在调电视中——原来一直没有调好…… 当然，最让我无语唯有爆笑的是第一次沈腾出场的时候，潇洒的出场，尴尬的下跪落地…… 而对于 一念天堂 ，我只记住了那个小姑娘，唱《睫毛弯弯》的那个小姑娘(何美璇 饰 兰兰)。 何美璇 饰 兰兰 夏洛特烦恼 ，说实话，以前我以为是 夏洛特~烦恼 而非实际的 夏洛特烦恼…… 这个蛮有意思，恍惚之间穿越了(?)。不过倒是印证了一个道理—— 最爱你的人，往往是最容易被忽略的。 珍惜眼前人吧！]]></content>
      <categories>
        <category>电影与艺术</category>
      </categories>
      <tags>
        <tag>开心麻花</tag>
        <tag>电影</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spyder_tool]]></title>
    <url>%2Flangs%2Fpython%2Fspyder_tool%2F</url>
    <content type="text"><![CDATA[python爬虫工具集合 主要针对python3 常用库 urllib Urllib是python提供的一个用于操作url的模块。 在python2中，有urllib库和urllib2库。在python3中，urllib2合并到urllib库中,我们爬取网页的时候，经常用到这个库。 urllib库在python2与python3中的区别 urllib3 github urllib3 is a powerful, sanity-friendly HTTP client for Python. Much of the Python ecosystem already uses urllib3 and you should too. urllib3 brings many critical features that are missing from the Python standard libraries. requests github Requests allows you to send organic, grass-fed HTTP/1.1 requests, without the need for manual labor. There’s no need to manually add query strings to your URLs, or to form-encode your POST data. Keep-alive and HTTP connection pooling are 100% automatic, thanks to urllib3. requests-html github This library intends to make parsing HTML (e.g. scraping the web) as simple and intuitive as possible. beautiful soup doc Beautiful Soup 提供一些简单的、python 式的函数用来处理导航、搜索、修改分析树等功能。它是一个工具箱，通过解析文档为用户提供需要抓取的数据，因为简单，所以不需要多少代码就可以写出一个完整的应用程序。Beautiful Soup 自动将输入文档转换为 Unicode 编码，输出文档转换为 utf-8 编码。你不需要考虑编码方式，除非文档没有指定一个编码方式，这时，Beautiful Soup 就不能自动识别编码方式了。然后，你仅仅需要说明一下原始编码方式就可以了。Beautiful Soup 已成为和 lxml、html6lib 一样出色的 python 解释器，为用户灵活地提供不同的解析策略或强劲的速度。 lxml doc lxml is the most feature-rich and easy-to-use library for processing XML and HTML in the Python language. phantomjs github PhantomJS是一个基于webkit的JavaScript API。它使用QtWebKit作为它核心浏览器的功能，使用webkit来编译解释执行JavaScript代码。任何你可以在基于webkit浏览器 做的事情，它都能做到。它不仅是个隐形的浏览器，提供了诸如CSS选择器、支持Web标准、DOM操作、JSON、HTML5、Canvas、SVG等， 同时也提供了处理文件I/O的操作，从而使你可以向操作系统读写文件等。PhantomJS的用处可谓非常广泛，诸如前端无界面自动化测试（需要结合 Jasmin）、网络监测、网页截屏等。 selenium doc Selenium 是自动化测试工具。它支持各种浏览器，包括 Chrome，Safari，Firefox 等主流界面式浏览器，如果你在这些浏览器里面安装一个 Selenium 的插件，那么便可以方便地实现Web界面的测试。换句话说叫 Selenium 支持这些浏览器驱动。PhantomJS是一个浏览器,那么 Selenium 支持，二者便可以实现无缝对接了。Selenium支持多种语言开发，安装一下 Python 的 Selenium 库，再安装好 PhantomJS，就可以实现 Python＋Selenium＋PhantomJS 的无缝对接。PhantomJS 用来渲染解析JS，Selenium 用来驱动以及与 Python 的对接，Python 进行后期的处理。 pyquery github doc PyQuery库也是一个非常强大又灵活的网页解析库，如果你有前端开发经验的，都应该接触过jQuery,那么PyQuery就是你非常绝佳的选择，PyQuery 是 Python 仿照 jQuery 的严格实现。语法与 jQuery 几乎完全相同. pyspider github doc pyspider中文网 一个国人编写的强大的网络爬虫系统并带有强大的WebUI。采用Python语言编写，分布式架构，支持多种数据库后端，强大的WebUI支持脚本编辑器，任务监视器，项目管理器以及结果查看器。 scrapy github doc Scrapy是一个为了爬取网站数据，提取结构性数据而编写的应用框架。 可以应用在包括数据挖掘，信息处理或存储历史数据等一系列的程序中。 re python内置 指南 正则表达式本身是一种小型的、高度专业化的编程语言，而在python中，通过内嵌集成re模块，程序员们可以直接调用来实现正则匹配。正则表达式模式被编译成一系列的字节码，然后由用C编写的匹配引擎执行。 spyder github doc 汉化 Spyder, the Scientific Python Development Environment, ipython github ipython是一个python的交互式shell，比默认的python shell好用得多，支持变量自动补全，自动缩进，支持bash shell命令，内置了许多很有用的功能和函数。它提供了一个强大的python交互式shell和供Jupyter notebooks使用的一个Jupyter内核（IPython notebook） jupter notebook github doc 外部工具 chrome chrome开发者工具小技巧 史上最全的Chrome使用技巧集锦 fiddler project download-unofficial download-official articles Fiddler是最强大最好用的Web调试工具之一，它能记录所有客户端和服务器的http和https请求，允许你监视，设置断点，甚至修改输入输出数据，使用Fiddler无论对开发还是测试来说，都有很大的帮助。Fiddler4基于4.0的.NET。 wireshark download articles Wireshark（前称Ethereal）是一个网络封包分析软件。网络封包分析软件的功能是撷取网络封包，并尽可能显示出最为详细的网络封包资料。Wireshark使用WinPCAP作为接口，直接与网卡进行数据报文交换。 关于爬虫技术 如何成为一名爬虫工程师 爬虫常用工具 curl postman、paw curl to requests python -m “json.tool” Proxifier]]></content>
      <categories>
        <category>记录与总结</category>
      </categories>
      <tags>
        <tag>python3</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python高级技巧之生成器与装饰器]]></title>
    <url>%2Flangs%2Fpython%2Fpython%E7%9A%84%E9%AB%98%E7%BA%A7%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[python中有很多高级的技巧，这里记录下生成器与装饰器。 链接 Python高级编程技巧 连接 廖雪峰 推导式(Comprehensions) 列表推导(list comprehensions)。这是一种将for循环、if表达式以及赋值语句放到单一语句中的一种方法。换句话说，你能够通过一个表达式对一个列表做映射或过滤操作。 一个列表推导式包含以下几个部分： 一个输入序列 一个表示输入序列成员的变量 一个可选的断言表达式 一个将输入序列中满足断言表达式的成员变换成输出列表成员的输出表达式 1234567891011121314151617# 原始num = [1, 4, -5, 10, -7, 2, 3, -1]filtered_and_squared = []for number in num: if number &gt; 0: filtered_and_squared.append(number ** 2)print filtered_and_squared# [1, 16, 100, 4, 9]# lambda函数num = [1, 4, -5, 10, -7, 2, 3, -1]filtered_and_squared = map(lambda x: x ** 2, filter(lambda x: x &gt; 0, num))print filtered_and_squared # [1, 16, 100, 4, 9] 上面都不是很好的方案，第一个虽然直观，但是代码较多，还有不必要的append，而第二个相当于就是将代码在水平上展开。 考虑列表推导的技巧。 列表生成式 常见的形式 12345678910111213&gt;&gt;&gt; [x * x for x in range(1, 11)][1, 4, 9, 16, 25, 36, 49, 64, 81, 100]&gt;&gt;&gt; [x * x for x in range(1, 11) if x % 2 == 0][4, 16, 36, 64, 100]&gt;&gt;&gt; [m + n for m in 'ABC' for n in 'XYZ']['AX', 'AY', 'AZ', 'BX', 'BY', 'BZ', 'CX', 'CY', 'CZ']# 三层和三层以上的循环就很少用到了。&gt;&gt;&gt; d = &#123;'x': 'A', 'y': 'B', 'z': 'C' &#125;&gt;&gt;&gt; [k + '=' + v for k, v in d.items()]['y=B', 'x=A', 'z=C'] 重回上面的问题 123456# 列表推导num = [1, 4, -5, 10, -7, 2, 3, -1]filtered_and_squared = [ x**2 for x in num if x &gt; 0]print filtered_and_squared# [1, 16, 100, 4, 9] 列表推导 迭代器(iterator)遍历输入序列num的每个成员x 断言式判断每个成员是否大于零 如果成员大于零，则被交给输出表达式，平方之后成为输出列表的成员。 列表推导式被封装在一个列表中，所以很明显它能够立即生成一个新列表。这里只有一个type函数调用而没有隐式调用lambda函数，列表推导式正是使用了一个常规的迭代器、一个表达式和一个if表达式来控制可选的参数。 存在的问题 那就是整个列表必须一次性加载于内存之中，这对上面举的例子而言不是问题，甚至扩大若干倍之后也都不是问题。但是总会达到极限，内存总会被用完。 针对上面的问题，生成器(Generator)能够很好的解决。生成器表达式不会一次将整个列表加载到内存之中，而是生成一个生成器对象(Generator objector)，所以一次只加载一个列表元素。 生成器 生成器表达式同列表推导式有着几乎相同的语法结构，区别在于生成器表达式是被圆括号包围，而不是方括号 123456789101112131415161718192021222324252627282930# 初始num = [1, 4, -5, 10, -7, 2, 3, -1]filtered_and_squared = ( x**2 for x in num if x &gt; 0 )print filtered_and_squared # &lt;generator object &lt;genexpr&gt; at 0x00583E18&gt; for item in filtered_and_squared: print item # 1, 16, 100 4,9# # 改进num = [1, 4, -5, 10, -7, 2, 3, -1] def square_generator(optional_parameter): return (x ** 2 for x in num if x &gt; optional_parameter) print square_generator(0)# &lt;generator object &lt;genexpr&gt; at 0x004E6418&gt; # Option Ifor k in square_generator(0): print k# 1, 16, 100, 4, 9 # Option IIg = list(square_generator(0))print g# [1, 16, 100, 4, 9] 除非特殊的原因，应该经常在代码中使用生成器表达式。但除非是面对非常大的列表，否则是不会看出明显区别的。 多元素处理 12345alist = ['a1', 'a2', 'a3']blist = ['1', '2', '3'] for a, b in zip(alist, blist): print a, b yield 这就是定义generator的另一种方法。如果一个函数定义中包含yield关键字，那么这个函数就不再是一个普通函数，而是一个generator。 fib函数实际上是定义了斐波拉契数列的推算规则，可以从第一个元素开始，推算出后续任意的元素，这种逻辑其实非常类似generator。 1234567891011def fib(max): n, a, b = 0, 0, 1 while n &lt; max: yield b a, b = b, a + b n = n + 1 return 'done'&gt;&gt;&gt; f = fib(6)&gt;&gt;&gt; f&lt;generator object fib at 0x104feaaa0&gt; a, b = b, a + b 表示 (a, b) = (b, a+b) 更易理解可见下 12345678910def fib(max): n, a, b = 0, 0, 1 while n &lt; max: yield b (a, b) = (b, a+b) n = n + 1 return 'done'a = list(fib(3))print a 这里，最难理解的就是generator和函数的执行流程不一样。函数是顺序执行，遇到return语句或者最后一行函数语句就返回。而变成generator的函数，在每次调用next()的时候执行，遇到yield语句返回，再次执行时从上次返回的yield语句处继续执行。 12345678910111213141516171819202122def odd(): print('step 1') yield 1 print('step 2') yield(3) print('step 3') yield(5)&gt;&gt;&gt; o = odd()&gt;&gt;&gt; next(o)step 11&gt;&gt;&gt; next(o)step 23&gt;&gt;&gt; next(o)step 35&gt;&gt;&gt; next(o)Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;StopIteration 可以看到，odd不是普通函数，而是generator，在执行过程中，遇到yield就中断，下次又继续执行。执行3次yield后，已经没有yield可以执行了，所以，第4次调用next(o)就报错。 把函数改成generator后，我们基本上从来不会用next()来获取下一个返回值，而是直接使用for循环来迭代： 12&gt;&gt;&gt; for n in fib(6):... print(n) 但是用for循环调用generator时，发现拿不到generator的return语句的返回值。如果想要拿到返回值，必须捕获StopIteration错误，返回值包含在StopIteration的value中。 12345678910111213141516g = fib(6)while True: try: x = next(g) print('g:', x) except StopIteration as e: print('Generator return value:', e.value) break# g: 1# g: 1# g: 2# g: 3# g: 5# g: 8# Generator return value: done 可以直接作用于for循环的数据类型有以下几种： 一类是集合数据类型，如list、tuple、dict、set、str等； 一类是generator，包括生成器和带yield的generator function。 这些可以直接作用于for循环的对象统称为可迭代对象：Iterable。 而生成器不但可以作用于for循环，还可以被next()函数不断调用并返回下一个值，直到最后抛出StopIteration错误表示无法继续返回下一个值了。可以被next()函数调用并不断返回下一个值的对象称为迭代器：Iterator。 生成器都是Iterator对象，但list、dict、str虽然是Iterable，却不是Iterator。 你可能会问，为什么list、dict、str等数据类型不是Iterator？ 这是因为Python的Iterator对象表示的是一个数据流，Iterator对象可以被next()函数调用并不断返回下一个数据，直到没有数据时抛出StopIteration错误。可以把这个数据流看做是一个有序序列，但我们却不能提前知道序列的长度，只能不断通过next()函数实现按需计算下一个数据，所以Iterator的计算是惰性的，只有在需要返回下一个数据时它才会计算。 Iterator甚至可以表示一个无限大的数据流，例如全体自然数。而使用list是永远不可能存储全体自然数的。 装饰器 装饰器为我们提供了一个增加已有函数或类的功能的有效方法。 装饰器是一个包装了另一个函数的特殊函数：主函数被调用，并且其 返回值 将会被传给装饰器，接下来装饰器将返回一个 包装了主函数的替代函数，程序的其他部分看到的将是这个包装函数。 本质上，decorator就是一个返回函数的高阶函数。所以，我们要定义一个能打印日志的decorator，可以定义如下： 12345def log(func): def wrapper(*args, **kw): print('call %s():' % func.__name__) return func(*args, **kw) return wrapper 观察上面的log，因为它是一个decorator，所以接受一个函数作为参数，并返回一个函数。我们要借助Python的@语法，把decorator置于函数的定义处： 123@logdef now(): print('2015-3-25') 调用now()函数，不仅会运行now()函数本身，还会在运行now()函数前打印一行日志： 123&gt;&gt;&gt; now()call now():2015-3-25 把@log放到now()函数的定义处，相当于执行了语句： 1now = log(now) 由于log()是一个decorator，返回一个函数，所以，原来的now()函数仍然存在，只是现在 同名的now变量指向了新的函数 ，于是 调用now()将执行新函数，即在 log()函数中返回的wrapper()函数。 wrapper()函数的参数定义是(*args, **kw)，因此，wrapper()函数可以接受任意参数的调用。在wrapper()函数内，首先打印日志，再紧接着调用原始函数(这里是在return func(*args, **kw)中实现的)。 要注意，上面的装饰器形式上没有使用参数，但是实际上有一个函数对象参数。如果decorator本身需要传入参数，那就需要编写一个返回decorator的高阶函数，写出来会更复杂。比如，要自定义log的文本： 1234567def log(text): def decorator(func): def wrapper(*args, **kw): print('%s %s():' % (text, func.__name__)) return func(*args, **kw) return wrapper return decorator 这个3层嵌套的decorator用法如下： 123@log('execute')def now(): print('2015-3-25') 执行结果如下： 123&gt;&gt;&gt; now()execute now():2015-3-25 和两层嵌套的decorator相比，3层嵌套的效果是这样的： 1&gt;&gt;&gt; now = log('execute')(now) 我们来剖析上面的语句，首先执行log('execute')，返回的是decorator函数，再调用返回的函数，参数是now函数，返回值最终是wrapper函数。 以上两种decorator的定义都没有问题，但还差最后一步。因为我们讲了函数也是对象，它有__name__等属性，但你去看经过decorator装饰之后的函数，它们的__name__已经从原来的'now'变成了'wrapper'： 12&gt;&gt;&gt; now.__name__'wrapper' 因为返回的那个wrapper()函数名字就是'wrapper'，所以，需要把原始函数的__name__等属性复制到wrapper()函数中，否则，有些依赖函数签名的代码执行就会出错。 **不需要编写wrapper.__name__ = func.__name__这样的代码，Python内置的functools.wraps就是干这个事的**，所以，一个完整的decorator的写法如下： 12345678import functoolsdef log(func): @functools.wraps(func) def wrapper(*args, **kw): print('call %s():' % func.__name__) return func(*args, **kw) return wrapper 或者针对带参数的decorator： 12345678910import functoolsdef log(text): def decorator(func): @functools.wraps(func) def wrapper(*args, **kw): print('%s %s():' % (text, func.__name__)) return func(*args, **kw) return wrapper return decorator]]></content>
      <categories>
        <category>编程与生活</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>进阶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我不是药神]]></title>
    <url>%2Flife%2F%E6%88%91%E4%B8%8D%E6%98%AF%E8%8D%AF%E7%A5%9E%2F</url>
    <content type="text"><![CDATA[关于《我不是药神》 序 首先庆祝下，今天算是小工作的一个里程碑阶段，生产实习的上位机的代码基本完成，就差进一步整理（清理）了。 而且终于搞定了hugo的shortcode的使用方法，具体可见之后的一篇文章 关于hugo的shortcode的使用。 关键是Jane这个主题的作者自己修改的关于豆瓣的条目的使用的一个shortcode的应用，折腾半天才搞定。 确实给力！ 想法 我不是药神 主要讲了一个吃药难的问题，印度有仿制药，中国不允许在专利期内进行仿制，只能出现片子中的尴尬局面。 卖神油的，为了赚钱走上了走私药物的道路，结识了一群身不由己、顽强生活的人。 些许小感动，浓浓市井生活气，一报还一报。 为了孩子，迫于现实，转手放弃走私药物的行当，走上了另一条更为安稳，更为正当的道路。 “来，吃个橘子。” 王传君 这句话，成了一前一后两种不同思想和认识转变的见证与激励。 王传君的表演是值得夸奖的，当当年 爱情公寓 的那帮人中的其他人，要么各种装疯卖傻，要么销声匿迹，他却走出了一条属于自己的道路，一条真正的演员的道路。吕受益这个角色，自我感觉是全片的关键，是程勇的转折的推动点，而他的表演，完美的做到了这一点。 钢管舞——性感背后是汗水 谭卓 谭卓饰演的单亲妈妈刘思慧，一段钢管舞，惊艳、性感，但是这之后是无限的努力。片中，徐峥饰演的程勇，用钱砸经理让他跳钢管舞的那一刻，真心解气，刘思慧眼中的泪水，或许才是真实的生活。 黄毛剃光头 章宇 章宇扮演了黄毛彭浩，这是一个特别的角色，社会底层，这种人生了大病，就是玩命。没招。 山争，给力 徐峥 徐峥现在可是出了大名，各种片子，评价都不错，不论眼光，不论演技，都是票房保证。 最后 对于电影本身的各种技术性评价，我不懂，但是我知道，这部片子，绝壁是值得赞扬，值得五星好评的。 对于现实问题的反映，是艺术源于生活、高于生活的一种特性。 可是现在的这些片子，都是些什么玩意儿。 我等民众，开心就好。]]></content>
      <categories>
        <category>电影与艺术</category>
      </categories>
      <tags>
        <tag>佳片</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C51汇编典型代码&一些org-mode技巧]]></title>
    <url>%2Flangs%2Fasm%2FC51%E6%B1%87%E7%BC%96%E5%85%B8%E5%9E%8B%E4%BB%A3%E7%A0%81%26%E4%B8%80%E4%BA%9Borg-mode%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[关于51，关于org-mode.. C51汇编典型代码&amp;一些org-mode技巧 文档存放 具体内容可见存放的数据。 下面主要介绍关键代码。 ASM 部分 12345678910111213141516171819202122232425262728293031323334353637383940414243;; LCD数据发送=============================================================OUT_DATA: PUSH 01H PUSH 02H PUSH 03H MOV R2, #32 ;32行,(双屏结构中上半屏) MOV R3, #80H ;Y地址寄存器LCD_ADDR_UP: MOV SONG, R3 ;设置绘图区的Y地址坐标 INC R3 ;Y地址加1 LCALL SEND_ML MOV SONG, #80H ;设置绘图区的X地址坐标 LCALL SEND_ML MOV R1, #16 ;16*8列LCD_DISP_UP: CLR A MOVC A, @A+DPTR MOV SONG, A LCALL SEND_SJ INC DPTR DJNZ R1, LCD_DISP_UP DJNZ R2, LCD_ADDR_UP ;写满全屏的16*8字节X64 MOV R2, #32 ;32行,(双屏结构的下半屏) MOV R3, #80H ;Y地址寄存器LCD_ADDR_DOWN: MOV SONG, R3 ;设置绘图区的Y地址坐标 INC R3 ;Y地址加1 LCALL SEND_ML MOV SONG, #88H ;设置绘图区的X地址坐标 LCALL SEND_ML MOV R1, #16 ;16*8列LCD_DISP_DOWN: CLR A MOVC A, @A+DPTR MOV SONG, A LCALL SEND_SJ INC DPTR DJNZ R1, LCD_DISP_DOWN DJNZ R2, LCD_ADDR_DOWN ;写满全屏的16*8字节X64 POP 03H POP 02H POP 01H RET 这部分介绍了如何在 LCD12864 上进行绘图操作。 值得纪念的是，这部分代码是我自己摸索，对比着网上找来的资料，不断地调整，最后终于搞定的。 开心的是，分享给了其他人，表现顽强 LCD12864 GDRAM存储结构 目前还没学会如何在 org-mode 中直接插入网络图片，并且可以直接显示。。 python 部分 123456789101112131415161718192021222324252627282930313233343536373839import binasciiimport serialfrom time import sleepimport matplotlib.pyplot as pltimport matplotlib.animation as animation#初始数据绘图def update(frame): #读入模拟 read_string = binascii.hexlify(ser.read()).decode('ascii') a = (int(read_string[0], 16) * 16 + int(read_string[1], 16)) print(a) sleep(0.1) #绘图数据生成 del(data_read[0]) data_read.append(a) #绘图 line.set_ydata(data_read) #颜色设置 if abs(a) &gt;= 40: plt.setp(line, 'color', 'r', 'linewidth', 2.0) else: plt.setp(line, 'color', 'b', 'linewidth', 2.0) return lineif __name__ == '__main__': data_read = list(range(100)) fig, ax = plt.subplots() line, = ax.plot(data_read) ax.set_ylim(0, 100) plt.grid(True) ax.set_ylabel("Temperature: ℃") ax.set_xlabel("Relative Time: s") ser = serial.Serial(port='COM3', baudrate=1200) ani = animation.FuncAnimation(fig, update, frames=None, interval=100) plt.show()ser.close() 这段代码中使用了 matplotlib.animation 这个特殊的子模块，用来绘制动态图。 最开始用的是 Tkinter 来配合 matplotlib 显示串口数据的状态，但是不适合大量数据连续的绘制。会出现卡死的状态。 直到最后，还是放弃了自定义界面的想法，干脆只是单纯的做图，于是有了这个版本。 但是还是要记录下之前的努力，下面的是原来的基于 Tkinter 和 matplotlib 的代码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147# coding:utf-8"""实现读取端口数据实现绘图2018年5月30日23:39:32"""import binasciiimport timefrom tkinter import *import matplotlibimport serialfrom matplotlib.backends.backend_tkagg import FigureCanvasTkAggfrom matplotlib.backend_bases import key_press_handlerfrom matplotlib.figure import Figuredef drawPic(): """ 获取GUI界面设置的参数，利用该参数绘制图片 """ # 清空图像，以使得前后两次绘制的图像不会重叠 screen_draw.clf() add_plot = screen_draw.add_subplot(111) add_plot.axis([0, 100, 00, 100]) x = list(range(100)) y = data_read add_plot.plot(x, y, 'r', label='Temperature') add_plot.set_title('DRAW') canvas_draw.draw()def serial_data(): """处理串口数据""" # 打开端口 try: port = input_port.get() baudrate = int(input_baudrate.get()) except: port = 'COM3' baudrate = 9600 input_port.delete(0) input_baudrate.delete(0) input_port.insert(0, 'COM3') input_baudrate.insert(0, '9600') ser = serial.Serial(port, baudrate) list_index = list(range(50)) data_read[0: 50] = data_read[50: 100] for x in list_index: read_string = binascii.hexlify(ser.read()).decode('ascii') data_read[x + 50] = int(read_string[0], 16) * \ 16 + int(read_string[1], 16) print(data_read[x]) print("Over") ser.close()def now_draw(): """实时绘制图像""" try: port = input_port.get() baudrate = int(input_baudrate.get()) delay = int(input_delay.get()) except: port = 'COM3' baudrate = 9600 delay = 10 input_port.delete(0) input_baudrate.delete(0) input_delay.delete(0) input_port.insert(0, 'COM3') input_baudrate.insert(0, '9600') input_delay.insert(0, '10') list_index_draw = list(range(100)) ser = serial.Serial(port, baudrate) start = time.clock() while True: read_string = binascii.hexlify(ser.read()).decode('ascii') data_read[99] = int(read_string[0], 16) * 16 + int(read_string[1], 16) data_read[0: 99] = data_read[1: 100] drawPic() # 指定退出死循环方式 if(data_read[99] == 85): # 温度采集模块关闭后，串口传回来的值就是 55H = 85 break elif(delay &gt; 0): if(time.clock() - start &gt;= delay): break ser.close()def on_key_event(event): print('推出程序 %s' % event.key) root.quit() root.destroy()if __name__ == '__main__': matplotlib.use('TkAgg') # 用于接受数据的存储 data_read = list(range(100)) root = Tk() # 在Tk的GUI上放置一个画布，并用.grid()来调整布局 screen_draw = Figure(figsize=(5, 4), dpi=100) canvas_draw = FigureCanvasTkAgg(screen_draw, master=root) # 绑定任意键退出 canvas_draw.mpl_connect('key_press_event', on_key_event) canvas_draw.get_tk_widget().grid(row=0, columnspan=3) canvas_draw.draw() # 放置标签、文本框和按钮等部件，并设置文本框的默认值和按钮的事件函数 Label(root, text='请输入监测时长(s),0则无限,关闭测温即可停止:').grid(row=1, column=0) input_delay = Entry(root) input_delay.grid(row=1, column=1) input_delay.insert(0, '50') Label(root, text='请输入端口号:').grid(row=2, column=0) input_port = Entry(root) input_port.grid(row=2, column=1) input_port.insert(0, 'COM3') Label(root, text='请输入波特率:').grid(row=3, column=0) input_baudrate = Entry(root) input_baudrate.grid(row=3, column=1) input_baudrate.insert(0, '9600') Button( root, text='实时监控', command=now_draw).grid( row=1, column=2, columnspan=1) Button( root, text='开始画图', command=drawPic).grid( row=2, column=2, columnspan=1) Button( root, text='打开端口', command=serial_data).grid( row=3, column=2, columnspan=1) # 启动事件循环 root.mainloop() 这里倒是学习了下 Tkinter 的相关操作，还是不错的。自定义的能力更强。不过很可惜。 并不是很适合处理动态数据显示。 ORG-MODE 部分 org-mode-babel 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970简单模板对应快捷输入的首字母输入 &lt; 后面跟一个字母，然后按 TAB 键，就可以生成对应的模板。（eg: &lt;e + TAB ）s #+BEGIN_SRC ... #+END_SRCe #+BEGIN_EXAMPLE ... #+END_EXAMPLEq #+BEGIN_QUOTE ... #+END_QUOTEv #+BEGIN_VERSE ... #+END_VERSEc #+BEGIN_CENTER ... #+END_CENTERl #+BEGIN_LaTeX ... #+END_LaTeXL #+LaTeX:h #+BEGIN_HTML ... #+END_HTMLH #+HTML:a #+BEGIN_ASCII ... #+END_ASCIIA #+ASCII:i #+INDEX: lineI #+INCLUDE: line#+END_EXAMPLE#+BEGIN_EXAMPLE（7） 文档元数据#+TITLE: the title to be shown (default is the buffer name)#+AUTHOR: the author (default taken from user-full-name)#+DATE: a date, an Org timestamp1, or a format string for format-time-string#+EMAIL: his/her email address (default from user-mail-address)#+DESCRIPTION: the page description, e.g. for the XHTML meta tag#+KEYWORDS: the page keywords, e.g. for the XHTML meta tag#+LANGUAGE: language for HTML, e.g. ‘en’ (org-export-default-language)#+TEXT: Some descriptive text to be inserted at the beginning.#+TEXT: Several lines may be given.#+OPTIONS: H:2 num:t toc:t \n:nil @:t ::t |:t ^:t f:t TeX:t ...#+BIND: lisp-var lisp-val, e.g.: org-export-latex-low-levels itemize You need to confirm using these, or configure org-export-allow-BIND#+LINK_UP: the ``up&apos;&apos; link of an exported page#+LINK_HOME: the ``home&apos;&apos; link of an exported page#+LATEX_HEADER: extra line(s) for the LaTeX header, like \usepackage&#123;xyz&#125;#+EXPORT_SELECT_TAGS: Tags that select a tree for export#+EXPORT_EXCLUDE_TAGS: Tags that exclude a tree from export#+XSLT: the XSLT stylesheet used by DocBook exporter to generate FO file其中#+OPTIONS是复合的选项，包括：H: set the number of headline levels for exportnum: turn on/off section-numberstoc: turn on/off table of contents, or set level limit (integer)\n: turn on/off line-break-preservation (DOES NOT WORK)@: turn on/off quoted HTML tags:: turn on/off fixed-width sections|: turn on/off tables^: turn on/off TeX-like syntax for sub- and superscripts. If you write &quot;^:&#123;&#125;&quot;, a_&#123;b&#125; will be interpreted, but the simple a_b will be left as it is.-: turn on/off conversion of special strings.f: turn on/off footnotes like this[1].todo: turn on/off inclusion of TODO keywords into exported texttasks: turn on/off inclusion of tasks (TODO items), can be nil to remove all tasks, todo to remove DONE tasks, or list of kwds to keeppri: turn on/off priority cookiestags: turn on/off inclusion of tags, may also be not-in-toc&lt;: turn on/off inclusion of any time/date stamps like DEADLINES*: turn on/off emphasized text (bold, italic, underlined)TeX: turn on/off simple TeX macros in plain textLaTeX: configure export of LaTeX fragments. Default autoskip: turn on/off skipping the text before the first headingauthor: turn on/off inclusion of author name/email into exported fileemail: turn on/off inclusion of author email into exported filecreator: turn on/off inclusion of creator info into exported filetimestamp: turn on/off inclusion creation time into exported filed: turn on/off inclusion of drawers]]></content>
      <categories>
        <category>编程与生活</category>
      </categories>
      <tags>
        <tag>汇编</tag>
        <tag>python</tag>
        <tag>org-mode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小诗一首]]></title>
    <url>%2Flife%2F%E5%B0%8F%E8%AF%97%E4%B8%80%2F</url>
    <content type="text"><![CDATA[配图 参加活动，造诗一首。 思绪反复，闹人，恼人。 123456789101112131415161718192021222324252627风吹过玉兰雨击打边栏摇摇晃晃 不断群星闪闪已向晚银杏叶呼扇呼扇搅动整个夏夜雨后金黄遍地人影匆匆不见影踪迷离夜色下呼吸这恼人的夏摇头摇头甩一把泪别过了头连理 理连着愁意浓浓 笑吟吟喜相逢 愁别离踏踏清脆脚步声是不悔的青春]]></content>
      <categories>
        <category>幻想与现实</category>
      </categories>
      <tags>
        <tag>生活</tag>
        <tag>校园</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Manjaro小记]]></title>
    <url>%2Ftools%2F%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEmanjaro%E5%B0%8F%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[又是一次新的尝试 写下这篇文章的时间：2018年5月23日22:46:25 使用的工具 manjaro-kde-17.1.7-stable-x86_64.iso rufus-2.18.exe AUSU X555L Core i3-5010U CPU @ 2.10GHz 2.10GHz RAM 4.00GB Win8.1 X64 一个容量合适的U盘 安装 使用 rufus 来制作启动U盘。BIOS设置U盘启动。 由于直接使用ISO模式，我这里出现了非法错误的提示，转而使用DD模式，成功进入安装设置界面。 界面很清晰，关键是驱动设定，选择闭源 —— non-free。 选择中文。 点击 boot 那项启动安装流程。 进入新的图形界面后，开始安装。 流程主要参看 Manjaro Linux 17.0.2 KDE环境安装、配置记录。 问题是，我在手动分区的时候，划分了 /boot/efi（这里文件系统我是用的是fat32，安装后win下会出现一个新的盘符，在磁盘管理中，我将其隐藏了），/，/var，但是安装过程会提示出错。 这里具体的错误已经忘记，但是多番尝试后，修改了挂载点，把 /var 改成了 交换分区。诶，这次竟然装上去了。 配置 初次进入系统后，首先要配置好源的问题。 用vi（或者KDE自带编辑器Kate，当然命令行里的Nano也不错）编辑/etc/pacman.conf文件(sudo vi /etc/pacman.conf)，在文件底部添加下面几行: 123[archlinuxcn]SigLevel = Optional TrustedOnlyServer = https://mirrors.tuna.tsinghua.edu.cn/archlinuxcn/$arch 再执行来调整源顺序，使用国内源。并更新系统，估计会有一个多G的内容要更新，等着吧。 123sudo pacman-mirrors -c China -g# 这里我直接使用了KDE的更新管理器，就是托盘里那个小妖精...简单直接sudo pacman -Syyu 关于 pacman 命令可见以下文章： https://wiki.archlinux.org/index.php/Pacman https://www.cnblogs.com/shengansong/archive/2011/11/19/2255129.html 之后就是常用软件的安装了。 终端使用vim（个人喜好，用了自己的配置文件。需要修改一些路径，字体就不用管，终端使用就这好处。） 图形使用emacs —— spacemacs（使用develop版本，参考配置可见子龙山人的）。 输入法使用fcitx-googlepinyin，我这里安装搜狗总是有问题，直接换了谷歌拼音。 12345678910111213141516171819sudo pacman -S gvimsudo pacman -S emacssudo pacman -S git# 关于fcitx可见 https://wiki.archlinux.org/index.php/Fcitxsudo pacman -S fcitx-googlepinyinsudo pacman -S fcitx-im # 全部安装sudo pacman -S fcitx-configtool # 图形化配置工具sudo pacman -S kcm-fcitx # KDE 的 Fcitx 输入法模块，似乎是可选的# 设置中文输入法环境变量，相当于开启启动输入法，编辑~/.xprofile文件，增加下面几行(如果文件不存在，则新建)# 可以通过 # echo ~# 或者# echo $HOME# 来查看对应的位置exportGTK_IM_MODULE=fcitxexportQT_IM_MODULE=fcitxexportXMODIFIERS="@im=fcitx" 如上安装后，gvim和emacs基本没有什么问题，但是输入法有些小问题，多次尝试后，就是输入字符出来的候选菜单里面不能显示文字，当我使用了 fcitx-ui-light 这个轻量级UI，发现正常了。（可在配置菜单里的高级中配置）。 没完没了 KDE启动内存占用将近五百兆，虽然比win要省一些，但是还是想尝试点新的更给力的环境。于是，我瞄上了 i3wm，一个平铺式窗口管理器。 1sudo pacman -S i3 注销用户，登录界面的 会话 选择 i3 。 进来的时候，发现只有屏幕最下方的显示有变化，变成了一条看似酷炫缺什么也做不了的状态栏。 不要慌，要知道i3主要是使用快捷键。 所以刚进的时候，会问你要不要使用默认配置。还是自己创建配置吧。会问你使用哪个作为主要的功能键，mod键设定为windows键。 这时需要 win+return 打开终端。 可以使用这个较为完整的配置： https://github.com/ID1258/oh-my-i3 注意，里面的安装最后，要运行脚本，这里需要这样执行，详见 https://github.com/ID1258/oh-my-i3/issues/2 ： 12git checkout HEAD^./install.sh 注意安装依赖： 调用conky作为i3bar输出 dmenu启动程序 feh显示壁纸 xcompmgr透明插件（可选） infinality字体渲染美化（可选） 关于配置，网上有很多，但是都需要仔细调教，可以仔细阅读i3官网手册，慢慢摸索。 相关参考 我的vim配置 spacemacs Manjaro安装与配置]]></content>
      <categories>
        <category>记录与总结</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一千天的时候]]></title>
    <url>%2Flife%2F%E5%8D%83%E6%97%A5%2F</url>
    <content type="text"><![CDATA[飞翔的鲸 第一千天的时候 by 庞有伟 一 今天是我们共处的第420天。 一年多以前，我花了一大笔钱，从那个落魄科学家那里得到了她。 那时他正要离开这个国家，急需出手这些带不走的东西。而我却因为没有离开的渠道，只好准备了另一种生活的方式。 哦，应该说是——苟活的方式。 我拿到了他们的一些补偿，被安置在了原来废墟不远处的新城。虽说新城，实为旧时拆迁尚未拆掉的旧楼。但是水电齐全，尚可安顿。 有时候和她坐在一起，我就在想，这会不会是个梦？ 倒真像个梦啊。 他们那时已经打了好几个月了。战争总是激烈的，死了好多人。 邻居家老太太的小孙子，多么可爱的一个小孩子，刚要准备上小学，却说没就没了。还有街角超市的那个漂亮的姑娘，她好像年末就要结婚了吧？ 当然，还有我们家里的人，以及，她的一切。可惜，我活着。 看着坐在前面的她，不禁一阵恍惚，鼻头骤然骤然一酸，眼泪又止不住的流了出来。 她递过来了一张纸巾。 我看向了她。她的眼睛里泛着光，那是屋里灯的光。光芒背后的颜色却是真的好看，是那种令人心静的蓝色。 那个科学家，还是很有想法的。也不知道他现在怎么样了。估计也一般吧？ 看着她，心里有些异样，但是说不上来。 屋里很暗，仅有几盏灯亮着。家里窗帘很厚，足以隔绝一切。 我已经准备好了所有东西。 我笑了笑，伸手顺了顺她的头发。 她也笑了。 二 这是我们相遇的第500天。 记得我们刚刚相见的时候，说了好多的话。不过，若是说具体说了些什么？ 哈哈，已经记不得了。毕竟都过了这么久了。 是啊，这么久了。该说的都说了，便就没话说了。 毕竟，她只是个机器人。 看着坐在对面充电的她，我心里忽然有点不开心。 但是每当我抬起头来，看到那张熟悉的面孔，就会觉得有一股难言的情绪弥漫在心里。 记得当初，她也是类似的姿势，坐在我的面前吧？ 战争啊。战争，唉。 看着紧闭着的窗帘，目光一滞，便又转开了。自那之后，这帘子就没有打开过。不喜欢太阳。因为感觉那刺眼的光，砸在心上，好生冷漠。 第500天的夜和第499天的夜一样，去的轻轻，来的匆匆。 屋外传来一些脚步声和低声细语。估计又是在讨论着当前的局势。 这个房间，应该会安全一阵子的吧。 外面是什么样子，我已经不知道了。 但是，那重要么？ 记得战争刚开始的时候，她就和我说过，要是有事，就赶快跑，越远越好，最好离开这个国家。可是谁又能离开呢？ 后来，局势越来越混乱，难民也越来越多。这个国家里，能去的地方，也没有几处。没想到我们倒是又挤在了一起。 那是个尴尬的时刻，双方家里人那时倒都还在，互相打过了招呼，也就没有再说话。 只记得，在离开的时候，她回头看了我一眼。当时的情形，已经记不清楚。但是，那一次回头，却让我再也忘不了了。 忘不了了，因为一切都终止于此。 戛然而止。 敌人的战机飞过了这里，他们的炸弹质量不错，嗯，确实，就是没炸死我。 但是，为什么却让其他人都死了？可是，这个问题，我该问谁？ 没得问，就没的说咯。 已经到了夜晚，依旧留着一缕光。 半夜里往往会醒过来，没有了这缕光，很不踏实。那次事情留给我的礼物，或许也就是这做噩梦的义务了。 第800天，转眼就到了，就像之前的第700天那样。 看着墙上密密麻麻的“正”字，整整齐齐排了40行，竟有了一种说不出的成就感。 成就感，虽然有点夸张的感觉。但是在这个时间点，倒也确实可以说得上是一种“成就”了。 但是总是隐隐的有些感觉——只是感觉说不清楚——让人很不安稳。 噩梦更加频繁了。 三 这是第999天的结束，亦是第1000天的开始。 新的生活又将开始。 所有的一切都将获得新生。 我还没有睡。今天估计是不会睡了。 把自己埋在沙发里。看着端坐在那里的她，心里有种说不出来的难过。 每天都在回想着过去一切。每次看到她，想到的也是过去。真也不知道这样的生活究竟有怎样的意义。 苟延残喘？白日做梦？ 站起了身子，走向了这个已经陪伴了我已经九百九十九天的“人”。看着她完美的皮肤和身材，我已经没有了最初时那样的满足与幸福。 记得最开始的时候，即使是坐在那里，静静地看着她，什么也不做，也是无尽的欢喜。 在她的“生命”的最开始的时候，我从她身上获得了新的快乐与激动。那种久违的，总被我觉得早已丢失了的情感，自从见到了她，仿佛一切都活络了过来。 这该以怎样的状态来形容呢？ 仿佛就像是被丢弃在了一片荒野后，发现周边什么生命也没有，只有自己一个人在苦苦挣扎。忽然有一天，有了一个新的、可以和你说话的——尽管大多数是我问她答——类似于“人”的生命个体，来到了你的身边…… 感觉一下子，一切都开始有了色彩。 想着这些混乱的东西，手已经摸到了她的脸颊。 此时的她是没有意识的，今天她已经活动了太久，储备的电能早已消耗干净了。 她的脸上的皮肤，软软的，绵绵的。触感很好，各方面都是完美的。可是却唯独有一点，却让我一直会在摸着她的皮肤时，不自觉地在脑子里跳出来“她不是人，她是机器人”的想法。 ——她的皮肤没有温度。 手已经探到了她身后的电源插口上。没有什么迟疑，顺着就把电源拔了出来…… 看着她的脸，我脑袋空空的。 回过头，顺手把窗帘扯开了。 天正亮。 一缕微光在窗帘拉开的同时，急不可耐的冲了进来，而紧随其后的无数光芒，瞬间席卷了整个房间。 远处的朝阳正雀跃着，欢呼着。仿佛在竭尽可能得为她的新客人展示着自己的所有的美。 就是这一天了，广播里说的就是这一天。 遥远的天空中，一点光芒急速飞近…… 随后，整个世界都安静了。]]></content>
      <categories>
        <category>幻想与现实</category>
      </categories>
      <tags>
        <tag>科幻</tag>
        <tag>爱情</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Processing权威指南阅读记录]]></title>
    <url>%2Fbooks%2FProcessing%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E9%98%85%E8%AF%BB%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[Processing权威指南 我与Processing 假期的时候，偶然间获知了Processing这门语言，在了解了它简单的语法，和通用的编程规则后，我进行了一些尝试。 很有意思的一个编程环境。以简化了的Java来实现图像绘制和设计的工作。其中蕴含着的数学物理知识，让我感受到了不同学科之间关联的一条若有若无的连线。 为了更为熟悉改语言的内容和规则，我特意找了两本书来看。一本书相当基础的《爱上processing》(密码: kdg3)，这本书，只要是有点编程基础的同学，基本上是三四个小时就可以看完的。我很快就翻完了。之后便找到了今天的主角——《Processing权威指南》。这本书可以说是非常之厚了。将近七百页，我花了两周才看完，当然，也是“有选择性的通读”。 看完之后，做个记录，毕竟，这本书的内容除了介绍Processing语言本身的技巧规则外，更多的是引导读者去了解、接触到一些新潮艺术家们的艺术创作旅程中。书中有很多访谈，记录许多杰出的艺术创作者们关于灵感与技术等方面的思考，值得一看。 而且这本书，从头到尾提到了很多编程语言的基础概念，也基本上说清楚了一门面向对象的语言的基本概念。甚至可以当做是一个对于Java语言学习的前奏。只不过这个前奏可能更欢快轻松些。 当然，这本书也为读者更进一步的参与到创作中，实现自己的灵感提供了一些技术上的引导，介绍了很多关于2D&amp;3D图像、声音、视频、网络、电子&amp;移动设备、打印格式等其他属于Processing本身具备或者是第三方支持功能领域的知识。为我们更进一步的了解到Processing创作的可能性提供了一个更为全面的认知。 归根到底，创意终究是最重要的。 其他的都只是装饰而已。 但是，如果连起码的装饰都没有的话，那么，绚烂的创意也是一片苍白。 Processing语言相关 Processing语言实际上是一个Java的子集。所以很多方面都可以看到Java的影子。 比如说下面这个稍微复杂点的例子 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475import gifAnimation.*;GifMaker gifExport; // 声明对象int [][] grid, futureGrid;void setup() &#123; size(940, 500); frameRate(8); grid = new int [width][height]; // 目前的图像像素数组 futureGrid = new int [width][height]; // 下一刻状态数组 // 设定初始状态 float density = 0.3 * width * height; for (int i = 0; i &lt; density; i++) &#123; grid[int(random(width))][int(random(height))] = 1; &#125; background(0); // 设定gif导出相关参数 gifExport = new GifMaker(this, "2D_CA.gif"); gifExport.setRepeat(0); // make it an "endless" animation gifExport.setTransparent(0,0,0); // black is transparent&#125;void draw() &#123; for (int x = 1; x &lt; width - 1; x++) &#123; for (int y = 1; y &lt; height - 1; y++) &#123; // “活着的”相邻细胞数目 int nb = neighbors(x, y); if ((grid[x][y] == 1) &amp;&amp; (nb &lt; 2)) &#123; futureGrid[x][y] = 0; set(x, y, color(0)); &#125; else if ((grid[x][y] == 1) &amp;&amp; (nb &gt; 3)) &#123; futureGrid[x][y] = 0; set(x, y, color(0)); &#125; else if ((grid[x][y] == 0) &amp;&amp; (nb == 3)) &#123; futureGrid[x][y] = 1; set(x, y, color(255)); &#125; else &#123; futureGrid[x][y] = grid[x][y]; &#125; &#125; &#125; int [][] temp = grid; grid = futureGrid; futureGrid = temp; gifExport.setDelay(1); gifExport.addFrame();&#125;// 统计“活着的”相邻细胞数目int neighbors (int x, int y) &#123; int north = (y + height - 1) % height; int south = (y + 1) % height; int east = (x + 1) % width; int west = (x + width - 1) % width; return grid[x][north] + grid[east][north] + grid[east][y] + grid[east][south] + grid[x][south] + grid[west][south] + grid[west][y] + grid[west][north];&#125;void mousePressed() &#123; gifExport.finish(); // write file noLoop();&#125; 这是一个二维的细胞自动机的例子。只不过在书中原有基础上添加了点生成gif图的部分。利用了第三方库 —— gifAnimathion import gifAnimation.*; 库的导入，对象的声明 GifMaker gifExport; 都和Java是一致的。类似于Processing的姊妹项目Arduino的编程，是由两个主要的函数 void setup(){}，void draw(){} 构成了程序基本的初始化和自动循环。全局变量需要在外部开头声明。 变量声明，流程控制（书中例程多用循环与条件，可见，循环判断才是关键）与Java基本一致。 下面说说Processing的简化后的优势之处。 书中在附录详细比对了设计们常用的几种语言的关于使用时的简介程度，当然，Processing自然是最简单的。毕竟本身就是一门简化后的语言。基本上所有的编写核心都是围绕绘图控制图像来的。 从最基本的绘制直线，圆，矩形，多边形等简单基本图形，到复杂的改变坐标系，以及利用循环条件结构进行稍复杂运动的表现，再到通过模仿物理规律从而展现出更为灵活多变的复杂情形，都是可以通过简单的几句代码来实现的。而且参数的设置也是很有规律的。 比如说这个例子 12345678910111213141516void setup() &#123; size(100, 100);&#125;void draw() &#123; background(204); diagonals(40, 90); diagonals(60, 62); diagonals(20, 40);&#125;void diagonals(int x, int y) &#123; line(x, y, x+20, y-40); line(x+10, y, x+30, y-40); line(x+20, y, x+40, y-40);&#125; 这段代码主要是利用了自定义的函数diagonals()实现了划线的功能，可以看到，这里使用的划线函数line(),用法是极其简单明晰的。前两点为起点坐标，后两点为终点坐标。两点定义线段，多么直接，明确。其他的类似的基础函数都是差不多的结构与使用方法，所以说，上手的话，看《爱上processing》(密码: kdg3)基本就够了。 哦，对，要注意，最基本的是使用二维直角坐标系，默认原点为窗口左上角，x轴向右，y轴向下。 Processing的潜力 相较其他语言，Processing设计出来就是为了提供给艺术家们一门简单直接，又足够强大的工具来进行创造设计。所以说，注定了它会有很多的扩展与延伸。 对的，它有很多功能库，实现了很多方面的功能。官方有一个库列表，在其主页上可以找到。但是使用各种库的时候，要注意版本。可能会有不兼容。 各种各样的库实现了各方面的功能。在开头我提到的2D&amp;3D图像、声音、视频、网络、电子&amp;移动设备等等都有相关的支持。 你甚至可以用它作为Arduino的数据处理前端，因为它可以处理端口的数据。 虽然，它只有一百多个库，但是，少而精才是现状，不用担心社区的力量，只需创意即可。 Processing的难点 利用工具实现灵感的关键还是在于用工具的规则去不断的贴合你的想法。 但是难点就在于如何将脑子里抽象的灵感，或者是动态的复杂的场景用规则化的，流程化的语言构造出来。这些都是在你实际上手的时候所需要关注的。 就像之前我的一个小尝试。 12345678910111213141516171819202122232425262728float num_lines; // 连线的数目float x_0, y_0; // 连线的起始点void setup() &#123; size(500, 500); smooth();&#125;void draw() &#123; frameRate(10); // 降低帧率 background(255); // 白色背景 num_lines = random(0, 10); // 随机连线数目 for(int i = 0; i &lt; 1000; i++) &#123; point(random(0, 500), random(0, 500)); // 背景随机点绘制 &#125; for(int i = 0; i &lt; num_lines; i++) &#123; x_0 = mouseX + random(-50, 50); y_0 = mouseY + random(-50, 50); line(x_0, y_0, mouseX, mouseY); // 鼠标连线 noFill(); // 无填充 ellipse(mouseX, mouseY, x_0, y_0);// 绘制随机高宽的圆 &#125;&#125; 就是为了实现在背景上周围随机出现点，然后令鼠标附近的几个点随机的与鼠标连线，类似于一些网站页面里利用Js实现的那种花哨的显示效果，可是最后只能做成这个样子。为了更“花哨”，我又加了一堆随机的圆。(*^__^*) 嘻嘻…… Processing权威指南 前面所说，都是我这段时间来学习的一个小的想法的汇总。 实际上，我感觉自己接触到的只是皮毛，因为语言的使用是要切合实际的应用的，否则也只是空中楼台，毫无用处。 在这本书里，后面介绍了一些比较复杂的设计思路，也就是利用了物理数学知识来实现一些更为美妙规律的视觉效果。 实际上，这本书让我对于这门语言的使用的关键——需要结合更为有力，更为逻辑的知识，来实现更为美妙魔幻的构思——有了更为切实的了解。而其他的，都是手册知识而已，总览全局后，会查手册就好。]]></content>
      <categories>
        <category>编程与生活</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[8086_i386试验箱综合设计实验]]></title>
    <url>%2Flangs%2Fasm%2F8086%E6%B1%87%E7%BC%96%E6%80%BB%E7%BB%93-i386%E8%AF%95%E9%AA%8C%E7%AE%B1%E7%BB%BC%E5%90%88%E8%AE%BE%E8%AE%A1%E5%AE%9E%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[设计要求 利用实验台上的开关（K7-K4），实现步进电机的转速、转向控制。具体要求如下： 利用8255的PC3-PC0做输出，输出步进电机的相序、驱动步进电机工作（同时使用四个LED监视步进电机的相序信号），相序之间的时间决定着步进电机的转速，而间隔时间由延时程序中的CX寄存器的初值决定。 利用8255的PC7-PC4做输入，与K7-K4连接。其中K7做步进电机的转向控制，其余位做步进电机的转速控制。程序运行时通过K7-K4对步进电机实施动态控制。 利用8253做秒脉冲发生器，产生约2秒的周期性方波信号。其中CNT0做分频器：将1MHZ信号分频为100HZ；CNT1做秒脉冲输出（0.5HZ）。 利用386模块的主8259的MIR5做中断请求输入，将CNT1的OUT1秒信号方波作为中断请求信号，引发中断服务ISR。 在中断服务程序中实现对步进电机的转速、转向实时记录存储。方法如下：在ISR中，对D8255的PC7-PC4口进行一次输入操作，并根据输入的数据： 对D7（与K7对应）位的数据识别为步进电机的转向控制； 对D6-D4（与K6-K4对应）位的数据识别为步进电机的转速控制。 利用实验台上的8*8点阵显示电路实现“小人跑步”的模拟。具体要求如下： 利用8255的PA7-PA0与8*8LED点阵显示模块的“行线Ri”连接，控制着每一列的8个LED的显示数据。 利用8255的PB7-PB0与8*8LED点阵显示模块的“列线Ri”连接，列线信号即为“位扫描”信号，决定着8255的PA数据显示在哪一列LED上。 利用8*8LED点阵显示一个小人在运动的动态画面，即显示一个小人四肢在摆动。 实现小人运动的速度与电机转速保持一致。即步进电机转速快，则小人运动快，转速慢，小人运动慢。 利用实验台上的六位数码管锁存器驱动动态显示具体档位。具体要求如下： 利用六位数码管模块的CPU模式实现功能。 利用锁存器（74LS73）电路实现一位共阴极数码管动态显示档位。 实现六位数码管锁存器驱动动态显示具体档位，即由滑动开关确定档位后，即时的显示对应的档位数字。 利用试验台的8253完成一个定时提示器。具体要求如下： 在CNT1的基础上，利用8253的CNT2做负脉冲发生器（0.1HZ）。 指定计数初值，实现定时使逻辑笔闪烁，实现提示功能。 设计分析及系统方案设计 程序结构 主要程序组成如下结构图。 结构图 算法描述 开关控制步进电机的转速、转向 步进电机驱动原理是通过对电机每相线圈施加某一顺序电压(电流)来使电机作步进式旋转。驱动电路由脉冲信号来控制，所以调节脉冲的频率便可改变步进电机的转速。由ULN2803八路达灵顿反向驱动器实现电机的电流驱动，只要在ULN2803的输入端(BJ_IN1~BJ_IN4)提供相序信号。经ULN2803反相后实现电机的驱动。ULN2803与步进电机的链接在实验台上已经完成。利用8255的低四位PC端口连接到ULN2803的输入端，输出脉冲序列，从而控制步进电机的旋转。 程序设计中，为了实现更为便捷的操作，使用“双四拍”相序信号。于是将初始相序存放在一个寄存器中（原始相序数据位33H），然后利用对该寄存器“移位”的方式产生下一个相序。这种方式下，输出脉冲的频率决定着步进电机的旋转速度，而对寄存器中的数据移位方向则决定着电机旋转方向。 所以在程序设计中，通过读取8255的PC口的高四位，以PC7作为方向，将其存放在方向数据变量direc，进而控制步进电机旋转方向。而PC6~PC4中数据作为速度参数，这里的速度参数存在程序中的速度数据变量speed中，而它又与步进电机相序输出的延时有关。以这样的方式，实现了对于步进电机的速度的调控。 在这里需要指定8255的工作方式，向8255的控制口输出10001000b，设定PA，PB口为输出，PC高位输入，低位输出。 实际中，还需要利用8253来实现定时引发自定义的中断。对于1MHZ时钟进行两次分频，最终获得周期为2s的输出信号，将这个信号接到MIR5上，定时引发中断。在中断程序中实现对于开关信号的读取和转存到对应的变量direc和speed内的功能。在编制与中断相关的程序时，需要设定中断屏蔽字、中断向量表以及开中断的操作。 在利用PC口进行读写操作时，这里需要注意，由于高四位为输入，低四位为输出，这导致读写数据时会修改了其他端口的数据，这对于程序的正常运行是不利的。所以，需要使用“读改写”的操作，在写数据的时候，先读入数据，再保留高四位的基础上，只写入低四位数据，再利用OUT指令输出。这样就保证了数据的稳定性和程序的健壮性。 8*8点阵显示 这里要实现对于88点阵的操作，在连接好8255的PA与行接口，PB与列接口后，通过对PA与PB的写数据，可以实现对具体LED的操作。为了实现小人跑步的模拟，需要先在数据段中准备好至少两份不同的小人动作的图形字符码，即程序中的LED1与LED2。通过利用speed来控制88点阵的扫描速度，来实现小人的运动速度的控制。这里利用speed来控制，也有利于点阵变化与步进电机变化的同步，更为合理的实现了“小人跑步”的概念设定。 8*8点阵图案的绘制，首先需要设定最高位扫描码，再通过对8255的PB口输出0，来关闭扫描信号，熄灭led，接下来通过向PA送列码，向PB送对应的列上的行的数据，不断地左移列码，显示行数据，这就是实现了图案从左向右扫描不断地显示。而多次调用，显示不同的图案，从表面上来看，就是实现了小人的运动状态的“模拟”。 六位数码管显示 程序使用的是CPU模式来操作一个七段数码管，来显示对应的数据的档位。对于数码管的操作，需要指定它的地址，这里使用220h，这里实际指定的是字型码锁存器，而扫描码锁存器地址为221h。实际的使用需要向220h中写入对应的字形码，指定显示的数字，而向221h中写入对应的扫描码，指定使用的数码管的位置。 程序设计中，先在数据段中指定0-3的字型码，对应四个档位。利用分支结构，实现了对应的字型码的选择。再对220h与221h中写数据，进而实现对于不同档位的显示。 定时指示 为了实现对于“运动者”定时的提示，利用8253的CNT2手动指定初值，以及工作于方式2，来实现对于CNT1输出的2s的信号定时引发负脉冲的功能，将输出接到逻辑笔上，进而实现了指示功能。 对8253的控制口输出控制字0b4h，指定cnt2的工作方式。实现负脉冲发生器。 硬件电路图 8255：用于配合CPU实现对88LED点阵，步进电机以及滑动开关的数据的相关读写操作。初始化命令字为10001000b，PA，PB口链接行列接口，控制88LED点阵，PC3PC0连接BJ_IN4BJ_IN1以及LED灯，用于控制步进电机和显示相序，PC7PC4接K7K0，用于读取开关数据。 8255连接方式示意图 8253：用于实现对于基准时钟1MHZ的分频输出2s脉冲引发中断以及指定时间输出到逻辑笔。 8253连接方式示意图 数码管：用于显示对应的档位数字。将地址接到230h即可 数码管示意图 程序流程图 主程序以及中断服务程序流程图 8*8LED显示以及七段数码管显示子程序 程序清单 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274; 2018-3-27 22:57:16; BY: Lart Pang.model small.386;begin for variable of addressio8253_0 equ 200hio8253_1 equ 201hio8253_2 equ 202hio8253_k equ 203hp8255_a equ 210hp8255_b equ 211hp8255_c equ 212hp8255_ctl equ 213hSMG equ 220h;end for variable of addressdata segment ;begin for motor buf db 0 ;相序存储 speed db 0 ;转速控制 direc db 0 ;转向控制 ;end for motor ;begin for 7-seg led ledcode db 3fh, 06h, 5bh, 4fh ;0-3的对应字形码 ;end for 7-seg led ;begin for 8*8 led led1 db 88h, 44h, 24h, 1fh, 1fh, 24h, 44h, 88h led2 db 02h, 04h, 84h, 7fh, 7fh, 84h, 04h, 02h count dw 00h ;查表计数器 bz dw ? ;定义一个位扫描码字的空间 ;end for 8*8 leddata endsss_seg segment stack dw 100 dup(0)ss_seg endscode segment assume cs:code, ds:datastart: cli ;关中断 mov ax, data ;指定数据段 mov ds, ax;begin 8259 for interruption in al, 21h ;读IMR寄存器 and al, 11011111b ;开放主片IR5中断 out 21h, al ;装载中断到IMR push ds ;压栈保存数据 mov ax, 0 ;设置中断向量 mov ds, ax lea ax, cs:int_proc ;AX指向中断程序入口地址 mov si, 35h ;中断类型码35H add si, si ;35H*4H找到相应中断向量表中的位置 add si, si mov ds:[si], ax ;装入自定义中断服务程序IP push cs ;将CS压栈，用以获取CS地址存到AX中 pop ax mov ds:[si+2], ax ;装入自定义中断服务程序CS:int_proc pop ds ;恢复数据;end 8259 for interruption;begin 8255 for initialization mov dx, p8255_ctl ;设定A口方式0输出，B口方式0输出 mov al, 10001000b ;高C口方式0输入，低C口方式0输出 out dx, al;end 8255 for initialization ;begin for setting the initial phase sequence mov buf, 33h ;初始相序33h = 0011 0011，这里是用&quot;双四拍&quot; ;相序驱动电机，故实际使用33h;end for setting the initial phase sequence;begin 8253 for frequency division ;第一次分频 1M--&gt;1K mov dx, io8253_k ;cnt0 双数 方式3 二进制 mov al, 36h ;00 11 011 0 out dx, al ;方波发生器，方式3 mov dx, io8253_0 ;cnt0产生1000Hz（1ms）的时钟 mov ax, 1000 ;分高低位写入1000 out dx, al mov al, ah out dx, al ;第二次分频 1K--&gt;0.5 mov dx, io8253_k ;cnt1 双数 方式3 二进制 mov al, 76h ;01 11 011 0 out dx, al mov dx, io8253_1 ;cnt1产生0.5Hz的时钟 mov ax, 2000 ;分高低位写入2000 out dx, al mov al, ah out dx, al ;计时 2s-&gt;10s mov dx, io8253_k ;cnt2 双数 方式2 二进制 mov al, 0b4h ;10 11 010 0 out dx, al mov dx, io8253_2 ;cnt2产生指定时间的负脉冲 mov ax, 5 ;分高低位写入指定数据 out dx, al ;这里指定为5 mov al, ah out dx, al;end 8253 for frequency division;begin main program mov dx, p8255_c ;读取8255C口内容 in al, dx ;由于C口既有输入又有输出，所以为了不会干扰 and al, 11110000b ;在写数据的时候，要保证不会改动输入的口的数据 mov bl, buf and bl, 00001111b ;只写buf的低四位到al里 add al, bl ;这里需要在低四位写数据，所以保留高四位。 out dx, al ;将数据传送 loop_main: cmp direc, 0 ;比较direc，决定相序正向输出还是反向输出 je direc_0 ;这里的方向控制实际上就是通过改变相序的循环方向 ;进而改变的 mov al, buf ;载入相序 ror al, 1 ;循环右移一位 jmp direc_1direc_0: mov al, buf rol al, 1 ;循环左移一位direc_1: ;移动完成后，进行后续操作 mov buf, al mov dx, p8255_c ;读取8255C口内容 in al, dx ;由于C口既有输入又有输出，所以为了不会干扰 and al, 11110000b ;在写数据的时候，要保证不会改动输入的口的数据 mov bl, buf and bl, 00001111b ;只写buf的低四位到al里 add al, bl ;这里需要在低四位写数据，所以保留高四位。 out dx, al ;将数据传送 sti ;开中断 ;begin 8*8 led &amp; 7-seg digital tube mov di, offset led1 ;设di为字型码缓冲区(指向首地址) call display mov di, offset led2 ;设di为字型码缓冲区(指向首地址) call display call disp_shumaguan ;end 8*8 led &amp; 7-seg digital tube jmp loop_main;end main program;begin for interrupt service programint_proc proc far push ax ;保护现场 push cx push dx mov dx, p8255_c ;读8255C口，修改方向 in al, dx ;读取端口信息 and al, 80h ;1000 0000保留方向位 mov direc, al ;将方向存入方向存储单元 mov dx, p8255_c ;再读8255C口，修改速度 in al, dx ;读取端口信息 and al, 01110000b ;0111 0000保留速度档位 mov speed, al ;将速度档位信息存入存储单元 mov al, 20h ;发EOI结束命令 out 20h, al pop dx ;恢复现场 pop cx pop ax sti ;开中断 iretint_proc endp;end for interrupt service program;begin for 8*8 led displaydisplay proc push bx ;保护现场 push ax push dx mov count, 0000h ;计数器初始值0 mov bh, 01h ;产生最高位扫描码 mov al, 0 ;扫描码消失(熄灭) mov dx, p8255_b ;指向b口 out dx, al ;输出扫描码熄灭数码管again: mov byte ptr bz, bh ;将位扫描码字节送存储空间bz push di ;保存变量指针 add di, count ;修改变量数据指针(基地址+偏移量) mov bl, byte ptr [di] ;查表得到变量数据送bl pop di ;恢复变量指针 mov al, bl mov dx, p8255_a ;指向a口 out dx, al ;输出扫描码 mov al, byte ptr bz ;使相应的数码管亮 mov dx, p8255_b out dx, al ;显示字型 inc count push cx ;保护CX mov dh, speed ;设定延时dh_0_disp: mov cx, 30h ;设定循环延时次数loop_disp: loop loop_disp dec dh jnz dh_0_disp pop cx ;恢复CX mov al, 0 ;扫描码消失(熄灭) mov dx, p8255_b ;指向b口 out dx, al ;输出扫描码熄灭数码管 mov bh, byte ptr bz ;取出扫描码 shl bh, 1 ;将扫描码右移一位 jnz again ;如果不等于0就跳转again pop dx ;恢复现场 pop ax pop bx retdisplay endp;end for 8*8 led display;begin for 7-seg digital tubedisp_shumaguan proc push bx ;保护现场 push ax push dx mov al, speed ;读取已经存储好的速度信息 cmp al, 01000000b ;第一档 jz al_1 cmp al, 00100000b ;第二档 jz al_2 cmp al, 00010000b ;第三档 jz al_3 ;al=0 mov si, 0 ;第0档：最慢，因为其间隔时间最长 jmp next_0al_1: mov si, 1 jmp next_0al_2: mov si, 2 jmp next_0al_3: mov si, 3next_0: lea bx, ledcode ;将数码管的字形码地址赋给BX里 mov bl, [bx+si] ;将对应的字形码存放到BL里 mov al, bl mov dx, SMG ;将数码管的地址存到DX里 out dx, al mov al, 01h ;设置数码管的位码，这里使用第一个数码管 inc dx ;数码管的位码，在CPU模式下 ;要存在数码管地址的下一地址 out dx, al pop dx ;恢复现场 pop ax pop bx retdisp_shumaguan endp;end for 7-seg digital tubecode ends end start ;程序结束 实验结果与分析 系统运行环境： 硬件：Windows XP 32位、386EX试验箱 软件：HQFC集成开发环境 设计语言：汇编 调试遇到的问题 由于使用了8*8点阵，导致只能将8255的接口PC分高低位用于不同的工作方式。在按此，高四位接好滑动开关，低四位接好步进电机后，运行程序，发现显示结果不正常。 在最后，准备利用8253分频配合逻辑笔，实现定时提示功能，代码写好，接口连接好后，发现逻辑笔始终显示低电平。 对应的解决办法 因为在程序中的读写PC口的时候，没有考虑到每次的写操作，是会影响到另外的四个口的数据的。所以在原来向PC口写数据的基础上，进行了进一步的处理，即“读改写”操作，先读回来原来的数据，只修改低四位，改为想要发送的数据，再写回去。这样就避免了互相干扰的问题，最终恢复正常了。 仔细检查代码后，发现，原来是CNT2相应的命令字写错了。对于2号计数器的指定出了错误，应该是0b4h，结果写成了0e4h。这里主要是因为对于16进制数字不熟悉的结果，导致信息错乱，没有输到想要的位置上。 系统运行结果 由下图可见，最终实现了档位指示，小人跑步模拟，步进电机的转动以及定时提示。 结论及设计体会 最终，完成了自己的设计，实现了“跑步机”的模拟。 最终完成的功能有：8*8LED点阵动态显示小人运动，一位七段数码管显示对应的速度档位，而利用滑动开关，实现跑步机（步进电机）的正反转和档位的控制，同时，利用分频实现定时功能，可以在指定时间输出负脉冲，将逻辑笔的指示灯切换，最终实现了定时提示的功能。 这个实验持续了两三周的时间，之前由于有考试，主要的精力没有放在这个上面，只是先做好了步进电机的基本功能，还未拓展点阵和数码管的功能。不过还好，最后还是赶上来了。 这个思路很好，在一个小的，课本的例子的基础上，不断扩展，不断增加更多的功能，这样也让我在不断地学习新的模块的知识，同时不同模块之间的配合，也在考验着我的能力，因为并不是把模块拿来接好就可以用的，总是会遇到各种各样的问题，需要我们不断地取寻找，解决。 这时，渐近式的编程就显得尤为重要。保留好源代码，先修改一部分，测试，再修改，再测试，不断地反复，直到效果满足预期要求，否则就不能拿来用，只能使用原来的未修改的源代码。这里也提示了我们，及时存档的重要性。 总的看来，磕磕绊绊，但还是走到了终点。 本次试验最遗憾的事情就是12864没用上。为了它我花费了半天时间，查资料，咨询老师，研究了半天，但最终也还是也没有用上12864。不过还是感谢老师的指导。 这次实验学到了很多，包括各种模块的使用，接口操作，中断操作，这都是在程序设计中使用到的，以及对于各种问题的调试解决方法，甚至对于编程也有了进一步的认识。汇编这门语言也因此而熟练了许多。感觉获益匪浅。]]></content>
      <categories>
        <category>编程与生活</category>
      </categories>
      <tags>
        <tag>汇编</tag>
        <tag>计算机原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Processing精彩例程之细胞自动机]]></title>
    <url>%2Flangs%2Fprocessing%2FProcessing%E7%B2%BE%E5%BD%A9%E4%BE%8B%E7%A8%8B%E4%B9%8B%E7%BB%86%E8%83%9E%E8%87%AA%E5%8A%A8%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[一维细胞自动机 一维细胞自动机 1234567891011121314151617181920212223242526272829303132333435363738394041424344int [] rules = &#123; 0, 0, 0, 1, 1, 1, 1, 0&#125;; // 生成一维规则int gen = 1; // 回合数，等于当前y轴位置加一color on = color(255); // 设定状态 on 为白色color off = color(0); // 设定状态 off 为黑色void setup() &#123; // 入口函数初始化参数 size(1001, 501); frameRate(8); // 设定较低的帧率 background(0); // 黑色背景 set(width/2, 0, on); // 设定初始状态&#125;void draw() &#123; for (int i = 1; i &lt; width - 1; i++) &#123; // 生成循环 int left = get(i - 1, gen - 1); int me = get(i, gen - 1); int right = get(i + 1, gen - 1); // 规则生效 if (rules(left, me, right) == 1) &#123; set(i, gen, on); &#125; &#125; gen++; if (gen &gt; height - 1) &#123; noLoop(); save("CA.png"); &#125;&#125;int rules (color a, color b, color c) &#123; // 规则 if ((a == on) &amp;&amp; (b == on) &amp;&amp; (c == on)) &#123;return rules[0];&#125; else if ((a == on) &amp;&amp; (b == on) &amp;&amp; (c == off)) &#123;return rules[1];&#125; else if ((a == on) &amp;&amp; (b == off) &amp;&amp; (c == on)) &#123;return rules[2];&#125; else if ((a == on) &amp;&amp; (b == off) &amp;&amp; (c == off)) &#123;return rules[3];&#125; else if ((a == off) &amp;&amp; (b == on) &amp;&amp; (c == on)) &#123;return rules[4];&#125; else if ((a == off) &amp;&amp; (b == on) &amp;&amp; (c == off)) &#123;return rules[5];&#125; else if ((a == off) &amp;&amp; (b == off) &amp;&amp; (c == on)) &#123;return rules[6];&#125; else if ((a == off) &amp;&amp; (b == off) &amp;&amp; (c == off)) &#123;return rules[7];&#125; return 0;&#125; 二维细胞自动机 二维细胞自动机 需要gif相关的库——gifAnimation。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687import gifAnimation.*;GifMaker gifExport; // 声明对象int [][] grid, futureGrid;void setup() &#123; size(940, 500); frameRate(8); grid = new int [width][height]; // 目前的图像像素数组 futureGrid = new int [width][height]; // 下一刻状态数组 // 设定初始状态 float density = 0.3 * width * height; for (int i = 0; i &lt; density; i++) &#123; grid[int(random(width))][int(random(height))] = 1; &#125; background(0); // 设定gif导出相关参数 gifExport = new GifMaker(this, "2D_CA.gif"); gifExport.setRepeat(0); // make it an "endless" animation gifExport.setTransparent(0,0,0); // black is transparent&#125;void draw() &#123; for (int x = 1; x &lt; width - 1; x++) &#123; for (int y = 1; y &lt; height - 1; y++) &#123; // “活着的”相邻细胞数目 int nb = neighbors(x, y); if ((grid[x][y] == 1) &amp;&amp; (nb &lt; 2)) &#123; futureGrid[x][y] = 0; set(x, y, color(0)); &#125; else if ((grid[x][y] == 1) &amp;&amp; (nb &gt; 3)) &#123; futureGrid[x][y] = 0; set(x, y, color(0)); &#125; else if ((grid[x][y] == 0) &amp;&amp; (nb == 3)) &#123; futureGrid[x][y] = 1; set(x, y, color(255)); &#125; else &#123; futureGrid[x][y] = grid[x][y]; &#125; &#125; &#125; int [][] temp = grid; grid = futureGrid; futureGrid = temp; gifExport.setDelay(1); gifExport.addFrame();&#125;// 统计“活着的”相邻细胞数目//int neighbors (int x, int y) &#123;// return grid[x][y-1] +// grid[x+1][y-1] +// grid[x+1][y] +// grid[x+1][y+1] +// grid[x][y+1] +// grid[x-1][y+1] +// grid[x-1][y] +// grid[x-1][y-1];//&#125;// 改进的neighbors()int neighbors (int x, int y) &#123; int north = (y + height - 1) % height; int south = (y + 1) % height; int east = (x + 1) % width; int west = (x + width - 1) % width; return grid[x][north] + grid[east][north] + grid[east][y] + grid[east][south] + grid[x][south] + grid[west][south] + grid[west][y] + grid[west][north];&#125;void mousePressed() &#123; gifExport.finish(); // write file noLoop();&#125;]]></content>
      <categories>
        <category>编程与生活</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[8086汇编总结-指令系统]]></title>
    <url>%2Flangs%2Fasm%2F8086%E6%B1%87%E7%BC%96%E6%80%BB%E7%BB%93-%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[目录 第一章 微型计算机概述 第二章 16位微处理器8086 第三章 指令系统 第四章 汇编语言程序设计 第五章 存储器 第六章 输入/输出接口设计 第七章 中断系统 第八章 可编程接口芯片 第九章 AD/DA 转换 第十章 串行通信 第三章 指令系统 指令系统基本概念 指令是使计算机执行某种特定操作的二进制编码 指令系统是所有指令的集合 一条指令通常包括两部分 操作码：规定所要执行的操作类型 操作数：所需要处理的数据或者数据的地址信息 获得数据或者数据地址信息的方式称为 寻址方式，例： MOV AX, 1234H 指令中有两个操作数，将前者称为目的操作数，后者称为源操作数，该指令将1234H传送到寄存器AX中。 CPU内部操作数寻址 数据寻址方式 立即数寻址 指令中直接给出操作数，指令执行时可以立即得到，此时把操作数又称作“立即数” 例： MOV AL,5 ;AL &lt;- 5 寄存器寻址 操作数放在CPU内部的寄存器中，在指令中直接指出寄存器的名字 例： INC CX ;将CX的内容加1 隐含寻址 指令已经默认是对CPU中的某个寄存器操作 例： DAA ;默认对AL进行十进制加法调整 以上三种方式均直接从CPU内部获得数据，操作速度快 直接寻址 操作数放在存储器中，存储单元的有效地址直接由指令给出 例： MOV SI, [2000H] ;SI &lt;- (2000H，2001H) CPU执行单元EU根据指令的寻址方式计算出16位的偏移量，称为有效地址(EA)，一般用 [有效地址] 表示。 寄存器间接寻址 操作数一定在存储器中，存储单元的有效地址由寄存器指出,寄存器可以为BX、BP、SI、DI， 例： MOV AX, [BX] 若需要对其它段寻址，则必须用前缀指出段寄存器名，又称“段超越” 例： MOV BL, ES:[SI] ;BL &lt;- 扩展段1000H单元的内容 注：IP只能在代码段寻址，SP只能在堆栈段寻址，不能进行段超越 寄存器相对寻址 操作数的有效地址由寄存器内容加上一个8位或16位的偏移量得到 例： MOV AX, [BX+1000H] ;AX &lt;- BX+1000H 所指向的存储单元内容 若BX = 2000H，则将数据段(3000H, 3001H）的内容传送给AX 指令也可书写为： MOV AX, 1000H[BX] 基址变址寻址 操作数的有效地址由基址寄存器和变址寄存器的内容相加产生 例： MOV AX, [BP+SI] ;AX &lt;- (BP+SI) 相对基址变址寻址 操作数的有效地址由基址寄存器、变址寄存器和偏移量三者相加产生 例： MOV AX, [BX+SI+1000H] ;AX &lt;- (BX+SI+1000H) 相对基址变址寻址应用 例：若访问堆栈段中的数组A[100]时，可以用BP存放栈顶地址，用偏移量表示数组中第一个元素到栈顶的距离，用变址寄存器SI（或DI）指向具体数组元素 第4～8种寻址方式，操作数一定在存储器中，由于计算EA、总线操作需要时间，因此比1～3方式慢 I/O端口寻址 操作数在I/O端口中时，必须通过累加器（AX或AL）实现对端口的访问 直接端口寻址 — 指令直接提供8位端口的地址 例： IN AL, 63H ;AL &lt;- (63H) 端口寻址时，地址不加[ ]，当端口地址可用一个字节来表示时,可使用直接端口寻址 间接端口寻址 — 由DX寄存器给出16位端口地址 例： MOV DX, 162H IN AX, DX 从端口162H读取一个字的数据传送到AX中，DX间接表示端口地址 比较： MOV AX, DX ;AX &lt;- DX IN AX, DX ;AX &lt;- (DX) 指令格式 指令一般由1～6个字节组成，具体格式如下： 指令格式 字节1 OPCODE： 指令操作码 D： 操作数传输方向(立即数指令和串操作指令除外) D=0，Reg为源操作数 D=1，Reg为目的操作数 W： 操作数字节长度 W=0，字节操作 W=1，字操作 字节2，寻址方式 MOD：寻址方式字段 00＝存储器方式，指令中无偏移量 01＝存储器方式，指令中有8位偏移量 10＝存储器方式，指令中有16位偏移量 11＝寄存器方式，指令中无偏移量 Reg：寄存器编码字段 000=AL/AX 100=AH/SP 001=CL/CX 101=CH/BP 010=DL/DX 110=DH/SI 011=BL/BX 111=BH/DI R/M：寄存器/存储器字段 在MOD=11,寄存器模式下，R/M给出第二个操作数的寄存器编码 在MOD≠11,存储器模式下，R/M给出计算有效地址的方法 计算有效地址 字节3～字节6 DISP：存储器操作数地址偏移量，长度由MOD字段定义 DATA：指令中的立即数 例： MOV AX, [BX] ;指令码为：8B 07 MOV [BX+SI+2000H], 2345H ;指令码为：C7 80 00 20 45 23 MOV AX, BX ;指令码为：89 D8 8086指令介绍 8086 CPU共有133条指令，根据操作性质，可分为： 传输指令 算术运算指令 逻辑运算和移位指令 串操作指令 控制转移指令 操作数的符号表示 符号 内容 DST 目的操作数 SRC 源操作数 TARGET 循环、转移和调用指令中的目的操作数 REG 寄存器操作数，字节或字 REG8 8位寄存器操作数，字节 REG16 16位寄存器操作数，字 MEM 存储器操作数，字节或字 MEM8 8位存储器操作数，字节 MEM16 16位存储器操作数，字 MEM32 32位存储器操作数，双字 ACC 累加器AL或AX SEG_REG 段寄存器 IMM 立即操作数，字节或字 IMM8 立即操作数，字节 IMM16 立即操作数，字 SHORT_LABEL 短标号，8位偏移量 NEAR_LABLE 近标号，16位地址或偏移量 FAR_LABLE 远标号，32位地址 传送类指令 （一）通用数据传送指令 MOV DST, SRC 操作：DST &lt;- SRC 说明： DST和SRC的组合关系是： REG/MEM &lt;-- IMM REG/MEM &lt;-&gt; REG REG/MEM &lt;-&gt; SEG_REG CS、IP和立即数不能做目的操作数 不能在两个存储单元之间直接传送 MOV指令不改变源操作数，不影响FLAG的状态标志 数据位数由寄存器决定或用说明符指出（如例所示） SS修改后，下一条指令执行完才检测中断，修改SS和SP一定要连续进行 例： MOV AX, 1000 MOV [BP], AX MOV ES, DX MOV word ptr [SI], 1000 MOV byte ptr [SI], AL MOV CS, 100H 错误 MOV [1000H], [2000H] 错误 （二）堆栈操作 SP总是指向栈顶，即最后压入堆栈的信息单元 PUSH SRC 进栈指令 操作：SP &lt;- SP-2，(SP+1, SP) &lt;- SRC 具体指令： PUSH REG16 PUSH SEG_REG PUSH MEM16 例： PUSH BX PUSH CS PUSH [SI] PUSH 1000 错误 POP DST 出栈指令 操作：DST &lt;- (SP+1, SP)，SP &lt;- SP+2 具体指令： POP REG16 POP SEG_REG POP MEM16 例： POP AX POP ES POP [SI] POP CS 错误 说明：堆栈操作以字为单位，按后进先出原则存储数据。POP出栈操作时，CS不能为目的操作数 堆栈主要用于子程序调用、中断子程序的现场保护和恢复、参数传递等。 例：保护现场（保存存储器和恢复存储器次序应一一对应） PUSH DS PUSH ES PUSH AX PUSH BX ;子程序处理 POP BX POP AX POP ES POP DS RET （三）交换指令 XCHG 指令 格式：XCHG DST, SRC 操作：DST &lt;-&gt; SRC 说明：两个操作数必须有一个在寄存器中，可在寄存器之间、寄存器与存储器之间交换信息，目的操作数DST不能为CS 具体指令： XCHG REG, REG XCHG REG, MEM XCHG MEM, REG 例： XCHG AL, byte ptr [2000H] ; AL &lt;-&gt; (2000H) XCHG AX, DX XCHG AX, CS 错误 （四）I/O端口传送指令 IN 输入指令 操作：AL/AX &lt;- (PORT)/(DX)，PORT为8位直接端口地址 具体指令： IN AL, PORT IN AX, PORT IN AL, DX IN AX, DX 例： IN AL, 20H IN AX, 60H IN AL, DX IN AX, DX IN AL, 160H 错误 OUT 输出指令 操作：(PORT)/(DX) &lt;- AL/AX，PORT为8位直接端口地址 具体指令： OUT PORT, AL OUT PORT, AX OUT DX, AL OUT DX, AX 说明：I/O端口地址有直接寻址和间接寻址（通过DX）两种寻址方式。I/O端口操作必须通过累加器AX或AL来完成 （五）换码指令 XLAT 换码指令 具体指令： XLAT 操作：AL &lt;- (BX+AL) 例： MOV AL, 1 MOV BX, 1000H XLAT ;将存储单元1001H的内容送给AL （六）有效地址 (EA) 传送指令 LEA (Load Effective Address) 取有效地址指令 具体指令：LEA REG16, SRC 操作： REG16 &lt;- SRC的有效地址 说明：该指令将源操作数的有效地址送给寄存器 例： MSG db 30H 31H 32H 33H ;定义数据 LEA BX, MSG ;将MSG的偏移地址送BX MOV DX, MSG ;DH=31H, DL=30H ;低位在前,高位在后 LDS (Load DS With Pointer) 地址指针送寄存器和DS 具体指令：LDS REG16, MEM32 操作： REG16 &lt;- (MEM32)，DS &lt;- (MEM32+2) 说明：将源操作数的4个字节，分别传送到指定的寄存器和DS中 例： LDS BX, [1000H] 结果：将(1000H,1001H)内容送BX，将(1002H,1003H)内容送DS LES (Load ES With Pointer) 地址指针送寄存器和ES 具体指令：LES REG16, MEM32 操作： REG16 &lt;- (MEM32)，ES &lt;- (MEM32+2) 说明：将源操作数的4个字节，分别传送到指定的寄存器和ES中 （七）标志寄存器传送指令 LAHF (Load AH with Flag) 标志送AH 格式：LAHF 操作：AH←标志寄存器的低八位 SAHF (Store AH into Flag) AH送标志寄存器 格式：SAHF 操作：标志寄存器的低八位←AH PUSHF (Push the Flag) 标志寄存器进栈 格式：PUSHF 操作：SP←SP-2,(SP+1,SP)←FLAG 栈以字为单位 POPF (Pop the Flag) 标志寄存器出栈 格式：POPF 操作：FLAG ←(SP+1，SP)， SP←SP+2 注：传送类指令除了SAHF和POPF外都不影响标志寄存器 算术类指令 （一）加法指令 ADD 加法 格式：ADD DST, SRC 操作：DST ← SRC + DST 具体指令： ADD REG, REG ADD REG, MEM ADD MEM, REG ADD REG, IMM ADD MEM, IMM ADC (Add With Carry) 带进位加法 格式：ADC DST, SRC 操作：DST ← SRC + DST + CF 具体指令： ADC REG, REG ADC REG, MEM ADC MEM, REG ADC REG, IMM ADC MEM, IMM INC (Increment) 加1 格式：INC DST 操作：DST ← DST + 1 具体指令： INC REG INC MEM 说明：INC指令影响除CF以外的所有状态标志 带进位加法指令ADC应用举例——实现多字节的加法运算 例：有2个4字节无符号数分别存放在数据段2000H和3000H开始的单元中，低位在前，高位在后，将两数相加，结果存放在数据段2000H开始的单元中 MOV SI, 2000H ;SI指向第一个数首地址 MOV DI, 3000H ;DI指向第二个数首地址 MOV AX, [SI] ;取第一个数的低16位到AX ADD AX, [DI] ;两个数的低16位相加 MOV [SI], AX ;低16位相加结果送2000H和2001H单元 MOV AX, [SI + 2] ;取第一个数高16位 ADC AX, [DI + 2] ;两个数高16位连同进位位相加 MOV [SI + 2], AX ;高16位相加结果送2003H和2004H单元 （二）减法指令 SUB (Subtract)减法 格式：SUB DST, SRC 操作：DST ← DST - SRC 具体指令 SUB REG, REG SUB REG, MEM SUB MEM, REG SUB REG, IMM SUB MEM, IMM SBB (Subtract With Borrow) 带借位减法 格式：SBB DST, SRC 操作：DST ← DST - SRC - CF 具体指令： SBB REG, REG SBB REG, MEM SBB MEM, REG SBB REG, IMM SBB MEM, IMM DEC (Decrement) 减1 格式：DEC DST 操作：DST ← DST – 1 具体指令： DEC REG DEC MEM 说明：DEC指令影响除CF以外的所有状态标志 NEG 求补运算 格式：NEG DST 操作：DST ← 模－DST 说明：求指令中给出的操作数的补码 具体指令： NEG REG NEG MEM 说明：字节的模为100H，字的模为10000H CMP 比较指令 格式：CMP DST，SRC 操作：DST －SRC 具体指令： CMP REG, REG CMP REG, MEM CMP MEM, REG CMP REG, IMM CMP MEM, IMM 说明：做减法操作，仅影响标志位，不保存结果 （三）乘法指令 MUL (unsigned Multiple) 无符号数乘法 格式： MUL SRC 操作: AX ← ALSRC 或 {DX, AX} ← AXSRC 具体指令： MUL REG MUL MEM IMUL (signed Multiple) 有符号数乘法 格式： IMUL SRC 操作: AX ← ALSRC 或 {DX, AX} ← AXSRC 具体指令： IMUL REG IMUL MEM 例：将2个32位无符号数DAT1和DAT2相乘，结果保存在64位无符号数Result中 （四）除法指令 DIV (unsigned Divide) 无符号数除法 格式： DIV SRC 操作: AL ← AX/SRC , AH ← AX%SRC ;字节除法 AX ← {DX, AX}/SRC, DX ← {DX, AX}%SRC ;字除法 具体指令： DIV REG DIV MEM IDIV (signed Divide) 有符号数除法 格式： IDIV SRC 操作: AL ← AX/SRC, AH ← AX%SRC ;字节除法 AX ← {DX, AX}/SRC , DX ← {DX, AX}%SRC ;字除法 具体指令： IDIV REG IDIV MEM CBW (Convert Byte to Word) 字节扩展为字命令 格式：CBW 操作：将AL扩展为AX 扩展方法：使用最高位进行扩展。若AL的最高位为0，则扩展后AH全为0；若AL的最高位为1，则扩展后AH全为1 CWD (Convert Word to Double Word) 字扩展为双字命令 格式：CWD 操作：将AX扩展为{DX，AX}，扩展后DX为高16位 扩展方法：使用最高位进行扩展。若AX的最高位为0，则扩展后DX全为0；若AX的最高位为1，则扩展后DX全为1 CBW和CWD只对有符号数进行扩展，无符号数的扩展只需使用MOV指令将其前面AH或DX全部清0。 （五）BCD码调整指令 8086 CPU中没有专用的BCD码运算指令，是使用二进制指令进行BCD码运算，然后再用BCD码调整指令对二进制运算结果进行调整，重新得到BCD码结果。例：DAA调整规则为： 低4位&gt;9 或 AF=1，则结果加06H 高4位&gt;9 或 CF=1，则结果再加上60H 压缩格式BCD码调整指令： DAA ;对加法运算结果AL进行调整 DAS ;对减法运算结果AL进行调整 非压缩格式BCD码调整指令： AAA ;加法调整指令 AAS ;减法调整指令 AAM ;乘法调整指令 AAD ;除法调整指令 例：下列程序段执行后AL=?, CF=? MOV AL, 89H ADD AL, 43H DAA 逻辑类指令 （一）逻辑运算指令 下面排版太困难了，就放弃了。 AND “与”运算命令 格式：AND DST, SRC 操作：DST &lt;- DST &amp; SRC 具体指令： AND REG, REG AND REG, MEM AND MEM, REG AND REG, IMM AND MEM, IMM 逻辑类指令 OR “或”运算命令 格式：OR DST, SRC 操作：DST &lt;- DST | SRC 具体指令： OR REG, REG OR REG, MEM OR MEM, REG OR REG, IMM OR MEM, IMM 逻辑类指令 逻辑运算指令常见用法 清0操作数：XOR AX, AX，不仅把AX清0，而且影响状态标志，至少CF=0, ZF=1（MOV AX,0不影响标志位） 把某几位取反：用XOR指令，把要取反的位和1异或，不变的位和0异或。（例：XOR AL, 80H ;将AL最高位取反） 清0或置位某几位：用AND指令清0，用OR指令置位；要清0的位就与0，要置1的位就或1。 例：清0 MOV AL, 33H ;’3’的ASCII码 AND AL, 0FH ;将高4位清0 置1 MOV AL, 9 OR AL, 30H ;得到9的ASCII码 逻辑类指令 （二）逻辑移位操作命令 SHL 逻辑左移指令 格式：SHL DST, count 操作：操作数整体左移，每次的最高位移到CF，空余位补0 说明：count可以为1，也可为CL，做移位计数 具体指令： SHL REG, 1 SHL REG, CL SHL MEM, 1 SHL MEM, CL 注：1）移位数目大于1时，必需用CL表示； 2）所有逻辑移位操作的具体指令均类似 逻辑类指令 SHR 逻辑右移指令 格式：SHR DST, count 操作：操作数整体右移，最低位到CF，空余位补0 SAL 算术左移指令 格式：SAL DST, count 说明：该指令与SHL逻辑左移指令完全一致 SAR 算术右移指令 格式：SAR DST, count 操作：操作数整体右移，最低位到CF，空余位用符号位补 注: 1）逻辑移位适用于无符号数，算术移位适用于有符号数 2）移位指令常用来做乘以2或除以2的操作 SHL、SAL用来乘以2，SHR、SAR用来除以2 例： MOV CL,5 ;若执行前(DI)=0064H SAR [DI],CL ;执行后(DI)=0003H，相当于100/32=3 逻辑类指令 ROL 循环左移指令 格式：ROL DST, count 操作：操作数整体左移，最高位移到CF，最低位用原来最高位补 ROR 循环右移指令 格式：ROR DST, count 操作：操作数整体右移，最低位移到CF，最高位用原来最低位补 RCL 带进位的循环左移指令 格式：RCL DST, count 操作：类似ROL循环左移，但CF加入到循环圈中 RCR 带进位的循环右移指令 格式：RCR DST, count 操作：类似ROR循环左移，但CF加入到循环圈中 串操作类指令 串操作类指令 对一串字符或数据操作，允许两个操作数均为MEM操作数，分为5种： MOVS (Move String) 串传送 STOS (Store into String) 存AL中数据到串中 LODS (Load from String) 从串中取数据到AL中 CMPS (Compare String) 串比较 SCAS (Scan String) 串扫描 串操作说明 每次完成一个字节或一个字的操作，B表示字节，W表示字 多次操作需用重复前缀，如REP，重复次数由CX决定 默认DS:SI指向存储器源操作数，ES:DI指向存储器目的操作数 SI、DI自动变化，DF指示变化方向 DF=0，SI、DI作增量变化，B: +1，W: +2 DF=1，SI、DI作减量变化，B:－1，W:－2 串操作类指令 重复前缀（CX又称作计数器） REP 重复 REPE / REPZ 相等/为0（ZF=1）则重复 REPNE / REPNZ 不等/不为0（ZF=0）则重复 MOVS 串传送指令 格式：MOVSB 或 MOVSW 操作：MOVSB：(ES : DI) ← (DS : SI)，SI←SI±1，DI←DI±1 MOVSW：(ES : DI) ← (DS : SI)，SI←SI±2，DI←DI±2 说明：使用前缀REP，可完成多次数据传送 例：MOV CX, 12 REP MOVSB ;连续传送12个字节 串操作类指令 STOS 存入串指令 格式：STOSB 或 STOSW 操作：STOSB：(ES : DI) ← AL，DI←DI±1 STOSW：(ES : DI) ← AX，DI←DI±2 说明：可使用REP前缀 LODS 从串中取数据指令 格式：LODSB 或 LODSW 操作：LODSB： AL ← (DS : SI)，SI←SI±1 LODSW：AX ← (DS : SI) ，SI←SI±2 SCAS 串扫描指令 格式：SCASB 或 SCASW 操作：在数据中查找AL或AX中的内容 SCASB：AL － (ES : DI)，DI←DI±1 SCASW：AX － (ES : DI)，DI←DI±2 说明：可使用REPE/REPZ 或 REPNE/REPNZ，仅影响标志位 串操作类指令 CMPS 串比较指令 格式：CMPSB 或 CMPSW 操作：两个MEM操作数的比较，源操作数－目的操作数 CMPSB：(DS : SI) － (ES : DI)，SI←SI±1，DI←DI±1 CMPSW：(DS : SI) － (ES : DI)，SI←SI±2，DI←DI±2 说明：可使用REPE / REPZ 或 REPNE / REPNZ，该指令只影响标志位，不保存结果 条件重复前缀说明 REPE / REPZ 相等或为0时重复 操作：若CX≠0 且 ZF=1 （相等）时继续执行，否则退出 REPNE / REPNZ 不相等或不等于0时重复 操作：若CX≠0 且 ZF=0（不相等）时继续执行，否则退出 串操作类指令 例1：将数据段中1000H开始的10个字节移动到2000H开始的单元 串操作类指令 例2：将数据段中1000H开始的10个字移动到1002H开始的单元去 控制转移类指令 控制转移类指令 该类指令是能够使程序执行流程发生改变的指令，分为5种： 无条件转移和条件转移指令 子程序调用和返回指令 循环控制指令 中断指令 处理器控制指令 指令需要寻找转移地址或调用地址，将此种寻址方式称为程序寻址方式 段内直接转移方式 — 指令中直接给出跳转的相对偏移量 目标转移地址 = IP + 偏移量（8位或16位） 偏移量为8位，称为短跳转，跳转范围：-128 ~ +127个单元 偏移量为16位，称为近跳转，跳转范围：-32768~ +32767个单元 例：JMP 1000H ;转移地址的偏移量由指令给出 控制转移类指令 段内间接转移方式 — 转移地址在寄存器或内存单元中 例：JMP CX ;转移地址由CX给出，执行时将CX值赋给IP JMP [1000H] ;转移地址存放在（1000H, 1001H）单元中 段间直接转移方式 — 指令中直接给出转移地址的段地址和偏移量 例：JMP 2000H:0100H ;执行时，2000H赋给CS, 0100H赋给IP 注：段间直间转移又称作远跳转，该种方式为程序提供了从一个代码段转移到另一个代码段的方法 段间间接转移方式 — 转移地址的段地址和偏移量在内存单元中 例：JMP DWORD PTR [SI] (SI, SI + 1)存放偏移地址，(SI + 2, SI + 3)存放段地址 控制转移类指令 （一）无条件转移指令和条件转移指令 无条件转移指令 JMP TARGET 无条件直接转移指令可以跳转到内存中任何程序段，有四种形式 例： JMP 1000H ;段内直接转移 JMP CX ;段内间接转移 JMP 2000H:0100H ;段间直接转移 JMP DWORD PTR [SI] ;段间间接转移 说明：段内间接转移和段间转移只用于无条件指令 实际使用时多采用符号地址，如： JMP BBB …… BBB: MOV AL, 3 …… 控制转移类指令 条件转移指令 根据判断条件，决定是否跳转，条件转移指令都是段内短跳转 根据单个标志进行跳转的指令 JS ;SF = 1，则跳转 JNS ;SF = 0，则跳转 JO ;OF = 1，则跳转 JNO ;OF = 0，则跳转 JP ;PF = 1，则跳转 JNP ;PF = 0，则跳转 JZ ;ZF = 1，则跳转 JNZ ;ZF = 0，则跳转 JC ;CF = 1，则跳转 JNC ;CF = 0，则跳转 根据CX中的值进行跳转的指令 JCXZ ;CX = 0，则跳转 控制转移类指令 根据无符号数比较结果进行跳转的指令 助记符：A：大于；B：小于；E：等于 JA （JNBE） ;大于，即不小于等于，则跳转 JAE（JNB） ;大于等于，即不小于，则跳转，同JNC JE ;等于，即结果为0，则跳转，同JZ JB（JNAE） ;小于，即不大于等于，则跳转，同JC JBE（JNA） ;小于等于，即不大于，则跳转，CF | ZF = 1 根据有符号数比较结果进行跳转的指令 助记符：G：大于；L：小于；E：等于 JG（JNLE） ;大于，即不小于等于，则跳转 JGE（JNL） ;大于等于，即不小于，则跳转 JE ;等于，与无符号数比较时相同 JL （JNGE） ;小于，即不大于等于，则跳转 JLE （JNG） ;小于等于，即不大于，则跳转 注：根据比较结果跳转时，必须区分有符号数和无符号数，如： 1111 1111b 与 0000 0000b比较 控制转移类指令 （二）子程序调用和返回指令 CALL TARGET 子程序调用指令类似转移指令，也有4种形式 CALL 1000H ;段内直接转移，调用地址偏移量在指令中给出 CALL AX ;段内间接转移，调用地址在AX中给出 CALL 2000H:0200H ;段间直接转移，指令中直接给出调用 ;地址的段地址和偏移量 CALL DWORD PTR [DI] ;段间间接转移，调用地址在内存单元中 执行该指令时，会将下一条指令的地址压入堆栈，该地址称为返回地址 段内调用：只将返回地址的偏移量压入堆栈 段间调用：将返回地址的段地址和偏移量压入堆栈，先压CS，后压IP 实际使用时CALL指令后面直接跟子程序名，例： CALL DISP DISP proc BBB: MOV AL, 3 ……. …… ret DISP endp 控制转移类指令 RET — 子程序返回指令，应与调用指令相对应 执行时，从堆栈顶部弹出返回地址 段内返回：仅从堆栈顶部弹出返回地址偏移量 IP ← (SP)，SP ← SP + 2 段间返回：从堆栈顶部弹出返回地址的段地址和偏移量 IP ← (SP)， SP ← SP + 2； CS ← (SP)，SP ← SP + 2 RET IMM16 — 带立即数返回指令 执行时，从堆栈顶部弹出返回地址，再使SP加上立即数，例：RET 4 控制转移类指令 （三）循环控制指令 循环控制指令均是段内短跳转 LOOP TARGET — 循环指令，循环次数由CX决定 执行时，CX先减1，若为0则退出，否则继续循环，例： MOV CX, 10 ;设置循环次数为10次 BBB: LOOP BBB ;CX减1，若不为0，则循环 …… ;后续处理 LOOPZ / LOOPE TARGET — 条件循环指令 LOOPZ 和LOOPE是同一条指令的不同助记符，执行时，在LOOP指令的基础上，还需判断ZF，若CX != 0 且 ZF = 1则循环 LOOPNZ / LOOPNE TARGET 执行时，在LOOP指令的基础上，还需判断ZF 若CX != 0 且 ZF = 0则循环 控制转移类指令 循环调用指令说明 循环指令不影响状态标志，即CX减为0时不影响FLAG 如果目标位置超出短跳转的范围，则用JMP辅助完成循环 （五）中断指令和中断返回指令 INT n — 中断调用指令 8086指令系统为程序员提供软件中断，利用INT n指令实现 执行时，依次将FLAG，当前CS和IP（即断点地址）压入堆栈，并清除IF和TF标志，执行中断类型码为n的中断程序。 IRET — 中断返回指令 执行时，从堆栈中依次弹出断点地址的IP、CS和FLAG INTO — 溢出中断指令 执行时，判断OF，若为1，则执行中断指令INT 4，否则无操作 （六）控制指令 标志处理指令 CLC / STC / CMC 对CF 清0 / 置位 /取反 CLD / STD 对DF 清0 / 置位 CLI / STI 对IF 清0 / 置位 控制转移类指令 处理器控制指令 NOP — 空操作指令，占用一个字节的机器码，不执行任何操作 HLT — Halt，停机指令，该指令使处理器处于停机状态，以便等待一次外部中断到来 WAIT— 等待指令，该指令使处理器处于空转状态，也可用来等待外部中断的到来 ESC — Escape，换码指令，用作前缀，例：ESC MEM 其中MEM指出一个存储单元，ESC指令把该存储单元的内容送到数据总线去。 LOCK — 封锁指令，用作前缀 该指令与其他指令联合，用来维持总线的封锁信号直到与其联合的指令执行完为止。 80386扩充指令介绍 第3.4节 80386扩充指令介绍 80386为32位CPU，具有独立的32位数据线(D31D0)和34位地址线(A31A2, /BE0~/BE3)，可寻址4GB存储空间，内部寄存器多为32位 80386扩充指令介绍 4. 段寄存器：80386内部设置了6个16位段寄存器CS DS SS ES FS GS 二. 80386寻址方式 在8086寻址方式基础上，80386的所有通用寄存器既可作为基址寄存器，也可作为变址寄存器(ESP除外)，存放地址。 EA = 基址 + 变址×比例因子 + 位移量 比例因子可以为：1、2、4或8，位移量可以为8位、16位或32位 例： MOV ECX, [EAX + EDX * 4 + 1000H] 三. 80386扩充指令 — 1.数据传送指令 1）使用MOV指令时，两操作数位数必须相同，若不同，则用MOVZX或MOVSX MOVZX AX, BL ;若BL=80H，则AX=0080H，MOVZX表示零扩展BL MOVSX AX, BL ;若BL=80H，则AX=FF80H，MOVSX表示符号扩展BL 2）立即数入栈指令 例：PUSH 1000H 3）PUSHA 将全部16位寄存器AX~DI压入堆栈， POPA 则全部出栈 PUSHAD 将全部32位寄存器EAX~EDI压入堆栈， POPAD 则全部出栈 PUSHFD 将EFLAG压入堆栈 POPFD 从堆栈弹出双字到EFLAG 80386扩充指令介绍 4）LSS ESP, MEM ;将MEM开始的存储单元内容送ESP和SS LFS EDX, MEM ;将MEM开始的存储单元内容送EDX和FS LGS EAX, MEM ;将MEM开始的存储单元内容送EAX和GS 5）CWDE ;将AX扩展为EAX CDQ ;将EAX扩展为(EDX, EAX) 2. 算数运算指令扩充 1）IMUL SRC AX &lt;- AL * SRC ;字节乘法 EAX &lt;- AX * SRC ;字乘法，高16位同时也放在DX中，兼容8086 (EDX, EAX) &lt;- EAX * SRC ;32位数乘法 另外操作数可为2个8位数、2个16位数、2个32位数，例： IMUL DX, [1000H], 300 ;DX = (1000H) * 300 IMUL ECX, 2000 ; ECX = ECX * 2000 IMUL BX, CX ;BX = BX * CX 2）MUL SRC ;与IMUL指令类似 80386扩充指令介绍 3）DIV与IDIV指令 — 可用AX, (DX, AX), (EDX, EAX)作为被除数，例： DIV BL ;AL = AX / BL, AH = AX % BL DIV BX ;AX = (DX, AX) / BX, DX = (DX, AX) % BX DIV ECX ;EAX = (EDX, EAX) / ECX, EDX = (EDX, EAX) % ECX 3. 逻辑指令扩充 1）逻辑操作与8086一样，只是逻辑指令还可用于32位操作数 2）增加了2条可对64位操作数进行移位的指令SHLD和SHRD SHLD EDX, EAX, 5 ;EDX左移5位, 低5位由EAX的高5位填充 ;且EAX中内容不变 SHRD EAX, EBX, CL ;EAX右移CL位, EAX高位由EBX的低位 ;填充，EBX的值保持不变 4. 串操作指令扩充 1）增加了32位数的串操作 例： MOVSD ;表示传送一个双字 2）增加字符串输入INS和字符串输出OUTS指令，必须使用DX存放端口号 MOV DX, 160H ; 从160H端口连续读10个双字存放到ES:EDI指向的存储单元 MOV CX, 10 REP INSD 80386扩充指令介绍 5. 转移、循环和调用指令 1）JECXZ TARGET ;若ECX = 0，则跳转 2）使用CALL指令时 段内调用：将EIP压入堆栈，保存4个字节 段间调用：将CS:EIP共6字节压入堆栈 3）RET和RET n指令 出栈时，操作应与CALL指令相对应 6. 条件设置指令 — 80386新增指令 格式： SETcond REG8/MEM8 ;cond为设置条件 例： SETZ AL ;若ZF = 1，则置AL为1，否则置0 SETGE CL ;有符号数比较大小时，若大于等于，则置CL为1 SETO [100H] ;若OF = 1，则置[1000H]存储单元为1，否则置0 7. 位处理指令 — 80386新增指令 BTS ;将指定位置1 BTR ;将指定位清0 BTC ;对指定位取反 BT ;对指定位进行测试 BSF ;从最低位往最高位扫描，若全为0，则ZF置1，若某位为1，则 ;ZF清0，且将此位的位号放入目的寄存器 80386扩充指令介绍 BSR ;从最高位往最低位扫描，若全为0，则ZF置1，若某位为1，则 ;ZF清0，且将此位的位号放入目的寄存器 例： BTC AX, 2 ;将AX的D2位装入CF，再对AX的D2位取反 BTS [100H], 4 ;将[100H]单元的D4位装入CF，再将D4位置1 BTR BL, CL ;将CL的值作为位的序号，将BL的此位送CF， ;再将BL的此位清0，若CL的值大于8，则将CL ;的值对8取余得到位序号 BT AL, CL ;将CL的值作为序号，对AL的此位进行测试 BSF AX, [2000H] ;对[2000H]开始的一个双字，从D0往D31 ;扫描，若全为0，则ZF = 1，否则ZF = 0， ;且将此位序号送AX BSR EAX, ECX ;对ECX从D31往D0扫描，若全为0，则置 ;ZF=1，否则ZF=0，并将此位序号送EAX]]></content>
      <categories>
        <category>编程与生活</category>
      </categories>
      <tags>
        <tag>汇编</tag>
        <tag>计算机原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[8086汇编总结-微型计算机概述]]></title>
    <url>%2Flangs%2Fasm%2F8086%E6%B1%87%E7%BC%96%E6%80%BB%E7%BB%93-%E5%BE%AE%E5%9E%8B%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[目录 第一章 微型计算机概述 第二章 16位微处理器8086 第三章 指令系统 第四章 汇编语言程序设计 第五章 存储器 第六章 输入/输出接口设计 第七章 中断系统 第八章 可编程接口芯片 第九章 AD/DA 转换 第十章 串行通信 第一章 微型计算机概述 微型计算机基本组成： 冯诺依曼结构 CPU（Central Processing Unit 中央处理单元 ） ALU (Arithmetic Logic Unit 算术逻辑单元) 控制器 Memory RAM (读写存储器） ROM (只读存储器) I/O接口 - 主机与外设的匹配连接 BUS（总线）：计算机用来传输信息的一组通信线 AB (地址总线)：用于传递地址信息，单向，成组使用，地址总线的宽度决定了CPU直接寻址内存的范围。如：8086有20根地址线，即地址总线宽度为20位，可寻址2^20B = 1MB DB (数据总线)：用于传递数据信息，双向，成组使用，计算机的位一般是指数据总线的宽度。如：8086有16根数据线，因此8086为16位机 CB (控制总线)：用于传输控制信号，以便控制计算机各部件协调工作， 各自独立使用，有发出，也有接收。如：CPU向存储器发出的读信号、写信号 地址数据复用总线：地址总线与数据总线共用一组通信线，分时传送地址，信息和数据信息（由同步信号区分），节省CPU引脚 微型计算机系统（MCS -- Micro-Computer System） 以微型计算机为主体，配上系统软件就构成微型计算机系统。 系统软件包括操作系统和一系列系统应用程序 如编辑程序、编译程序、调试程序等 有了系统软件才能发挥微机的硬件功能 外设 输入设备：鼠标、键盘、扫描仪 输出设备：显示器、打印机、投影仪 IBM PC/XT系统板框图 微处理器、单板机和单片机概念 微处理器 专指中央处理器(CPU)，是将计算机的运算器(ALU)和控制器集成在一个芯片上。 如：8086，80386，Pentium，PII等 单板机 将CPU、存储器、I/O口以及简单的外设集成在一块板上，是一个简单的计算机系统。 如：TP801A等。 单片机 将CPU、存储器、I/O口集成在一个芯片上。 如：Intel MCS-48，MCS-51，MCS-96等 微型计算机发展 CPU位数不断增加，集成度不断提高，频率不断提高 计算机的位 CPU片内数据总线的宽度决定了计算机的位数 如：8位，16位，32位，64位，128位 准16位机 CPU片内数据线宽度为16位，片外数据线宽度为8位 如：8088，8098 由单处理器向多处理器发展 指令系统由复杂指令集向精简指令集发展 复杂指令集计算机（CISC – Complex Instruction Set Computer） 精简指令集计算机（RISC – Reduced Instruction Set Computer） Intel在Pentium之前的CPU均属于CISC体系，从Pentium开始将CISC和RISC相结合，Pentium大多数指令是精简指令，但仍保留了一部分复杂指令 计算机中的信息表示 计算机使用二进制存储，但书写时常用16进制 计算机内所有代码以二进制表示，机器码又称二进制码 1位16进制数对应半个字节（4位二进制码） 例：1000 0101 B 二进制；85 H 16进制 注：书写16进制数时，若最高位是字母，则前面加0，表示是数据，如0FEH 一些进制的简化符号: 2进制 - B(Binary)、 16进制－ H(Hex) 8进制 - O(Octal)、 10进制 - D(Decimal) 无符号数表示 二进制无符号数 — 码值与数值相等 一个n位二进制无符号数表示的范围是0～(2^n - 1) 例：8位二进制无符号数表示的范围是0～255，16位二进制无符号数表示的范围是0～65535 BCD码(Binary Coded Decimal) - 用半个字节表示1位十进制数 压缩BCD码: 用1个字节表示2位BCD码，又称8421BCD码 非压缩BCD码：用1个字节的低四位表示1位BCD码，高四位忽略 例 00111001b 在压缩格式下表示：39；在非压缩格式下表示：9 有符号数表示 原码 将最高位作为符号位，正数的符号位为0，负数的符号位为1，余下的其他位为数值位 反码 正数的反码与原码相同； 负数的反码由该负数的原码按位取反(符号位除外)得到 补码 正数的补码与原码相同。 负数的补码由该负数的原码按位取反(符号位除外)加1得到 计算机内有符号数默认用补码表示 一个字节有符号数范围 原码表示： -127～+127 有+0，-0 1111 1111b – 1000 0000b - 0000 0000b – 0111 1111 -127 -0 +0 +127 反码表示：-127～+127 有+0，-0 1000 0000b – 1111 1111b – 0000 0000b – 0111 1111b -127 -0 +0 +127 补码表示：-128～+127 只有一个0 1000 0000b – 1111 1111b - 0000 0000b – 0111 1111b -128 -1 0 127 一个字的补码表示范围: -32768 ~ +32767 (只有一个0) 1000 0000 0000 0000 ~ 1111 1111 1111 1111 -32768 -1 0000 0000 0000 0000 ~ 0111 1111 1111 1111 0 +32767 举例说明 计算机内一个字节为 81H =&gt; 1000 0001b 二进制 129 （二进制无符号数） BCD码 81 （压缩格式BCD码） 原码 -1 反码 -126（1111 1110b —&gt; 1000 0001b） 补码 -127（1111 1111b —&gt; 1000 0000b—&gt;1000 0001b） 一个代码，赋予不同类型，其数值不一样。而类型要由人编程指定 数学运算时，结果超出运算器所表示范围则会产生“溢出” 无符号数：通过进位或借位标志C标记“溢出”，避免产生错误结果 有符号数：用标志O标记“溢出”，表示运算结果错误 字节运算，结果超出-128～127，则为溢出 字运算，结果超出-32768～32767，则为溢出 一般可以直接判断运算过程来确定是否溢出 - 双高位判别法：最高位（符号位）是否有进借位Cs异或次高位（数值的最高位）是否有进借位Cp。溢出 = Cs xor Cp 字符代码 ASCII码 — 美国标准信息交换码 用7位二进制数表示128个字符 包含26个英文大、小写字母，数字0～9，符号和命令符等 ASCII码在计算机内用一个字节表示，最高位一般为0，有时候用作校验位，计算机与外设交换信息一般都用ASCII码 如：字符显示器，字符打印机等 注：需牢记字符 ‘0’～‘9’,‘A’～‘F’，‘a’～‘f’的ASCII码分别为30H～39H, 41H～46H， 61H～66H 汉字内码 GB2312定义了6763个汉字，其中一级字库3755字，二级字库3008字 其他编码方式 硬件基础知识补充 计算机硬件主要由 逻辑门、触发器（D触发器）、三态门构成，使用器件为 CMOS、TTL和NMOS。 TTL和CMOS电平范围如下表所示： TTL和CMOS电平范围 要了解逻辑电平的内容，首先要知道以下几个概念的含义： 输入高电平（ViH）： 保证逻辑门输入为高电平时所允许的最小输入电压，当输入电平高于ViH时，则认为输入电平为高电平。 输入低电平（ViL）：保证逻辑门的输入为低电平时所允许的最大输入电压，当输入电平低于ViL时，则认为输入电平为低电平。 输出高电平（VoH）：保证逻辑门的输出为高电平时的最小输出电压，逻辑门的输出为高电平时的电平值都必须大于此VoH。 输出低电平（VoL）：保证逻辑门的输出为低电平时的最大输出电压，逻辑门的输出为低电平时的电平值都必须小于此VoL。 阀值电平 (Vt)： 数字电路芯片都存在一个阈值电平，就是电路刚刚勉强能翻转动作时的电平。它是一个界于ViL、ViH之间的电压值，对于CMOS电路的阈值电平，基本上是二分之一的电源电压值，但要保证稳定的输出，则必须要求输入高电平&gt; ViH，输入低电平 &lt; ViL，而如果输入电平在阈值上下，也就是ViL～ViH这个区域，电路的输出会处于不稳定状态 逻辑门 重点在于其图像。直与弯或。 三态缓冲器 三态门 三态门 单向三态缓冲器 — 74LS244 74LS244为TTL的单向三态缓冲器，有两个三态控制使能引脚G1和G2分别控制4个三态门 双向三态缓冲器 — 74LS245或INTEL 8286 74LS245为TTL双向三态缓冲器，有控制引脚DIR和EN 锁存器 D触发器 具有异步清零的TTL上升沿锁存器－74LS273 当CLK上升沿到来时，将输入端的数据D0～D7锁存到输出端Q0～Q7，当CLR为低电平时将锁存器输出清零（具体逻辑可见对应的芯片图） 具有缓冲输出的TTL低电平锁存器－74LS373或INTEL8282 OE为低电平时，输出三态门打开，此时LE为高电平，Q7～Q0跟随D7～D0；LE为低电平，数据锁存 OE为高电平时，输出Q7～Q0为三态 计算机内的总线连接 为减少计算机内各部件之间的连线，采用总线结构，使各部件共用一组数据线。 输入数据到总线的部件，一定要使用三态电路作缓冲 需输出数据时，打开三态门，占用总线，传输信息 不输出时，关闭三态门，使输出处于高阻状态，让出总线，不影响其它部件使用总线 从总线输出数据的部件，常采用D触发器锁存总线数据 常用总线技术 时分技术：计算机内各部件之间的信息传送分时进行 频分技术：CATV 有线电视，分频复用 类型 一个计算机系统包含多种类型总线，按 所处位置可分为： 内部总线 位于CPU芯片内，用于连接片内各功能部件的总线 内部总线的对外引线叫做CPU总线 局部总线 位于主机板上，用于连接主机板上各个主要部件，并通过扩展槽连接各种适配器（显卡、网卡、声卡） 常见的有ISA、EISA、PCI总线 ISA — Industry Standard Architecture EISA — Extension Industry Standard Architecture PCI — Peripheral Component Interconnect 系统总线 位于机箱底板，多个CPU插件板以此互相连接，在PC机中，一般不用，常见的有MULTIBUS、VME等 外部总线 是微机与外部设备之间或几个微机系统之间的通信总线，如： IDE (Integrated Drive Electronic)总线，专用于连接硬盘 SCSI (Small Computer System Interface)，专用于连接硬盘 Centronics总线，用于与并行打印机连接 USB (Universal Serial Bus)总线，用于连接USB设备 总线性能 主要从三方面来衡量 总线宽度：指总线一次可以同时传输的数据位数 如：ISA为16位总线，一次可传输16位二进制数，EISA、PCI为32位总线 总线频率：指总线每秒能传输数据的次数 如：ISA、EISA的频率为8MHz，PCI的频率为33MHz，PCI-2的频率为66MHz 传输率：指每秒钟能够传输的字节数，用MB/s表示 传输率 = 宽度/8 ×频率 例：PCI总线宽度为32位，频率为33MHz，则传输率 = 32b / 8 ×33 = 132MB/s，即PCI总线每秒能够传输132M字节 微机的层次化总线 微机的层次化总线 CPU总线 CPU芯片内部总线的对外引线 连接与CPU最密切、速度最快的部件，如二级Cache PCI总线控制器 像桥梁一样，一边连接CPU总线，一边连接CPU访问相对频繁、速度相对较快的部件，又称“PCI桥” 如：通过PCI总线连接主存储器，通过AGP总线连接高速图形卡 可级联下一级PCI总线控制器，形成多级PCI总线，容纳更多PCI卡 PCI转换桥 完成PCI总线与ISA或EISA总线的连接转换 ISA总线：总线宽度16位，总线频率8MHz，传输率16MB/s 24位地址线，16位数据线 由主槽和扩展槽两部分组成，主槽为62脚，对应早期IBM PC/XT系统的62芯总线槽，扩展槽为36脚 为和大量ISA适配卡兼容，目前计算机仍然通过“桥”来扩展ISA总线 EISA总线：是ISA的扩展，总线宽度32位，总线频率8MHz，传输率32MB/s 32位地址线，32位数据线，能自动进行8位、16位、32位数据访问 共198条信号线，98条为ISA原有的，扩展了100条信号线 PCI总线：目前微机中应用最广泛的局部总线 总线宽度32位，总线频率33MHz，传输率为132MB/s 支持即插即用功能 1234567891011面对更大数据量传送的需求，传统PCI总线已无法满足应用要求，因此现在的设计对其进行扩展，称作PCI-X总线：PCI-X 66 64位 66MHz Hot Plugging, 3.3 V 533MB/sPCI-X 133 64位 133MHz Hot Plugging, 3.3 V 1.06GB/sPCI-X 266 64/16位 133MHz Double Data Rate Hot Plugging, 3.3 &amp; 1.5 V, ECC supported 2.13GB/s （主要应用到DDR内存）PCI-X 533 64/16位 133MHz Quad Data Rate Hot Plugging, 3.3 &amp; 1.5 V, ECC supported 4.26GB/s （主要应用在DDR2内存）说明：1. PCI-X 266 用上Double Data Rate技术，让每一个时钟脉冲的上升与下降边缘都可以传输数据，所以有多出了一 倍的机会来传输数据2. PCI-X 533规格更进一步采用每一个时钟脉冲可以传送四次（Quad Data Rate）的技术]]></content>
      <categories>
        <category>编程与生活</category>
      </categories>
      <tags>
        <tag>汇编</tag>
        <tag>计算机原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[8086汇编总结-16位微处理器8086]]></title>
    <url>%2Flangs%2Fasm%2F8086%E6%B1%87%E7%BC%96%E6%80%BB%E7%BB%93-16%E4%BD%8D%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A88086%2F</url>
    <content type="text"><![CDATA[目录 第一章 微型计算机概述 第二章 16位微处理器8086 第三章 指令系统 第四章 汇编语言程序设计 第五章 存储器 第六章 输入/输出接口设计 第七章 中断系统 第八章 可编程接口芯片 第九章 AD/DA 转换 第十章 串行通信 第二章 16位微处理器8086 微处理器性能指标 微处理器性能指标主要有2项： 字长：指CPU能同时处理的数据位数 如：8086为16位字长，80386为32位字长 主频：即CPU时钟频率，主频越高，速度越快 如：8086为5MHz，80386为16MHz，Pentium IV可达3GHz 指令执行过程 取指令 -&gt; 指令译码 -&gt; 指令执行 微型计算机的工作过程，也就是不断地取指令、译码和执行的过程，直到遇到停机指令时才结束机器的运行。 流水线的概念 cpu流水线技术是一种将指令分解为多步，并让不同指令的各步操作重叠，从而实现几条指令并行处理，以加速程序运行过程的技术。指令的每步有各自独立的电路来处理，每完成一步，就进到下一步，而前一步则处理后续指令。 8086内部结构 8086内部结构 (EU Execution Unit)执行单元:负责 指令的译码和执行 (BIU Bus Interface Unit)总线接口单元:负责与存储器、I/O口传送数据 总线接口单元BIU 具体功能 负责从内存取指令送到CPU内部的指令队列 CPU执行指令时，配合EU从指定存储单元或I/O口取数据，或把运算结果传送到指定存储单元或I/O口 组成 4个16位段地址寄存器 CS (Code Segment) —代码段寄存器，代码段存放代码 DS (Data Segment) —数据段寄存器，数据段存放数据 SS (Stack Segment)—堆栈段寄存器，堆栈段用作堆栈操作 ES (Extra Segment)—扩展段寄存器，扩展段存放数据 注：8086对存储器采用分段管理，4个段寄存器分别存放4个当前段的段地址，又称作段基址寄存器。 指令指针寄存器IP (Instruction Pointer) 16位IP存放当前代码段(CS)所要取出的下一条指令的偏移地址 地址加法器∑ 8086用20位地址线寻址1MB内存空间，但其内部寄存器是16位的，因此需要用地址加法器∑根据16位寄存器的值计算出20位物理地址 指令缓冲队列 8086执行指令的同时，会从内存取1条或几条指令，取来的指令就存放在指令队列中，8086执行完一条指令就可立即执行下一条指令，无需轮番的取指令和执行指令，提高了CPU效率； 8086指令队列为6个字节，8088指令队列为4个字节； 其他 暂存器：用于与EU通信的内部寄存器 总线控制电路：负责总线操作控制 执行单元EU 16位算术逻辑单元ALU 主要是加法器，绝大部分指令执行都由加法器完成 4个16位数据寄存器（AX、BX、CX、DX） 可分为8个8位寄存器使用AH、AL、BH、BL、CH、CL、DH、DL 数据寄存器用于存放操作数及中间结果，AX和AL可用作累加操作，因此又称作累加器 4个16位地址指针寄存器：通常用于存放操作数偏移地址 SP (Stack Pointer) — 堆栈指针寄存器，指示堆栈段栈顶位置 BP (Base Pointer) — 基址指针寄存器，指示堆栈段数据区基址 SI (Source Index) — 源变址寄存器，指示数据段源串地址 DI (Destination Index) — 目的变址寄存器，指示扩展段目的串地址 标志寄存器 FLAG 6位状态标志，3位控制标志IF、DF、TF，剩下7位保留 标志寄存器 状态标志： CF（Carry Flag）进(借)位标志，加法运算最高位产生进位或减法运算最高位产生借位，则CF置1，否则置0 AF（Auxiliary Carry Flag）辅助进位标志，加法运算时第3位往第4位有进位，或减法运算时第3位往第4位有借位，则AF置1，否则置0 ZF（Zero Flag）零标志, 若当前运算结果为零, 则ZF置1,否则置0 SF（Sign Flag）符号标志，与运算结果最高位相同，若为负数，则SF置1，否则置0，SF指示了当前运算结果是正还是负 OF（Overflow Flag）溢出标志，有符号数算术运算结果溢出，则OF置1，否则置0 PF（Parity Flag）奇偶标志，运算结果低8位所含1的个数为偶数则PF置1，否则置0，即奇校验低八位 控制标志： DF（Direction Flag）方向标志 DF=1，串操作时，地址不断递减；DF=0，串操作时，地址不断递增 IF（Interrupt enable Flag）中断允许标志 IF=1，CPU允许接收可屏蔽中断请求，即开中断；IF=0，则关中断 TF（Trap Flag）跟踪标志，又称单步标志 TF=1，CPU为单步工作方式，每执行完一条指令产生一次软件中断 TF=0，CPU为正常工作，连续处理指令 BIU与EU的配合 指令队列中出现两个字节为空时，BIU自动按CS和IP值组成20位物理 地址，到存储器中取指令，一次取两个字节指令存放到指令队列中 EU从BIU指令队列中读取指令 由EU控制电路对指令进行译码分析，指出操作性质及操作对象 EU执行指令，如需访问存储器或I/端口中的数据，则由EU给出数据 的16位偏移地址送给BIU BIU由地址加法器∑形成20位绝对物理地址,并传递给存储器 存储器给出数据，BIU通过总线控制电路将其传送到CPU内部总线 EU将从内部总线获得数据，并送入ALU进行运算 EU运算出的结果，经内部总线送到指定的寄存器或暂存器，若需要将结果送给存储器，则由EU给出偏移地址，请求BIU产生20位实际物理地址，将结果写入存储器 存储器和I/O管理 8086存储器编址 8086具有20位地址线，可寻址1MB存储空间，编址为00000H～FFFFFH 8086存储器管理 8086对存储器采用分段管理，将1MB空间分为若干个段，每段最多为64KB，一个程序可以有代码、数据、堆栈和扩展数据4个部分，每部分又可包含一个或几个段，代码部分包含的段均称为代码段，其余部分类似，分别由CS、DS、SS、ES指示每部分当前正在操作的段起始地址。实际CS、DS等存放的是20位段起始地址的高16位，即段地址。 对存储单元访问时，需要知道该存储单元所在段的起始地址，还需要知道该存储单元距离段起始位置的偏移量，即偏移地址，才能访问该存储单元。由于每段大小不会超过64KB，因此偏移地址用16位表示。 由于段寄存器是16位，偏移地址也为16位，而一个存储单元的物理地址是20位，因此8086需要通过地址加法器∑根据段地址和偏移地址形成20位物理地址。段地址和偏移地址组合称为逻辑地址。 逻辑地址形式为 -&gt; 段地址 : 偏移地址 20位物理地址的形成 (物理地址) 20 = 段地址左移4位 + 偏移地址 (物理地址) 20 = (段地址)*16 + 偏移地址 例：若逻辑地址为FFFFH : 0000H，则对应的物理地址为： F F F F | 段地址 16位 + 0 0 0 0 | + 偏移地址 16位 ------------------ | ----------------- F F F F 0 | 物理地址 20位 **段寄存器 -&gt; 段地址，地址指针寄存器 -&gt; 偏移地址* 二者配对使用 存储器管理的几点说明 一个段总是从16字节边界开始，20位段起始地址的低4位总为0 同一个物理地址可以采取不同的逻辑地址形式表示 例：物理地址 12345H 可表示为1200 : 0345H 或 1230 : 0045H 尽管代码段、数据段、堆栈段、扩展段均为64KB，但实际应用时，不同段可以相互重叠或重合，但段内地址连续 基本的对应的使用关系可见下图 段寄存器的对应关系 8086 I/O 编址 8086用低16根地址线，寻址64KB的I/O端口，编址为0000H～FFFFH 一个I/O端口通常对应I/O接口电路中的一个存储单元，微机为每个端口分配一个地址，即为端口号 实际使用中8086只使用低10根地址线，寻址1KB的I/O端口 8086对I/O端口操作，需要专门的IN、OUT指令，并且只能通过累加器（AX/AL）来完成，例： IN AL, 80H 8086系统中，存储器和I/O端口分别独立编址 存储器的地址范围是 00000H – 0FFFFFH I/O端口的地址范围是 0000H – 0FFFFH 8086引脚信号和工作模式 最小模式与最大模式 两种工作模式，由 \(MN/\overline{MX}\) 引脚决定。 最小模式：系统中只有一个处理器；\(MN/\overline{MX}\)为高电平； 最大模式：系统中包括两个或多个处理器；\(MN/\overline{MX}\)为低电平。 不同模式下，部分引脚定义不同 8086引脚信号和功能 8086引脚图和引脚分类图 8086 CPU为40pin双列直插（DIP)封装 8086引脚分类图 最小模式下引脚信号和功能 1）总线信号 ① AD0～AD15: 地址/数据复用引脚，双向工作。分时传送16位数据和地址的低16位，由ALE锁存地址信息。 ② A16～A19（S3～S6）: 地址/状态复用引脚，输出。分时输出地址的高4位和CPU当前状态，地址信息由ALE锁存。 ③ BHE/S7: 高8位数据总线允许/状态复用引脚，输出。低电平有效，表示高8位数据线D15～D8上数据有效 ④ ALE: 地址锁存允许信号输出。高电平有效，表示总线上的信息是地址信息。 2）总线控制信号 ① HOLD: 总线保持请求信号输入。高电平有效，表示其他模块（如DMA)申请占用总线 ② HLDA: 总线保持响应信号输出，高电平有效，表示CPU已让出总线 3）系统控制信号 ① M/IO: 存储器/输入输出选择信号，输出，高电平表示CPU访问存储器，低电平表示CPU访问I/O端口 ② RD: 读信号输出，低电平有效，表示CPU从存储器或I/O口读入信息 ③ WR: 写信号输出，低电平有效，表示CPU向存储器或I/O口输出数据 ④ DT/R: 数据收发信号输出。高电平表示CPU正在发送数据，低电平表示CPU接收数据 ⑤ DEN: 数据允许信号输出。低电平有效，表示CPU当前准备发送或接收一个数据 4）中断控制信号 ① INTR: 可屏蔽中断请求信号输入。高电平有效，表示外部向CPU提出中断申请 ② INTA: 中断响应信号输出，低电平有效，表示CPU响应外设中断请求 ③ NMI: 非屏蔽中断请求信号输入。上升沿有效。表示外部有非屏蔽中断申请。非屏蔽中断不受软件控制，CPU必须响应 5）CPU控制信号 ① RESET: 复位信号输入。高电平有效，至少保持4个时钟周期的高电平。复位时CPU停止现行操作，开始复位，并进行初始化：标志寄存器FLAG、IP、DS、SS、ES及指令队列均清零，CS为FFFFH，复位结束时CPU从FFFF0H开始执行程序 ② MN/MX：最小模式/最大模式选择信号输入 ③ READY：“准备好”信号输入，高电平有效，表示存储器或I/O口已准备就绪，可进行一次数据传输 ④ TEST: 测试信号输入，低电平有效，有效时CPU退出WAIT指令 6）其它信号 ① CLK: 时钟信号，8086主频为4.77MHZT=210ns；单相，占空比为1/3。 ② VCC,GND: 电源及地，+5V，满足TTL规范 最大模式下8086有8个控制信号被重新定义，对应关系如下： 最大模式重新定义 8088引脚信号与功能 8088为准16位机，片内数据总线宽度为16位，片外为8位，引脚信号和功能与8086类似，二者 差别如下： 8086微处理器 8088微处理器 16位AD复用 8位AD复用 BHE高八位数据允许 SS0/高电平 M/IO引脚选择存储器/IO口 M/IO引脚选择存储器/IO口 总线连接 8086最小模式下的总线连接 很重要的图。 8086最小模式连接图 1）Intel 8282 把AD复用引脚连接到地址总线的8位地址锁存器。3片8282(功能同74LS373)A0～A19和BHE，ALE为锁存信号。 2）Intel 8286 把AD复用引脚连接到数据总线的8位数据缓冲器。2片8286(功能同74LS245)做D15～D0的缓冲器，DT/R做方向选择，DEN为选通信号。 3） 控制信号M/IO、RD和WR 完成信息传递控制。组合起来完成右面的控制。 4）中断控制信号INTR、INTA、NMI INTR: 外部可屏蔽中断请求引脚，高电平有效 INTA: 中断响应信号，低电平有效 NMI: 不可屏蔽中断请求引脚，上升沿有效 5）总线控制信号HOLD、HLDA HOLD：总线保持请求引脚,高电平有效 HLDA：总线保持响应引脚，高电平有效 HLDA控制8282的OE，当CPU总线保持响应时让出总线 8086最大模式下的总线 8086最大模式下总线连接 8086时钟电路与复位电路 8086时钟电路与复位电路 8284为8086提供CLK时钟信号、RESET复位信号和READY准备好信号 8086/8088内部无时钟发生器，时钟由8284提供，频率为4.77MHz 输入/RES经8284内部斯密特触发器整形，同步后产生RESET信号,给CPU复位 外界准备好信号输入到8284的RDY端，同步后产生READY信号给CPU 8284内部逻辑图 8086/8088系统的复位操作和启动过程 CPU接到RESET信号，停止现有工作，进行复位操作：CS置FFFFH，IP置0，指令队列清空，其余寄存器清0； 从存储器FFFFH :0000H取第一条指令，一般在此处放一条跳转指令，跳转到ROM BIOS中的系统测试程序； 系统测试程序执行硬件自检(对CPU、RAM、ROM等硬件进行测试)，然后执行ROM BIOS中的初始引导程序； 初始引导程序再从磁盘0面0道1扇区装入引导程序，执行引导操作； 按引导程序的指令，顺序装入其他程序模块，完成操作系统的引导操作； 注：在3、4步之间微机还会检查C0000H开始的扩展ROM空间中是否有程序，如果有，并且校验正确，则先执行这些程序 8086总线周期 CPU取指令或传送数据时，均需要通过BIU进行总线操作，而总线操作是 根据时钟脉冲CLK一个节拍一个节拍的完成。 时钟周期T（T状态） 时钟脉冲的一个循环时间叫做一个时钟周期。每个时钟周期T又称为一个“状态”。它是CPU工作的最小时间单位，是计算机系统工作速度的重要标 志。8086 CPU的F=4.77M，T=210ns 总线周期 CPU通过总线从存储器或I/O端口存取一个字或字节的时间称为总线周期 包括三类：存储器读写周期、I/O端口读写周期、中断响应周期 一个基本总线周期包括4个状态：T1，T2，T3，T4 指令周期 执行一条指令所需要的时间称为指令周期。8086指令周期最短为2个时 钟周期，最长为200个时钟周期。 例：时钟周期、总线周期、指令周期举例 各种周期 在总线周期的T3状态，CPU会检查READY引脚，若为低电平无效，则CPU会在T3之后插入等待周期Tw，等待外界准备好，在每个Tw状态会继续检查READY引脚，直到READY变为高电平有效才进入T4状态 在两个总线操作中间，系统总线处于空闲状态，CPU便会在两个总线周期之间插入空闲周期Ti，在Ti状态，CPU不执行任何总线操作 8086总线操作时序 这里的图上的BHE描述的是8282锁存前方位置的信号。所以T2会有变换。实际上真正到了存储存储器作用的是被锁存住的信号。 时序]]></content>
      <categories>
        <category>编程与生活</category>
      </categories>
      <tags>
        <tag>汇编</tag>
        <tag>计算机原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017年总结]]></title>
    <url>%2Flife%2F2017%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[一 2017年转瞬即逝，倏忽间，便已是2018。 回顾2017，我所希望的目的是，可以找到自己的不足，找到更多的缺点，找到，那个熟悉的自己。 二 人生天地之间，若白驹之过隙，忽然而已。 一七年，是鸡年，我已经忘了春晚是什么样子，我也忘了年初那个寒假，是如何度过的。 一七年，已经陷入了遗忘的轮回。所有的色彩都在变得稀薄，所有的味道都在变得寡淡，所有的人影都在变得模糊。 记忆的长廊里，愈发的在被新时光填充，新的色彩绘成了新的画面，挂在了墙上，新的声音汇成了新的曲调，飘荡在空气中。 这一年里，过得匆忙，还没反应过来，就已经到了年末，新的年初。 这一年，学了好多的课程，但是印象最深的不过计算机原理和随机信号分析，主要是因为和这两门课的老师联系比较密切。给他们留下了比较好的印象。 接触了8086汇编，学到了计算的组成所涉及到的方方面面，顿时对于眼前所面对的这个东西多了一份熟悉感。 之后会整理一下汇编语言的知识。 随机信号重新温习了一遍概率论的知识，但是却总是感觉流于表面，在学习的过程中，总是有一层纱，一直笼罩在我的面前，戳不破，点不透。模模糊糊，就这样在最后的考试中，以一个96作结。 对于一七年上半年，已经没了任何印象。而下半年，主要是开始摸到了考研的边缘，生活节奏顿时快了许多，也更加单调了许多。放弃了很多的事情（其实实际上而言，不算放弃，只是更加的不再主动），将所有的精力放在了学习上，从最开始的独飞，到考试前的集体自习，不断感受着“强者们”的强，学习的事，靠的是自己，但是考试的事，却在此时，无比显然的凸显着集体的力量。 更多的考试习题，被“强者们”从各种渠道搞来，只有你身为其中的一分子（是“一分子”，而非“一份子”）的时候，你才能感受到独自作战时捉襟见肘的无奈。 唉，这个社会…… 三 一七年看了好多电影和电视剧。 国内的： 段奕宏的《引爆者》 有很多背景与与我的家乡相似 那绚丽的烟花，是愤怒与无奈 潘粤明的《白夜追凶》 近年来，国产剧的最大惊喜 大鹏的《缝纫机乐队》 让我改变了对于《屌丝男士》的大鹏的低俗印象，里面的音乐确实好听。 不思凡的《大护法》 犀利 周冬雨的《喜欢你》和《七月与安生》 自此喜欢上了这个肤白貌美，笑起来眼睛都不见了的姑娘。 她的笑容，看着就开心。 …… 亚洲的： 今敏的《东京教父》 似乎是今敏唯一一部比较温情的电影。 “京アニ”（京阿尼，京都动画）的《声之形》 好虐呀，虽说有点矫情。 配乐很好听。 新海诚的《你的名字》与《言叶之庭》 真，漂亮，的画面。 配乐，画面双绝。 宫崎骏的《起风了》 好看，没话说。 理想，爱情。 阿米尔·汗的《摔跤吧，爸爸》 对社会现实的批判，对于女性的鼓励与尊重。 押井守的《攻壳机动队》(1,2) 吊吊吊，没话说，逼格，就是逼格。 …… 欧美的： 雷德利·斯科特的《银翼杀手》 黑暗，压抑，细节丰富，画面色彩独特，内涵深刻 维伦纽瓦的《银翼杀手2049》 压抑，色彩更炫丽，依旧不失深度，对于自我身份的认知的不断反转，最后感觉好可怜 诺兰的《蝙蝠侠：黑暗骑士三部曲》和《敦刻尔克》 非线性叙事玩出了花。 前者黑暗骑士，另类的英雄，独具特色的反派与配角。牛逼的小丑。 后者以另类的方式讲述战争。 埃德加·赖特的《极盗车神》 没有了音乐，这部片子就没意思了。 有了音乐，这部片子就神了。 盖尔·加朵的《神奇女侠》 盖尔·加朵好美呀！ 张艺谋的《长城》 好一部怪兽围城。 周杰伦、摩根·弗里曼的《惊天魔盗团2》 杰杰六六六。 克里斯·埃文斯（美队）的《天才少女》 温情，感人。 小姑娘让我想起了《怒火救援》里的达科塔·范宁。 斯嘉丽·约翰逊的《唐璜》 嘿嘿嘿…… 埃米纳姆的《八英里》 姆爷的曾经过往。 女主挺漂亮。 说唱很犀利。 …… 看了不少，主要以电影为主，幸好有PT资源站，感谢IPV6，让我们身处校园内，可以免费获取那么丰富的资源。 感谢这些片子，给了我美好的回忆。 四 一七年，比较值得纪念的一次旅行——去了一趟长沙。 飞机飞济南，火车直奔长沙。 这是两个“第一次”——第一次坐飞机，第一次坐火车。 以前对于飞机的感觉就是高大上，机票贼啦贵，一般不愿意坐飞机，更多是选择火车。但是这次受地理条件以及时间所限，坐飞机是一个比较合适的方式，否则就要绕好大一圈的渤海湾。 大连真是祖国的“犄角旮旯”呀！ 头一次感受到了卧铺的方便与舒服（相较于硬座而言），四个人，一起嗨。他们仨玩扑克，我玩了几把就不想玩了。不太喜欢这一类游戏，总感觉没意思。不过，辛好我带了本书，《灿烂千阳》，去时看了一路。 这一路上，我们看过了白云拥挤的沉在我们的下方，看过了云雾缭绕的泰山在我们的窗外耸立，看过了从南到北的各色人潮，或多或少的认识到了，所谓的地大物博。 南方真热，尤其是在北方已经开始热起来的时候。到了长沙，最先做的就是洗澡。带了两天，洗了两次澡，其他时间就在吹空调。 第二天晚上，一切结束了，就出去和小伙伴们吃了一顿红烧肉，米饭免费供应。感觉很棒，肥而不腻，又香又辣，吃的我们爽个不停。 次日，就准备回学校了。在上火车之前，我们上了橘子洲头，见到了毛爷爷的巨大塑像。那时大家已经是湿透了，全是汗。在走向洲头的时候，感觉衣服将皮肤摩擦的疼痛无比。大家是叫苦不迭。太热了。但是为什么还是那么多的人？ 橘子洲头毛爷爷塑像 绕了个大圈。绕道开封。刚听说要到开封，就在想，开封会是什么样的一个城市。但是经过数个小时颠簸又熬夜的硬座，到了之后，有一种“幻想破灭”的感觉。 感觉回到了自己老家那个小县城。乘兴而来，失望而归。无奈。 十几个小时的卧铺之后，终于回到了学校。终于可以回家了。 这几十个小时的颠簸旅程，倒是成了我日后被学习压得喘不过气来的时候，可以偶尔回头细品的一段记忆。 五 一七年，过去了，就像他来的那样，匆匆，去也一般。 一八年，来了。]]></content>
      <categories>
        <category>生活与思考</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[R基本数据结构]]></title>
    <url>%2Flangs%2Fr%2FR%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[主站：https://lartpang.github.io/ 之前一阵子，在EDX上学习了R语言的一门基础课程，这里做个总结。这门课程主要侧重于R的数据结构的介绍，当然也介绍了它的基本的绘图手段。 工作空间相关 ls() ## character(0) rm(a) ## Warning in rm(a): 找不到对象&#39;a&#39; ls() ## character(0) 基本数据类型 logical TRUE/FALSE/NA/T/F(推荐使用完整形式)/某些时候的0与非0 numeric integer is numeric numeric not always integer character Other atomic types: double: higher precision complex: complex numbers raw: store raw bytes is.*()返回括号内内容是否是*对应类型。 # logical TRUE ## [1] TRUE class(TRUE) ## [1] &quot;logical&quot; FALSE ## [1] FALSE class(NA) ## [1] &quot;logical&quot; T ## [1] TRUE F ## [1] FALSE # numeric 2 ## [1] 2 class(2) ## [1] &quot;numeric&quot; 2.5 ## [1] 2.5 class(2.5) ## [1] &quot;numeric&quot; 2L ## [1] 2 class(2L) ## [1] &quot;integer&quot; is.numeric(2) ## [1] TRUE is.numeric(2L) ## [1] TRUE #integer is numeric #numeric not always integer is.integer(2) ## [1] FALSE is.integer(2L) ## [1] TRUE # character &quot;I love data science!&quot; ## [1] &quot;I love data science!&quot; class(&quot;I love data science!&quot;) ## [1] &quot;character&quot; 强制转换 as.*()返回括号内内容转化为*对应类型后的结果，有些情况无法转换。 as.numeric(TRUE) ## [1] 1 as.numeric(FALSE) ## [1] 0 as.character(4) ## [1] &quot;4&quot; as.numeric(&quot;4.5&quot;) ## [1] 4.5 as.integer(&quot;4.5&quot;) ## [1] 4 as.numeric(&quot;Hello&quot;) ## Warning: 强制改变过程中产生了NA ## [1] NA 向量 Vector Sequence of data elements Same basic type Automatic coercion if necessary character, numeric, logical Single value = Vector 创建 c()或者利用: # c() drawn_suits &lt;- c(&quot;hearts&quot;, &quot;spades&quot;, &quot;diamonds&quot;, &quot;diamonds&quot;, &quot;spades&quot;) drawn_suits ## [1] &quot;hearts&quot; &quot;spades&quot; &quot;diamonds&quot; &quot;diamonds&quot; &quot;spades&quot; is.vector(drawn_suits) ## [1] TRUE # : 1:5 ## [1] 1 2 3 4 5 is.vector(1:5) ## [1] TRUE 命名 names() remain &lt;- c(11, 12, 11, 13) suits &lt;- c(&quot;spades&quot;, &quot;hearts&quot;, &quot;diamonds&quot;, &quot;clubs&quot;) names(remain) &lt;- suits remain ## spades hearts diamonds clubs ## 11 12 11 13 #or remain &lt;- c(spades = 11, hearts = 12, diamonds = 11, clubs = 13) remain ## spades hearts diamonds clubs ## 11 12 11 13 #or remain &lt;- c(&quot;spades&quot; = 11, &quot;hearts&quot; = 12, &quot;diamonds&quot; = 11, &quot;clubs&quot; = 13) remain ## spades hearts diamonds clubs ## 11 12 11 13 单值仍为向量 my_apples &lt;- 5 my_oranges &lt;- &quot;six&quot; is.vector(my_apples) ## [1] TRUE is.vector(my_oranges) ## [1] TRUE length(my_apples) ## [1] 1 length(my_oranges) ## [1] 1 强制变换 drawn_ranks &lt;- c(7, 4, &quot;A&quot;, 10, &quot;K&quot;, 3, 2, &quot;Q&quot;) drawn_ranks ## [1] &quot;7&quot; &quot;4&quot; &quot;A&quot; &quot;10&quot; &quot;K&quot; &quot;3&quot; &quot;2&quot; &quot;Q&quot; class(drawn_ranks) ## [1] &quot;character&quot; 基本运算 很自然的可以由单数的运算推广出来。 # with number: +-*/ earnings &lt;- c(50, 100, 30) earnings * 3 ## [1] 150 300 90 earnings^2 ## [1] 2500 10000 900 # with vector: +-*/ earnings &lt;- c(50, 100, 30) expenses &lt;- c(30, 40, 80) bank &lt;- earnings - expenses ## sum() &gt; sum(bank) ## [1] 30 earnings &gt; expenses ## [1] TRUE TRUE FALSE ## multiplication and division are done element-wise! earnings * c(1, 2, 3) ## [1] 50 200 90 子集 三种索引方式 序号（R从1开始） 名字 —— names()的利用 逻辑值 remain &lt;- c(spades = 11, hearts = 12, diamonds = 11, clubs = 13) remain[1] ## spades ## 11 remain[&quot;spades&quot;] ## spades ## 11 remain[c(4, 1)] # 此法可以用来交换或者抽取特定位置的元素 ## clubs spades ## 13 11 remain[c(&quot;clubs&quot;, &quot;spades&quot;)] ## clubs spades ## 13 11 # 逻辑值索引，短的会被自动循环使用 remain[c(TRUE, FALSE)] ## spades diamonds ## 11 11 remain[c(TRUE, FALSE, TRUE, FALSE)] ## spades diamonds ## 11 11 # 负索引，“all but it”，返回除此之外的元素 remain[-1] ## hearts diamonds clubs ## 12 11 13 remain[-c(1, 2)] ## diamonds clubs ## 11 13 #remain[-&quot;spades&quot;] #can&#39;t work 矩阵 Matrix Vector: 1D array of data elements Matrix: 2D array of data elements Rows and columns One atomic vector type 创建 matrix() 默认按列填充 # 直接创建 matrix(1:6, nrow = 2) ## [,1] [,2] [,3] ## [1,] 1 3 5 ## [2,] 2 4 6 matrix(1:6, ncol = 3) ## [,1] [,2] [,3] ## [1,] 1 3 5 ## [2,] 2 4 6 matrix(1:6, nrow = 2, byrow = TRUE) ## [,1] [,2] [,3] ## [1,] 1 2 3 ## [2,] 4 5 6 # 循环创建 matrix(1:3, nrow = 2, ncol = 3) ## [,1] [,2] [,3] ## [1,] 1 3 2 ## [2,] 2 1 3 matrix(1:4, nrow = 2, ncol = 3) ## Warning in matrix(1:4, nrow = 2, ncol = 3): 数据长度[4]不是矩阵列数[3]的整 ## 倍数 ## [,1] [,2] [,3] ## [1,] 1 3 1 ## [2,] 2 4 2 # 组合创建 cbind(1:3, 1:3) ## [,1] [,2] ## [1,] 1 1 ## [2,] 2 2 ## [3,] 3 3 rbind(1:3, 1:3) ## [,1] [,2] [,3] ## [1,] 1 2 3 ## [2,] 1 2 3 m &lt;- matrix(1:6, byrow = TRUE, nrow = 2) rbind(m, 7:9) ## [,1] [,2] [,3] ## [1,] 1 2 3 ## [2,] 4 5 6 ## [3,] 7 8 9 cbind(m, c(10, 11)) ## [,1] [,2] [,3] [,4] ## [1,] 1 2 3 10 ## [2,] 4 5 6 11 命名 rownames(), colnames() m &lt;- matrix(1:6, byrow = TRUE, nrow = 2) rownames(m) &lt;- c(&quot;row1&quot;, &quot;row2&quot;) m ## [,1] [,2] [,3] ## row1 1 2 3 ## row2 4 5 6 colnames(m) &lt;- c(&quot;col1&quot;, &quot;col2&quot;, &quot;col3&quot;) m ## col1 col2 col3 ## row1 1 2 3 ## row2 4 5 6 # 直接命名 m &lt;- matrix(1:6, byrow = TRUE, nrow = 2, dimnames = list(c(&quot;row1&quot;, &quot;row2&quot;), c(&quot;col1&quot;, &quot;col2&quot;, &quot;col3&quot;))) m ## col1 col2 col3 ## row1 1 2 3 ## row2 4 5 6 强制转换 num &lt;- matrix(1:8, ncol = 2) num ## [,1] [,2] ## [1,] 1 5 ## [2,] 2 6 ## [3,] 3 7 ## [4,] 4 8 char &lt;- matrix(LETTERS[1:6], nrow = 4, ncol = 3) char ## [,1] [,2] [,3] ## [1,] &quot;A&quot; &quot;E&quot; &quot;C&quot; ## [2,] &quot;B&quot; &quot;F&quot; &quot;D&quot; ## [3,] &quot;C&quot; &quot;A&quot; &quot;E&quot; ## [4,] &quot;D&quot; &quot;B&quot; &quot;F&quot; num &lt;- matrix(1:8, ncol = 2) char &lt;- matrix(LETTERS[1:6], nrow = 4, ncol = 3) cbind(num, char) ## [,1] [,2] [,3] [,4] [,5] ## [1,] &quot;1&quot; &quot;5&quot; &quot;A&quot; &quot;E&quot; &quot;C&quot; ## [2,] &quot;2&quot; &quot;6&quot; &quot;B&quot; &quot;F&quot; &quot;D&quot; ## [3,] &quot;3&quot; &quot;7&quot; &quot;C&quot; &quot;A&quot; &quot;E&quot; ## [4,] &quot;4&quot; &quot;8&quot; &quot;D&quot; &quot;B&quot; &quot;F&quot; 子集运算 m &lt;- matrix(sample(1:15, 12), nrow = 3) rownames(m) &lt;- c(&quot;r1&quot;, &quot;r2&quot;, &quot;r3&quot;) colnames(m) &lt;- c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;) m ## a b c d ## r1 7 5 6 10 ## r2 3 9 12 8 ## r3 15 13 2 4 m[1,3] ## [1] 6 m[3,] ## a b c d ## 15 13 2 4 m[,3] ## r1 r2 r3 ## 6 12 2 m[4] # 默认按列计数 ## [1] 5 m[2, c(2, 3)] ## b c ## 9 12 m[c(1, 2), c(2, 3)] ## b c ## r1 5 6 ## r2 9 12 m[c(1, 3), c(1, 3, 4)] ## a c d ## r1 7 6 10 ## r3 15 2 4 m[&quot;r2&quot;,&quot;c&quot;] ## [1] 12 m[2,&quot;c&quot;] ## [1] 12 m[3, c(&quot;c&quot;, &quot;d&quot;)] ## c d ## 2 4 m[c(FALSE, FALSE, TRUE), c(FALSE, TRUE, FALSE, TRUE)] ## b d ## 13 4 m[c(FALSE, FALSE, TRUE), c(FALSE, TRUE)] ## b d ## 13 4 矩阵运算 colSums(), rowSums() Standard arithmetic possible Element-wise computation the_fellowship &lt;- c(316, 556) two_towers &lt;- c(343, 584) return_king &lt;- c(378, 742) lotr_matrix &lt;- rbind(the_fellowship, two_towers, return_king) colnames(lotr_matrix) &lt;- c(&quot;US&quot;, &quot;non-US&quot;) rownames(lotr_matrix) &lt;- c(&quot;Fellowship&quot;, &quot;Two Towers&quot;, &quot;Return King&quot;) lotr_matrix ## US non-US ## Fellowship 316 556 ## Two Towers 343 584 ## Return King 378 742 # 与数字 +-*/ lotr_matrix / 1.12 ## US non-US ## Fellowship 282.1429 496.4286 ## Two Towers 306.2500 521.4286 ## Return King 337.5000 662.5000 lotr_matrix - 50 ## US non-US ## Fellowship 266 506 ## Two Towers 293 534 ## Return King 328 692 # 与矩阵 +-*/ (这里不是线性代数中的矩阵计算) theater_cut &lt;- matrix(c(50, 80, 100), nrow = 3, ncol = 2) theater_cut ## [,1] [,2] ## [1,] 50 50 ## [2,] 80 80 ## [3,] 100 100 lotr_matrix - theater_cut ## US non-US ## Fellowship 266 506 ## Two Towers 263 504 ## Return King 278 642 # 与向量 lotr_matrix - c(50, 80, 100) #按列循环计算 ## US non-US ## Fellowship 266 506 ## Two Towers 263 504 ## Return King 278 642 因子 Factors Factors for categorical variables Limited number of different values Belong to category 创建因子 factor() blood &lt;- c(&quot;B&quot;, &quot;AB&quot;, &quot;O&quot;, &quot;A&quot;, &quot;O&quot;, &quot;O&quot;, &quot;A&quot;, &quot;B&quot;) blood ## [1] &quot;B&quot; &quot;AB&quot; &quot;O&quot; &quot;A&quot; &quot;O&quot; &quot;O&quot; &quot;A&quot; &quot;B&quot; blood_factor &lt;- factor(blood) # 默认等级按照字母顺序定 blood_factor ## [1] B AB O A O O A B ## Levels: A AB B O str(blood_factor) ## Factor w/ 4 levels &quot;A&quot;,&quot;AB&quot;,&quot;B&quot;,&quot;O&quot;: 3 2 4 1 4 4 1 3 # 自定义level blood_factor2 &lt;- factor(blood, levels = c(&quot;O&quot;, &quot;A&quot;, &quot;B&quot;, &quot;AB&quot;)) blood_factor2 ## [1] B AB O A O O A B ## Levels: O A B AB str(blood_factor2) ## Factor w/ 4 levels &quot;O&quot;,&quot;A&quot;,&quot;B&quot;,&quot;AB&quot;: 3 4 1 2 1 1 2 3 Rename factor levels blood &lt;- c(&quot;B&quot;, &quot;AB&quot;, &quot;O&quot;, &quot;A&quot;, &quot;O&quot;, &quot;O&quot;, &quot;A&quot;, &quot;B&quot;) #1.1 blood_factor &lt;- factor(blood) levels(blood_factor) &lt;- c(&quot;BT_A&quot;, &quot;BT_AB&quot;, &quot;BT_B&quot;, &quot;BT_O&quot;) #1.2 blood &lt;- c(&quot;B&quot;, &quot;AB&quot;, &quot;O&quot;, &quot;A&quot;, &quot;O&quot;, &quot;O&quot;, &quot;A&quot;, &quot;B&quot;) blood_factor &lt;- factor(blood) factor(blood, levels = c(&quot;O&quot;, &quot;A&quot;, &quot;B&quot;, &quot;AB&quot;), labels = c(&quot;BT_O&quot;, &quot;BT_A&quot;, &quot;BT_B&quot;, &quot;BT_AB&quot;)) ## [1] BT_B BT_AB BT_O BT_A BT_O BT_O BT_A BT_B ## Levels: BT_O BT_A BT_B BT_AB #2 factor(blood, labels = c(&quot;BT_A&quot;, &quot;BT_AB&quot;, &quot;BT_B&quot;, &quot;BT_O&quot;)) ## [1] BT_B BT_AB BT_O BT_A BT_O BT_O BT_A BT_B ## Levels: BT_A BT_AB BT_B BT_O Ordered factor blood &lt;- c(&quot;B&quot;, &quot;AB&quot;, &quot;O&quot;, &quot;A&quot;, &quot;O&quot;, &quot;O&quot;, &quot;A&quot;, &quot;B&quot;) blood_factor &lt;- factor(blood) blood_factor[1] &lt; blood_factor[2] ## Warning in Ops.factor(blood_factor[1], blood_factor[2]): &#39;&lt;&#39; not meaningful ## for factors ## [1] NA # 下面比较大小才是有意义的 tshirt &lt;- c(&quot;M&quot;, &quot;L&quot;, &quot;S&quot;, &quot;S&quot;, &quot;L&quot;, &quot;M&quot;, &quot;L&quot;, &quot;M&quot;) tshirt_factor &lt;- factor(tshirt, ordered = TRUE, levels = c(&quot;S&quot;, &quot;M&quot;, &quot;L&quot;)) tshirt_factor ## [1] M L S S L M L M ## Levels: S &lt; M &lt; L tshirt_factor[1] &lt; tshirt_factor[2] ## [1] TRUE 列表 List Vector - Matrix - List Vector: 1D, same type Matrix: 2D, same type List: Different R objects No coercion Loss of some functionality 创建列表 list() list(&quot;Rsome times&quot;, 190, 5) ## [[1]] ## [1] &quot;Rsome times&quot; ## ## [[2]] ## [1] 190 ## ## [[3]] ## [1] 5 song &lt;- list(&quot;Rsome times&quot;, 190, 5) is.list(song) ## [1] TRUE 命名列表 #1 song &lt;- list(&quot;Rsome times&quot;, 190, 5) names(song) &lt;- c(&quot;title&quot;, &quot;duration&quot;, &quot;track&quot;) song ## $title ## [1] &quot;Rsome times&quot; ## ## $duration ## [1] 190 ## ## $track ## [1] 5 #2 song &lt;- list(title = &quot;Rsome times&quot;, duration = 190, track = 5) song ## $title ## [1] &quot;Rsome times&quot; ## ## $duration ## [1] 190 ## ## $track ## [1] 5 str(song) ## List of 3 ## $ title : chr &quot;Rsome times&quot; ## $ duration: num 190 ## $ track : num 5 列表嵌套 similar_song &lt;- list(title = &quot;R you on time?&quot;, duration = 230) song &lt;- list(title = &quot;Rsome times&quot;, duration = 190, track = 5, similar = similar_song) str(song) ## List of 4 ## $ title : chr &quot;Rsome times&quot; ## $ duration: num 190 ## $ track : num 5 ## $ similar :List of 2 ## ..$ title : chr &quot;R you on time?&quot; ## ..$ duration: num 230 子集运算 [ versus [[ similar_song &lt;- list(title = &quot;R you on time?&quot;, duration = 230) song &lt;- list(title = &quot;Rsome times&quot;, duration = 190, track = 5, similar = similar_song) str(song) ## List of 4 ## $ title : chr &quot;Rsome times&quot; ## $ duration: num 190 ## $ track : num 5 ## $ similar :List of 2 ## ..$ title : chr &quot;R you on time?&quot; ## ..$ duration: num 230 song[1] ## $title ## [1] &quot;Rsome times&quot; song[[1]] ## [1] &quot;Rsome times&quot; song[c(1, 3)] ## $title ## [1] &quot;Rsome times&quot; ## ## $track ## [1] 5 #song[[c(1, 3)]] #can&#39;t work #song[[1]][[3]] #can&#39;t work song[[&quot;duration&quot;]] ## [1] 190 song[&quot;duration&quot;] ## $duration ## [1] 190 song[c(FALSE, TRUE, TRUE, FALSE)] ## $duration ## [1] 190 ## ## $track ## [1] 5 #song[[c(FALSE, TRUE, TRUE, FALSE)]] # can&#39;t work #song[[F]][[T]][[T]][[F]] #also # list in list song[[4]][[1]] ## [1] &quot;R you on time?&quot; song[[c(4, 1)]] ## [1] &quot;R you on time?&quot; song[c(&quot;duration&quot;, &quot;similar&quot;)] ## $duration ## [1] 190 ## ## $similar ## $similar$title ## [1] &quot;R you on time?&quot; ## ## $similar$duration ## [1] 230 [[ or [ ? + [[ to select list element + [ results in sublist + [[ and $ to subset and extend lists 列表扩展 这里引出了R中比较重要的一个符号$ similar_song &lt;- list(title = &quot;R you on time?&quot;, duration = 230) song &lt;- list(title = &quot;Rsome times&quot;, duration = 190, track = 5, similar = similar_song) #$ song$duration ## [1] 190 #extending friends &lt;- c(&quot;Kurt&quot;, &quot;Florence&quot;, &quot;Patti&quot;, &quot;Dave&quot;) song$sent &lt;- friends #或者 song[[&quot;sent&quot;]] &lt;- friends song$similar$reason &lt;- &quot;too long&quot; song ## $title ## [1] &quot;Rsome times&quot; ## ## $duration ## [1] 190 ## ## $track ## [1] 5 ## ## $similar ## $similar$title ## [1] &quot;R you on time?&quot; ## ## $similar$duration ## [1] 230 ## ## $similar$reason ## [1] &quot;too long&quot; ## ## ## $sent ## [1] &quot;Kurt&quot; &quot;Florence&quot; &quot;Patti&quot; &quot;Dave&quot; 数据框 Data Frame Observations 观测值 Variables 变量 Example: people each person = observation properties (name, age …) = variables Rows = observations (persons) Columns = variables (age, name, …) 不同的变量的观测值可以类型不同，但是变量自己的所有观测值类型一致。 多在导入数据时使用。 创建数据框 name &lt;- c(&quot;Anne&quot;, &quot;Pete&quot;, &quot;Frank&quot;, &quot;Julia&quot;, &quot;Cath&quot;) age &lt;- c(28, 30, 21, 39, 35) child &lt;- c(FALSE, TRUE, TRUE, FALSE, TRUE) df &lt;- data.frame(name, age, child) str(df) ## &#39;data.frame&#39;: 5 obs. of 3 variables: ## $ name : Factor w/ 5 levels &quot;Anne&quot;,&quot;Cath&quot;,..: 1 5 3 4 2 ## $ age : num 28 30 21 39 35 ## $ child: logi FALSE TRUE TRUE FALSE TRUE 命名数据框 name &lt;- c(&quot;Anne&quot;, &quot;Pete&quot;, &quot;Frank&quot;, &quot;Julia&quot;, &quot;Cath&quot;) age &lt;- c(28, 30, 21, 39, 35) child &lt;- c(FALSE, TRUE, TRUE, FALSE, TRUE) df &lt;- data.frame(name, age, child) names(df) &lt;- c(&quot;Name&quot;, &quot;Age&quot;, &quot;Child&quot;) str(df) ## &#39;data.frame&#39;: 5 obs. of 3 variables: ## $ Name : Factor w/ 5 levels &quot;Anne&quot;,&quot;Cath&quot;,..: 1 5 3 4 2 ## $ Age : num 28 30 21 39 35 ## $ Child: logi FALSE TRUE TRUE FALSE TRUE df &lt;- data.frame(Name = name, Age = age, Child = child) #also str(df) ## &#39;data.frame&#39;: 5 obs. of 3 variables: ## $ Name : Factor w/ 5 levels &quot;Anne&quot;,&quot;Cath&quot;,..: 1 5 3 4 2 ## $ Age : num 28 30 21 39 35 ## $ Child: logi FALSE TRUE TRUE FALSE TRUE 可见，这里的字符串向量，被自动转化为因子类型，所以可以设置参数来避免此隐含行为。 name &lt;- c(&quot;Anne&quot;, &quot;Pete&quot;, &quot;Frank&quot;, &quot;Julia&quot;, &quot;Cath&quot;) age &lt;- c(28, 30, 21, 39, 35) child &lt;- c(FALSE, TRUE, TRUE, FALSE, TRUE) df &lt;- data.frame(name, age, child, stringsAsFactors = FALSE) str(df) ## &#39;data.frame&#39;: 5 obs. of 3 variables: ## $ name : chr &quot;Anne&quot; &quot;Pete&quot; &quot;Frank&quot; &quot;Julia&quot; ... ## $ age : num 28 30 21 39 35 ## $ child: logi FALSE TRUE TRUE FALSE TRUE 子集运算 Subset Data Frame * Subsetting syntax from matrices and lists * [ from matrices * [[ and $ from lists name &lt;- c(&quot;Anne&quot;, &quot;Pete&quot;, &quot;Frank&quot;, &quot;Julia&quot;, &quot;Cath&quot;) age &lt;- c(28, 30, 21, 39, 35) child &lt;- c(FALSE, TRUE, TRUE, FALSE, TRUE) people &lt;- data.frame(name, age, child, stringsAsFactors = FALSE) # 类似矩阵的操作 people[3,2] ## [1] 21 people[3,&quot;age&quot;] ## [1] 21 people[,&quot;age&quot;] ## [1] 28 30 21 39 35 people[3,] # 由于返回的是一个数据框，我的R notebook不显示数据框 ## name age child ## 3 Frank 21 TRUE people[c(3, 5), c(&quot;age&quot;, &quot;child&quot;)] # 同上 ## age child ## 3 21 TRUE ## 5 35 TRUE # 类似列表的操作 people$age ## [1] 28 30 21 39 35 people[[&quot;age&quot;]] ## [1] 28 30 21 39 35 people[[2]] ## [1] 28 30 21 39 35 ## 由于返回的是一个数据框，我的R notebook不显示数据框 people[&quot;age&quot;] ## age ## 1 28 ## 2 30 ## 3 21 ## 4 39 ## 5 35 people[2] ## age ## 1 28 ## 2 30 ## 3 21 ## 4 39 ## 5 35 扩展数据框 Extend Data Frame * Add columns = add variables * Add rows = add observations name &lt;- c(&quot;Anne&quot;, &quot;Pete&quot;, &quot;Frank&quot;, &quot;Julia&quot;, &quot;Cath&quot;) age &lt;- c(28, 30, 21, 39, 35) child &lt;- c(FALSE, TRUE, TRUE, FALSE, TRUE) people &lt;- data.frame(name, age, child, stringsAsFactors = FALSE) #Add column height &lt;- c(163, 177, 163, 162, 157) people$height &lt;- height str(people) ## &#39;data.frame&#39;: 5 obs. of 4 variables: ## $ name : chr &quot;Anne&quot; &quot;Pete&quot; &quot;Frank&quot; &quot;Julia&quot; ... ## $ age : num 28 30 21 39 35 ## $ child : logi FALSE TRUE TRUE FALSE TRUE ## $ height: num 163 177 163 162 157 ##also people[[&quot;height&quot;]] &lt;- height str(people) ## &#39;data.frame&#39;: 5 obs. of 4 variables: ## $ name : chr &quot;Anne&quot; &quot;Pete&quot; &quot;Frank&quot; &quot;Julia&quot; ... ## $ age : num 28 30 21 39 35 ## $ child : logi FALSE TRUE TRUE FALSE TRUE ## $ height: num 163 177 163 162 157 weight &lt;- c(74, 63, 68, 55, 56) cbind(people, weight) ## name age child height weight ## 1 Anne 28 FALSE 163 74 ## 2 Pete 30 TRUE 177 63 ## 3 Frank 21 TRUE 163 68 ## 4 Julia 39 FALSE 162 55 ## 5 Cath 35 TRUE 157 56 #Add row 这里要注意，有时候会出错 tom &lt;- data.frame(&quot;Tom&quot;, 37, FALSE, 183) #rbind(people, tom) #会报错： #Error : names do not match previous names tom &lt;- data.frame(name = &quot;Tom&quot;, age = 37, child = FALSE, height = 183) rbind(people, tom) ## name age child height ## 1 Anne 28 FALSE 163 ## 2 Pete 30 TRUE 177 ## 3 Frank 21 TRUE 163 ## 4 Julia 39 FALSE 162 ## 5 Cath 35 TRUE 157 ## 6 Tom 37 FALSE 183 排序 这里主要介绍了sort()与order()，其中，order()更适合用来为数据框调整顺序。 str(people) ## &#39;data.frame&#39;: 5 obs. of 4 variables: ## $ name : chr &quot;Anne&quot; &quot;Pete&quot; &quot;Frank&quot; &quot;Julia&quot; ... ## $ age : num 28 30 21 39 35 ## $ child : logi FALSE TRUE TRUE FALSE TRUE ## $ height: num 163 177 163 162 157 #sort()直接对于向量元素进行了排序 sort(people$age) ## [1] 21 28 30 35 39 #order()会返回对应大小等级所实际在的位置 ranks &lt;- order(people$age) ranks ## [1] 3 1 2 5 4 people$age ## [1] 28 30 21 39 35 people[ranks, ] #直接对行进行了排序 ## name age child height ## 3 Frank 21 TRUE 163 ## 1 Anne 28 FALSE 163 ## 2 Pete 30 TRUE 177 ## 5 Cath 35 TRUE 157 ## 4 Julia 39 FALSE 162 #或者如下可以实现降序排序 people[order(people$age, decreasing = TRUE), ] ## name age child height ## 4 Julia 39 FALSE 162 ## 5 Cath 35 TRUE 157 ## 2 Pete 30 TRUE 177 ## 1 Anne 28 FALSE 163 ## 3 Frank 21 TRUE 163 绘图 Graphics 这里主要介绍了graphics包的plot()与hist() plot()会根据不同的数据类型，而画出不同的图像 plot() (categorical) 条形图 例如：plot(countries$continent) plot() (numerical) 散点图 例如：plot(countries$population) plot() (2x numerical) 散点图 例如：plot(countries$area, countries$population)、 plot(log(countries$area), log(countries$population)) plot() (2x categorical) 某种条形图的变形 例如：plot(countries$continent, countries$religion) hist()可以绘制直方图 例如： hist(africa$population)、 hist(africa$population, breaks = 10) Other graphics functions * barplot() * boxplot() * pairs() 自定义绘图 这里就是修改参数了。无需多讲。 这里，引出了函数par()，这是一个绘图的公共参数列表，里面存放着常用的一些绘图的公共属性，可以实现绘制多幅图形时，基本属性的一次性确定。 例如： par(col = &quot;blue&quot;) plot(mercury$temperature, mercury$pressure) 常用的plot的属性有： plot(mercury$temperature, mercury$pressure, xlab = &quot;Temperature&quot;, ylab = &quot;Pressure&quot;, main = &quot;T vs P for Mercury&quot;, #标题 type = &quot;o&quot;, col = &quot;orange&quot;, col.main = &quot;darkgray&quot;, cex.axis = 0.6, #cex系列属性表示缩放程度 lty = 5, #Line Type pch = 4 #Plot Symbol ) 多图绘制 mfrow与mfcol参数可以在一个图形框里，用来放置多个图像，区别是，前者是将后面plot语句生成的图像按行填充，而后者是按列填充。 #按行填充 par(mfrow = c(2,2)) plot(shop$ads, shop$sales) plot(shop$comp, shop$sales) plot(shop$inv, shop$sales) plot(shop$size_dist, shop$sales) #按列填充 par(mfcol = c(2,2)) plot(shop$ads, shop$sales) plot(shop$comp, shop$sales) plot(shop$inv, shop$sales) plot(shop$size_dist, shop$sales) Reset the grid par(mfrow = c(1,1)) 相较于这个，layout()函数设置的更为灵活。 grid &lt;- matrix(c(1, 1, 2, 3), nrow = 2, ncol = 2, byrow = TRUE) layout(grid) plot(shop$ads, shop$sales) #放在grid的1号位置 plot(shop$comp, shop$sales) #放在grid的2号位置 plot(shop$inv, shop$sales) #放在grid的3号位置 Reset the grid layout(1) par(mfcol = c(1,1)) Reset all parameters old_par &lt;- par() par(col = &quot;red&quot;) plot(shop$ads, shop$sales) par(old_par) plot(shop$ads, shop$sales) 线性拟合 引出函数lm() —— linear model，**lm(a~b)就是对a=k*b+c进行线性拟合** plot(shop$ads, shop$sales, pch = 16, col = 2, xlab = &quot;advertisement&quot;, ylab = &quot;net sales&quot;) lm_sales &lt;- lm(shop$sales ~ shop$ads) abline(coef(lm_sales), lwd = 2) #取模型系数，线宽为2，画直线]]></content>
      <categories>
        <category>编程与生活</category>
      </categories>
      <tags>
        <tag>R</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[chuck8]]></title>
    <url>%2Flangs%2Fchuck%2Fchuck8%2F</url>
    <content type="text"><![CDATA[functions writing calling overloading #writing keyword fun (or function) followed by the return type and then the name of the function. After the name of the function parentheses(括号) must be opened to declare the types of the input arguments. 12345// define function call 'funk'fun void funk( int arg )&#123; // insert code here&#125; 123456// define function 'addOne'fun int addOne(int x)&#123; // result return x + 1;&#125; #calling 123456789// define 'hey'fun int hey( int a, int b )&#123; // do something return a + b;&#125;// call the function; store resulthey( 1, 2 ) =&gt; int result; You can also use the ChucK operator to call functions! 1234567891011// call hey( 1, 2 ) =&gt; hey =&gt; int result;// samehey( 1, 2 ) =&gt; int result;// several in a row( 10, 100 ) =&gt; Std.rand2 =&gt; Std.mtof =&gt; float foo;// same 返回值做参数Std.mtof( Std.rand2( 10, 100 ) ) =&gt; float foo; #overloading Overloading a function allows functions with the same name to be defined(定义) with different arguments. The function must be written in separate instances(实例) to handle the input, and the return type must agree(一致). 123456789101112131415// funk( int )fun int add(int x)&#123; return x + x;&#125;// funk( int, int )fun int add(int x, int y)&#123; return x + y;&#125;// compiler automatically choose the right one to calladd( 1 ) =&gt; int foo;add( 1, 2 ) =&gt; int bar;]]></content>
      <categories>
        <category>编程与生活</category>
      </categories>
      <tags>
        <tag>ChucK</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[chuck7]]></title>
    <url>%2Flangs%2Fchuck%2Fchuck7%2F</url>
    <content type="text"><![CDATA[manipulating time time and duration operations (arithmetic) the keyword 'now' advancing time properties #Manipulating Time ChucK is a strongly-timed language, meaning that time is fundamentally(根本地) embedded(嵌入) in the language. ChucK allows the programmer to explicitly(明确的) reason about time from the code. This gives extremely flexible(灵活的) and precise(精确的) control over time and (therefore) sound synthesis(综合). In ChucK: time and duration are native types in the language keyword now holds the current logical time time is advanced (and can only be advanced) by explicitly(显式地) manipulating(操纵) now you have flexible(灵活的) and precise(精确的) control #time and duration Time and duration are native types in ChucK. `time` represents an absolute(绝对的) point in time (from the beginning of ChucK time). 时间点 `dur` represents a duration (with the same logical units as time). 时间段 12345// a duration of one second1::second =&gt; dur foo;// a point in time (duration of foo from now)now + foo =&gt; time later; Later in this section, we outline(概述) the various arithmetic operations(各种数学运算) to perform on time and duration. Durations can be used to construct new durations, which then be used to inductively(归纳地) construct yet other durations. For example: 12345// .5 second is a quarter.5::second =&gt; dur quarter;// 4 quarters is whole4::quarter =&gt; dur whole; By default, ChucK provides these preset(预先装置的) duration values: samp : duration(持续) of 1 sample(样本 in ChucK time ms : duration of 1 millisecond(毫秒) second : duration of 1 second minute : 1 minute hour : 1 hour day : 1 day week : 1 week Use these to represent any duration. 1234567891011// the duration of half a sample.5::samp =&gt; dur foo;// 20 weeks20::week =&gt; dur waithere;// use in combination2::minute + 30::second =&gt; dur bar;// same value as above2.5::minute =&gt; dur bar; #operations on time and duration (arithmetic) In ChucK, there are well-defined(定义明确的) arithmetic operations on values of type time and dur. #the keyword 'now' The keyword now is the key to reasoning about and controlling time in ChucK.思考控制时间的关键 Some properties(属性) of now include: now is a special variable(变量) of type time. now holds the current ChucK time (when read). modifying now has the side effects(副作用) of: advancing time (see below); suspending(暂停) the current process (called shred) until the desired time is reached - allowing other shreds and audio synthesis to compute; the value of now only changes when it is explicitly(明确地) modified(改动). (also see next section on advancing time). Example: 123456789101112// compute value that represents "5 seconds from now"now + 5::second =&gt; time later;// while we are not at later yet...while( now &lt; later )&#123; // print out value of now &lt;&lt;&lt; now &gt;&gt;&gt;; // advance time by 1 second 1::second =&gt; now;&#125; #advancing time(推进时间) Advancing time allows other shreds (processes进程) to run and allows audio to be computed in a controlled manner. There are three ways of advancing time in ChucK: chucking (=&gt;) a duration to now: this will advance time by that duration. chucking (=&gt;) a time to now: this will advance time to that point. (note that the desired time must be later than the current time, or at least be equal to it.) chucking (=&gt;) an Event to now: time will advance until the event is triggered(引发). (also see event) advancing time by duration 1234567891011// advance time by 1 second1::second =&gt; now;// advance time by 100 millisecond100::ms =&gt; now;// advance time by 1 samp (every sample)1::samp =&gt; now;// advance time by less than 1 samp.024::samp =&gt; now; advancing time by absolute(绝对的) time 12345// figure out whennow + 4::hour =&gt; time later;// advance time to laterlater =&gt; now; A time chucked to now will have ChucK wait until the appointed(约定的) time. ChucK never misses an appointment (unless it crashes)! Again, the time chucked to now must be greater than or equal to now, otherwise an exception(异常) is thrown. #advancing time by event 12// wait on evente =&gt; now; The advancement(推进) of time can occur(发生) at any point in the code. 123456789101112// our patch: sine oscillator -&gt; dacSinOsc s =&gt; dac;// infinite time loopwhile( true )&#123; // randomly choose frequency from 30 to 1000 Std.rand2f( 30, 1000 ) =&gt; s.freq; // advance time by 100 millisecond 100::ms =&gt; now;&#125; Furthermore(此外), there are no restrictions(限制) (other than underlying floating point precision除了基本的浮点精度) on how much time is advanced. So it is possible to advance time by a microsecond(微秒), a samp, 2 hours, or 10 years. The system will behave accordingly(相应地) and deterministically(确切地). This mechanism(机制) allows time to be controlled at any desired rate, according to any programmable(可编程的) pattern. With respect to(关于) sound synthesis(合成), it is possible to control any unit generator at literally(字面地) any rate, even sub-sample rate. The power of the timing mechanism is extended(延伸) by the ability to write parallel(并行) code, which is discussed in concurrency(并发性) and shreds. #properties (see above)]]></content>
      <categories>
        <category>编程与生活</category>
      </categories>
      <tags>
        <tag>ChucK</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[chuck9]]></title>
    <url>%2Flangs%2Fchuck%2Fchuck9%2F</url>
    <content type="text"><![CDATA[concurrency, processes, shreds sporking shreds the &#39;me&#39; keyword using machine.add() inter-shred communication #Concurrency &amp; Shreds ...is able to run many processes concurrently... A ChucKian process is called a shred. To spork a shred means creating and adding a new process to the virtual(虚拟的) machine. Shreds may be sporked from a variety of places(各种各样的地方), and may themselves spork new shreds. (直接代换理解：spork a shred == creating &amp; adding a process) ChucK supports sample-synchronous(采样同步), non-preemptive concurrency(非抢占式并发). Via the timing mechanism(机制). any number of programs/shreds can be automatically(自动的) shreduled(往后看，便于理解，实际上就是创建添加的过程，感觉就像是shred动作化了) and synchronized(同步的) use the timing information.A shreduler in the virtual(虚拟的) machine does the shreduling. The concurrency(并发性) is 'sample-synchronous', meaning that inter-process audio timing is guaranteed(保证) to be precise(精确的) to the sample(样品). Note that each process/shred does not necessarily need to know about each other - it only has to deal with time locally. The virtual machine will make sure things happen correctly &quot;across the board(全体，全面)&quot;. Finally, concurrency - like timing - is deterministic(确定性的) in ChucK. The simplest way to to run shreds concurrently is to specify(指定) them on the command line: chuck foo.ck bar.ck boo.ck The above command runs chuck on foo.ck, bar.ck, and boo.ck concurrently. There are other ways to run shreds concurrently (see on-the-fly programming commands). Next, we show how to create new shreds from within ChucK programs. #sporking shreds (in code) To spork means to shredule a new shred. To spork a shred, use the spork keyword/operator: spork dynamically(动态地) sporks shred from a function call从函数调用中动态创建进程 this operation is sample-synchronous, the new shred is shreduled to execute(执行) immediately新进程创建来立即执行 the parent shred continues to execute, until time is advanced (see manipulating time) or until the parent explicitly(显式地) yields(产生) (see next section).父进程继续执行，直到时间被推进或者直到父进程显示产生。 in the current implementation(实现), when a parent shred exits, all child shreds all exit (this behavior(行为) will be enhanced(提高) in the future.)在当前实现中，当父进程退出，所有的子进程会退出。 sporking a functions returns reference to the new shred, note that this operation does not return what functions returns - the ability to get back the return value at some later point in time will be provided in a future release.产生一个函数返回新进程的引用，注意这个操作不会返回函数返回值-返回在某个靠后的时间点上的返回值的能力就被在未来的版本中提供。 1234567891011// define function go()fun void go()&#123; // insert code&#125;// spork a new shred to start running from go()spork ~ go();// spork another, store reference to new shred in offspringspork ~ go() =&gt; Shred @ offspring; a slightly longer example: 1234567891011121314151617181920212223242526// define functionfun void foo( string s )&#123; // infinite time loop while( true ) &#123; // print s &lt;&lt;&lt; s &gt;&gt;&gt;; // advance time 5::second =&gt; now; &#125;&#125;// spork shred, passing in "you" as argument to foospork ~ foo( "you" );// advance time by 250 ms2::second =&gt; now;// spork another shredspork ~ foo( "me" );// infinite time loop - to keep child shreds aroundwhile( true ) 1::second =&gt; now;//测量：//输出you后，第2s输出me，第5s再次输出 两个进程互有交错，&quot;you&quot;先输出，&quot;me&quot;后输出，循环输出。 个人理解： `1::second =&gt; now;`感觉上就像是将进程挂起，sleep()的感觉 就像是1s后再跳到这个程序 12you-&gt;me:2sme-&gt;you:3s #the 'me' keyword The me keyword (type Shred) refers the current shred. Sometimes it is useful to suspend(暂停) the current shred without advancing time, and let other shreds shreduled for the current time to execute(实行). me.yield() does exactly that. This is often useful immediately after sporking a new shred, and you would like for that shred to have a chance to run but you do not want to advance time yet for yourself. 123456// spork shredspork ~ go();// suspend the current shred ...// ... give other shreds (shreduled for 'now') a chance to runme.yield(); It may also be useful to exit the current shred. For example if a MIDI device(装置) fails to open, you may exit the current shred. 1234567891011// make a MidiIn objectMidiIn min;// try to open device 0 (chuck --probe to list all device)if( !min.open( 0 ) )&#123; // print error message &lt;&lt;&lt; "can't open MIDI device" &gt;&gt;&gt;; // exit the current shred me.exit();&#125; You can get the shred id: 12// print out the shred id&lt;&lt;&lt; me.id(); &gt;&gt;&gt;; These functions are common to all shreds, but yield() and exit() are commonly used with the current shred. #using machine.add() Machine.add( string path ) takes the path to a chuck program, and sporks it. Unlike spork ~, there is no parent-child relationship between the shred that calls the function and the new shred that is added. This is useful for dynamically(动态地) running stored programs. 12// spork "foo.ck"Machine.add( "foo.ck" ); Presently, this returns the id of the new shred, not a reference to the shred. This will likely be changed in the future. Similarly, you can remove shreds from the virtual(虚拟的) machine. 1234567891011// addMachine.add( "foo.ck" ) =&gt; int id;// remove shred with idMachine.remove( id );// addMachine.add( "boo.ck" ) =&gt; id// replace shred with "bar.ck"Machine.replace( id, "bar.ck" ); #inter-shred communication Shreds sporked in the same file can share the same global variables(变量). They can use time and events to synchronize to each other. (see events) Shreds sporked from different files can share data (including events).For now, this is done through a public class with static data (see classes). Static data is not completely implemented! We will fix this very soon! #command line arguments ChucK supports passing arbitrary(任意的) data from the command line into ChucK programs using optional(可选择的) command line arguments. An argument is specified(指定) by appending(附加) a colon(冒号) character &quot;:&quot; to the name of the ChucK program to which you wish to send that argument, followed by the argument itself. chuck foo.ck:foo Multiple arguments can be specified, each separated by the colon character. chuck foo.ck:foo:bar:boo Furthermore(此外), each ChucK program has its own set of arguments, which are specified separately. chuck foo.ck:foo bar.ck:bar boo.ck Command line arguments can also be used when using on-the-fly programming facilities(即时编程工具) of ChucK. chuck + foo.ck:foo bar.ck:bar:boo (后面有一篇博文会讲解相关参数功能的，包括这里的+) Machine.add() and Machine.replace() accept command line arguments in a similar fashion. 1234567// add foo.ck// pass foo and bar as command line argumentsMachine.add( "foo.ck:foo:bar" ) =&gt; int id;// replace shred with "bar.ck"// pass foo and bar as command line argumentsMachine.replace( id, "bar.ck:foo:bar" ); To access command line arguments within a ChucK program, use the me.args() and me.arg() functions. 123// print out all argumentsfor( int i; i &lt; me.numArgs(); i++ ) &lt;&lt;&lt; me.arg( i ) &gt;&gt;&gt;; 直接运行会输出： C:1&gt;chuck test.ck:foo [test.ck]:line(2): class 'Shred' has no member 'numArgs' (真就尴尬了)]]></content>
      <categories>
        <category>编程与生活</category>
      </categories>
      <tags>
        <tag>ChucK</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[chuck12]]></title>
    <url>%2Flangs%2Fchuck%2Fchuck12%2F</url>
    <content type="text"><![CDATA[unit analyzers &gt;new!!! declaring connecting controlling over time representing metadata: the UAnaBlob representing complex data performing analysis in UAna networks using events built-in unit analyzers creating (coming soon) #Unit Analyzers 单元分析器 Unit Analyzers (UAnae) are analyis building blocks, similar in concept to unit generators.They perform analysis functions on audio signals and/or metadata input, and produce metadata analysis results as output. (对音频信号或者元数据输入进行分析，把元数据分析结果作为输出) Unit analyzers can be linked together and with unit generators to form analysis/synthesis networks. Like unit generators, several unit analyzers may run concurrently, each dynamically(动态地) controlled at different rates. Because data passed between UAnae is not necessarily audio samples, and the relationship of UAna computation to time is fundamentally (根本地)different than that of UGens (e.g., UAnae might compute on blocks of samples, or on metadata), the connections between UAnae have a different meaning from the connections between UGens formed with the ChucK operator, =&gt;. This difference is reflected in the choice of a new connection operator, the upChucK operator: =^. Another key difference between UGens and UAnae is that UAnae perform analysis (only) on demand, via the upchuck() function (see below). Some more quick facts about ChucK unit analyzers: All ChucK unit analyzers are objects (not primitive(原始的) types). All ChucK unit analyzers inherit(继承) from the UAna class. The operation foo =^ yah, where foo and yah are UAnae, connects foo to yah. Unit analyzer parameters(参数) and behaviors(行为) are controlled by calling / chucking to member functions over time, just like unit generators. Analysis results are always stored in an object called a UAnaBlob. The UAnaBlob contains a time-stamp(时间标记) indicating(表明) when it was computed, and it may store an array(数组) of floats and/or complex(复杂的) values. Each UAna specifies(指定) what information is present in the UAnaBlob it produces.每个UAna指定它产生的UAnaBlob中的信息 All unit analyzers have the function upchuck(), which when called issues a cascade of(一系列的) analysis computations for the unit analyzer and any &quot;upstream(上游的)&quot; unit analyzers on which its analysis depends. (In the example of foo =^ yah, yah.upchuck() will result in foo first performing its analysis (possibly requesting analysis results from unit analyzers further upstream), then yah, using foo's analysis results in its computation. upchuck() returns the analysis results in the form of a UAnaBlob.) Unit analyzers are specially integrated into the virtual(虚拟的) machine such that each unit analyzer performs its analysis on its input whenever it or a downstream (下游的)UAna is upchuck()-ed. Therefore, we have the ability to assert(维护) control over the analysis process at any point in time and at any desired control rate. View a list of ChucK's built-in(嵌入的) unit analyzer(分解) classes #declaring Unit analyzers (UAnae) are objects, and they need to be instantiated before they can be used. 单元分析器是对象，使用前需要实例化 We declare unit analyzers the same way we declare UGens and other objects. // instantiate an FFT, assign reference to variable f FFT f; #connecting The upChucK operator (=^) is only meaningful(有意义的) for unit analyzers. Similar to the behavior(行为) of the ChucK operator between UGens, using =^ to connect one UAna to another connects the analysis results of the first to the analysis input of the second. // instantiate FFT and flux objects, // connect to allow computation of spectrum(频谱) and spectral flux on adc input adc =&gt; FFT fft =^ Flux flux =&gt; blackhole; Note that the last UAna in any chain must be chucked to the blackhole or dac to &quot;pull&quot; audio samples from the adc or other unit generators upstream. It is also possible to linearly(线性的) chain many UAnae together in a single statement(声明). In the example below, the analysis of flux_capacitor depends on the results of flux, so the flux object will always perform its analysis computation before the computation of flux_capacitor.分析计算是先后执行的 // Set up analysis on adc, via an FFT object, a spectral flux object, and a // made-up object called a FluxCapacitor that operates on the flux value. adc =&gt; FFT f =^ Flux flux =^ FluxCapacitor flux_capacitor =&gt; blackhole; Very importantly, it is possible to create connection networks containing both UAane and UGens. In the example below, an FFT transforms(改变) two (added) sinusoidal(正弦曲线的) inputs, one of which has reverb(混响) added. An IFFT transforms the spectrum(频谱) back into the time domain(频域转换为时域), and the result is processed(处理) with a third sinusoid(正弦曲线) by a gain object before being played through the dac(被通过dac播放). (No, this example is not supposed to do anything musically interesting, only help you get a feel for the syntax(语法).) Notice that any connection through which audio samples are passed is denoted(表示) with the =&gt; operator, and the connection through which spectral data is passed (from the FFT to the IFFT) is denoted with the =^ operator. //Chain a sine into a reverb, then perform FFT, then IFFT, then apply gain, then output SinOsc s =&gt; JCRev r =&gt; FFT f =^ IFFT i =&gt; Gain g =&gt; dac; // Chuck a second sine into the FFT SinOsc s2 =&gt; f; // Chuck a third sine into the final gain SinOsc s3 =&gt; g; FFT, IFFT, and other UAnae that perform transforms between the audio domain and another domain play a special role, as illustrated above(正如上文所述). FFT takes audio samples(样品) as input, so unit generators connect to it with the ChucK operator =&gt;. However, it outputs(输出) analysis results in the spectral domain, so it connects to other UAnae with the upChucK operator =^. Conversely(相反的), UAnae producing spectral domain output connect to the IFFT using =^, and IFFT can connect to the dac or other UGens using =&gt;. This syntax(语法) allows the programmer to clearly reason about the expected behavior(行为) of an analysis/synthesis(分析综合，分解重构) network, while it hides the internal mechanics(内部机制) of ChucK timing and sample buffering from the programmer. Finally, just as with unit generators, it is possible to dynamically (动态地)disconnect (拆开)unit analyzers, using the UnChucK operator (=&lt; or !=&gt;). #controlling (over time) In any ChucK program, it is necessary to advance time in order to pull audio samples(样品) through the UGen network and create sound. Additionally(此外), it is necessary to trigger(引发) analysis computations(计算) explicitly(显式地) in order for any analysis to be performed, and for sound synthesis(合成) that depends on analysis results (e.g., IFFT) to be performed. To explicitly trigger computation at a point in time, the UAna's upchuck() member function is called. upchuck()：显式引发计算 In the example below, an FFT computation is triggered(引发) every 1024 samples. adc =&gt; FFT fft =&gt; dac; // set the FFT to be of of size 2048 samples 2048 =&gt; fft.size; while (true) { // let 1024 samples pass 1024::samp =&gt; now; // trigger the FFT computation on the last 2048 samples (the FFT size) fft.upchuck(); } In the example above, because the FFT size is 2048 samples, the while-loop causes a standard &quot;sliding-window(滑动窗)&quot; FFT to be computed, where the hop size(步进值) is equal to half a window. However, ChucK allows you to perform analysis using nonstandard, dynamically(动态地) set, or even multiple hop sizes with the same object. 非标准的动态设定或者甚至多倍的步进大小 For example, in the code below, the FFT object fft performs computation every 5 seconds as triggered by shred1, and it additionally performs computation at a variable(可变的) rate as triggered by shred2. adc =&gt; FFT fft =&gt; dac; 2048 =&gt; fft.size; // spork two shreds: shred1 and shred2 spork ~shred1(); spork ~shred2(); // shred1 computes FFT every 5 seconds fun void shred1() { while (true) { 5::second =&gt; now; fft.upchuck(); } } // shred2 computes FFT every n seconds, where n is a random number between 1 and 10 fun void shred2() { while (true) { Std.rand2f(1, 10)::second =&gt; now; fft.upchuck(); } } Parameters(参数) of unit analyzers may be controlled and altered at any point in time and at any control rate. We only have to assert(维护) control at the appropriate(适当的) points as we move through time, by setting various parameters of the unit analyzer. To set the a value for a parameter of a UAna, a value of the proper type should be ChucKed to the corresponding control function. // connect the input to an FFT adc =&gt; FFT fft =&gt; blackhole; //start with a size of 1024 and a Blackman-Harris window 1024 =&gt; fft.size; Windowing.blackmanHarris(512) =&gt; fft.window; //advance time and compute FFT 1::minute =&gt; now; fft.upchuck(); // change window to Hamming Windowing.hamming(512) =&gt; fft.window; // let time pass... and carry on. Since the control functions are member functions of the unit analyzer, the above syntax(语法) is equilavent to calling functions. For example, the line below could alternatively(作为选择) be used to change the FFT window to a Hamming window, as above. fft.window(Windowing.hamming(512)); For a list of unit analyzers and their control methods, consult(查阅) UAna reference. Just like unit generators, to read the current value of certain parameters of a Uana, we may call an overloaded function of the same name.就像单元发生器，读取当前Uana的某个参数的值，可以调用重载的同名函数 Additionally, assignments(分配) can be chained together when assigning(分配) one value to multiple targets.给多的目标分配一个值时，可以串联起来 // connect adc to FFT adc =&gt; FFT fft =&gt; blackhole; // store the current value of the FFT size fft.size() =&gt; int fft_size; What if a UAna that performs analysis on a group of audio samples(样品) is upchuck()-ed before its internal(内部的) buffer(缓冲区) is filled? This is possible if an FFT of size 1024 is instantiated(实例化), then upchuck()-ed after only 1000 samples, for example. In this case, the empty buffer slots(位置) are treated as 0's (that is, zero-padding(补零) is applied空的缓存区会被置零). This same behavior(行为) will occur if the FFT object's size is increased from 1024 to 2048, and then only 1023 samples pass after this change is applied; the last sample in the new (larger) buffer will be 0. Keep in mind, then, that certain analysis computations near the beginning of time and analysis computations after certain parameters(参数) have changed will logically(逻辑上) involve(包含) a short &quot;transient(短暂的)&quot; period. // connect adc to FFT to blackhole adc =&gt; FFT fft =&gt; blackhole; // set the FFT size to 1024 samples 1024 =&gt; fft.size; // allow 1000 samples to pass 1000::samp =&gt; now; // compute the FFT: the last 24 spots in the FFT buffer haven&#39;t been filled, so they are zero-ed out归零，置零 // the computation is nevertheless valid and proceeds.计算仍然是有效又有收益的。 fft.upchuck(); 1::minute =&gt; now; // let time pass for a while // increase the size of the FFT, and therefore the size of the sample buffer it uses 2048 =&gt; fft.size; // let 1023 samples pass // 会填满1023个缓存点 1023::samp =&gt; now; // at this point, only 2047 of the 2048 buffer spots have been filled // 这处，2048中只有2047个缓存位置被填满——怎么算的？1000+24+1023 // the following computation therefore zeros out the last audio buffer spot // 此句置零了最后一个音频缓存点 fft.upchuck(); 1::minute =&gt; now; //let time pass for a while // now the buffer is happy and full fft.upchuck(); // proceeds normally on a full buffer #representing metadata: the UAnaBlob It is great to be able to trigger(引发) analysis computations like we've been doing above, but what if you want to actually use the analysis results? Luckily, calling the upchuck() function on a UAna returns a reference to an object that stores the results of any UAna analysis, called a UanaBlob. UanaBlobs can contain an array of floats, and/or an array of complex numbers (see the next section). The meaning and formatting(格式化) of the UanaBlob fields(字段) is different for each UAna subtype(子类型). FFT, for example (see specification), fills in the complex array with the spectrum(频谱的复数数组) and the floating point array with the magnitude spectrum(振幅谱的浮点数组). Additionally, all UanaBlobs store the time when the blob was last computed. The example below demonstrates(证明) how one might access(访问) the results of an FFT: adc =&gt; FFT fft =&gt; blackhole; // ... set FFT parameters here ... UAnaBlob blob; while (true) { 500::ms =&gt; now; // use hop size of 50 ms fft.upchuck() @=&gt; blob; // `store` the result in blob. blob.fvals() @=&gt; float mag_spec[]; // get the magnitude spectrum as float array blob.cvals() @=&gt; complex spec[]; // get the whole spectrum as complex array // get `the first bin`(这个指什么？？？) of the magnitude spectrum mag_spec[0] =&gt; float first_mag; blob.fval(0) =&gt; float first_mag2; // equivalent way to get first bin of mag spectrum fft.upchuck().fval(0) =&gt; float first_mag3; // yet another equivalent way fft.upchuck().cval(0) =&gt; complex first_spec; // similarly, get 1st spectrum bin blob.when() =&gt; time when_computed; // get the time it was computed } Beware: whenever a UAna is upchuck()-ed, the contents of its previous UAnaBlob are overwritten. In the following code, blob1 and blob2 refer to the same UAnaBlob. When fft.upchuck() is called the second time, the contents of the UAnaBlob referred to by blob1 are overwritten. adc =&gt; FFT fft =&gt; blackhole; UAnaBlob blob1, blob2; 1::minute =&gt; now; //let time pass for a while fft.upchuck() @=&gt; blob1; // blob1 points to `the analysis results` 1::minute =&gt; now; // let time pass again fft.upchuck() @=&gt; blob2; // now both blob1 and blob2 refer to the same object: **the new results!** Also beware: if time is not advanced between subsequent(后来的) upchuck()s of a UAna, any upchuck() after the first will not re-compute the analysis, even if UAna parameters have been changed. After the code below, blob refers to a UAnaBlob that is the result of computing the first (size 1024) FFT.指向第一次计算的结果的UAnaBlob adc =&gt; FFT fft =&gt; blackhole; 1024 =&gt; fft.size; UAnaBlob blob; 1::minute =&gt; now; //let time pass for a while fft.upchuck() @=&gt; blob; // blob holds the result of the FFT 512 =&gt; fft.size; fft.upchuck() @=&gt; blob; // time hasn&#39;t advanced since the last computation, so no re-computation is done #representing complex data: the complex and polar types In order to represent complex data, such as the output of an FFT, two new datatypes have been added to ChucK: complex and polar. #performing analysis in UAna networks Often, the computation of one UAna will depend on the computation results of &quot;upstream&quot; UAnae. For example, in the UAna network below, the spectral flux(频谱流量) is computed using the results of an FFT. adc =&gt; FFT fft =^ Flux flux =&gt; blackhole; The flow of computation in UAna networks is set up(设置) so that every time a UAna a is upchuck()-ed, each UAna whose output is connected to a's input via =^ is upchuck()-ed first, passing the results to a for it to use. For example, a call to flux.upchuck() will first force fft to compute an FFT on the audio samples in its buffer, then flux will use the UanaBlob from fft to compute the spectral flux. This flow of computation is handled internally by ChucK; you should understand the flow of control, but you don't need to do fft.upchuck() explicitly. Just writing code like that below will do the trick: adc =&gt; FFT fft =^ Flux flux =&gt; blackhole; UAnaBlob blob; while (true) { 100::ms =&gt; now; flux.upchuck() @=&gt; blob; // causes fft to compute, then computes flux and stores result in blob } Additionally, each time a UAna upchuck()s, its results are cached(缓存) until time passes. This means that a UAna will only perform its computation once for a particular point in time. adc =&gt; FFT fft =^ Flux flux =&gt; blackhole; fft =^ Centroid c =&gt; blackhole; UAnaBlob blob, blob2; while (true) { 100::ms =&gt; now; flux.upchuck() @=&gt; blob; // causes fft to compute, then computes flux and stores result in blob c.upchuck() @=&gt; blob2; // uses cached fft results from previous line to compute centroid } When no upchuck() is performed on a UAna, or on UAnae that depend on it, it will not do computation. For example, in the network below, the flux is never computed. adc =&gt; FFT fft =^ Flux flux =&gt; blackhole; UAnaBlob blob; while (true) { 100::ms =&gt; now; fft.upchuck() @=&gt; blob; // compute fft only } The combination of this &quot;compute-on-demand&quot; behavior(这种按需计算行为的组合) and UAna caching means that different UAnae in a network can be upchuck()-ed at various/varying control rates, with maximum efficiency. In the example below, the FFT, centroid, and flux are all computed at different rates. When the analysis times for flux and fft or centroid and fft overlap(同时发生), fft is computed just once due to its internal caching. When it is an analysis time point for fft but not for flux, flux will not be computed. adc =&gt; FFT fft =^ Flux flux =&gt; blackhole; fft =^ Centroid c =&gt; blackhole; UAnaBlob blob1, blob2, blob3; spork ~do_fft(); spork ~do_flux(); spork ~do_centroid(); while (true) { //Keep parent shred going 1::minute =&gt; now; //感觉是多进程必要的一段代码 } fun void do_fft() { while (true) { 50::ms =&gt; now; fft.upchuck() @=&gt; blob1; } } fun void do_flux() { while (true) { 110::ms =&gt; now; flux.upchuck() @=&gt; blob2; } } fun void do_centroid() { while (true) { 250::ms =&gt; now; c.upchuck() @=&gt; blob3; } } An easy way to synchronize analysis of many UAnae is to upchuck() an &quot;agglomerator(凝聚剂)&quot; UAna. In the example below, agglom.upchuck() triggers analysis of all upstream UAnae in the network. Because agglom is only a member of the UAna base class, it does no computation of its own. However, after agglom.upchuck(), all other UAnae will have up-to-date results that are synchronized, computed, and cached so that they are available to be accessed via upchuck() on each UAna (possibly by a different shred waiting for an event-- see below). adc =&gt; FFT fft =^ Flux flux =^ UAna agglom =&gt; blackhole; fft =^ Centroid centroid =^ agglom; // could add arbitrarily(反复地) many more UAnae that connect to agglom via =^ while (true) { 100::ms =&gt; now; agglom.upchuck(); // forces computation of both centroid and flux (and therefore fft, too) } Because of the dependency and caching behavior of upchuck()-ing in UAna networks, UAna feedback loops should be used with caution. In the network below, each time c is upchuck()-ed, it forces b to compute, which forces a to compute, which then recognizes that b has been traversed(遍历) in this upChucK path but has not been able to complete its computation-- thereby(因此) recognizing a loop in the network. a then uses b's last computed UAnaBlob to perform its computation. This may or may not be desirable, so be careful.可能不理想 adc =&gt; UAna a =^ UAna b =^ Uana c =&gt; blackhole; b =^ a; // creates a feedback loop while (true) { 100::ms =&gt; now; c.upchuck(); // involves a using b&#39;s analysis results from 100 ms ago } Another handy(方便的) UAna for synchronizing feature extraction(同步特征提取) is the FeatureCollector. Calling upchuck() on a FeatureCollector triggers computation of all upstream UAnae, and it concatenates(连接) their output blob data(BLOB二进制大数据) into a feature vector that can be used as input to a classifier(分类器), for example using smirk. adc =&gt; FFT fft =^ Flux flux =^ FeatureCollector fc =&gt; blackhole; fft =^ Centroid centroid =^ fc; // could add abitrarily many more UAnae that connect to fc via =^ while (true) { 100::ms =&gt; now; // forces computation of both centroid and flux (and therefore fft, too) // an vectorBlob&#39;s fvals and cvals will be a concatenation(连接) of the feature values fc.upchuck() @=&gt; UAnaBlob vectorBlob; } #built-in unit analyzers ChucK has a number of built-in UAna classes. These classes perform many basic transform(变换) functions (FFT, IFFT) and feature extraction(特征提取) methods (both spectral and time-domain features(频域时域特征)). A list of built-in ChucK unit analyzers can be found here. #creating ( someday soon you will be able to implement your own unit analyzers! ) 单元分析器的个人实现]]></content>
      <categories>
        <category>编程与生活</category>
      </categories>
      <tags>
        <tag>ChucK</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[chuck5]]></title>
    <url>%2Flangs%2Fchuck%2Fchuck5%2F</url>
    <content type="text"><![CDATA[operators &amp; operations =&gt; (chuck) / (arithmetic) % (modulo) &amp;&amp; || == != &gt;= &lt;=&quot; (logic) &amp; | ^ (bitwise) ++ -- (inc / dec) ! + - new (unary) You may have seen many of the operators in other programming languages (C/Java). Some others are native to ChucK. We start with the family of ChucK operators. #=&gt; (the ChucK operator) The ChucK operator (=&gt;) is a massively(大量地) overloaded operator that, depending on the types involved(包含), performs various actions(执行各种操作). It denotes(表示) **action**, can be chained(链接), and imposes(强制执行) and clarifies order(理清顺序) (always goes *from left to right*). The ChucK operator is the means by which work is done in ChucK. Furthermore(此外), the ChucK operator is not a single operator, but a family of operators. ##=&gt; (foundational(基础的) ChucK operator) We start with the standard, plain-vanilla(普通的，无修饰的) ChucK operator (=&gt;). It is left-associative (all ChucK operators are), which allows us to specify(指定) any ordered flow of data/tasks/modules (such as unit generator connection) from left to right, as in written (English) text. What =&gt; does depends on the context(环境). It always depends on the type of the entity(实体) on the left (the chucker(投手)) and the one on the right (the chuckee(接球手)), and it sometimes also depends on the nature of the entity (such as whether it is a variable(变量的) or not). Some examples: (用了c的高亮，至少好看点) 1234567891011// a unit generator patch - the signal flow is apparent// (in this case, =&gt; connects two unit generators)SinOsc b =&gt; Gain g =&gt; BiQuad f =&gt; dac;// add 4 to foo, chuck result to new 'int' variable 'bar'// (in this case, =&gt; assigns a value to a variable (int)4 + foo =&gt; int bar;// chuck values to a function == function call// (same as Math.rand2f( 30, 1000))( 30, 1000 ) =&gt; Math.rand2f; There are many other well-defined(定义明确的) uses of the ChucK operator, depending on the context. ##@=&gt; (explicit(明确的) assignment(分配) ChucK operator) In ChucK, there is no stardard assignment operator (=), found in many other programming languages. Assignment is carried out using ChucK operators. In the previous examples, we have used =&gt; for assignment: 1234567891011// assign 4 to variable foo4 =&gt; int foo;// assign 1.5 to variable bar1.5 =&gt; float bar;// assign duration of 100 millisecond to duh100::ms =&gt; dur duh;// assign the time "5 second from now" to later5::second + now =&gt; time later; The @=&gt; explicit assignment ChucK operator behaves exactly the same for the above types (int, float, dur, time). However, the difference is that @=&gt; can also be used for reference assignments(分配) of objects (see objects and classes) whereas(然而) =&gt; only does assignment on primitive(原始的) types (int, float, dur, time). The behavior(行为) of =&gt; on objects is completely context-dependent(上下文相关的). 1234567891011121314151617// using @=&gt; is same as =&gt; for primitive types4 @=&gt; int foo;// assign 1.5 to variable bar1.5 @=&gt; float bar;// (only @=&gt; can perform reference assignment on objects)// reference assign moe to larry// (such that both moe and larry reference the same object)Object moe @=&gt; Object @ larry;// array initialization[ 1, 2 ] @=&gt; int ar[];// using newnew Object @=&gt; moe; In its own screwed-up(糟透了的) way, this is kind of nice because there is no confusion(混淆) between assignment (@=&gt; or =&gt;) and equality (==). In fact, the following is not a valid ChucK statement(声明): // not a valid ChucK statement! int foo = 4; ##+=&gt; -=&gt; *=&gt; /=&gt; etc. (arithmetic(算数) ChucK operators) These operators are used with variables(变量) (using 'int' and 'float') to perform one operation with assignment(执行一个有分配的操作). 12345678910111213141516// add 4 to foo and assign result to foofoo + 4 =&gt; foo;// add 4 to foo and assign result to foo4 +=&gt; foo;// subtract 10 from foo and assign result to foo// remember this is (foo-10), not (10-foo)10 -=&gt; foo;// 2 times foo assign result to foo2 *=&gt; foo;// divide 4 into foo and assign result to foo// again remember this is (foo/4), not (4/foo)4 /=&gt; foo; It is important to note the relationship between the value and variable when using -=&gt; and /=&gt;, since these operations are not commutative(交换的). 12345678// mod foo by T and assign result to fooT %=&gt; foo;// bitwise(按位) AND 0xff and bar and assign result to bar0xff &amp;=&gt; bar;// bitwise OR 0xff and bar and assign result to bar0xff |=&gt; bar; #+ - * / (arithmetic) 1234567891011// divide (and assign)16 / 4 =&gt; int four;// multiply2 * 2 =&gt; four;// add3 + 1 =&gt; four;// subtract93 - 89 =&gt; four; cast(转换) ChucK implicitly(隐式地) casts int values to float when float is expected, but not the other around. The latter could result in a loss of information and requires an explicit(明确的) cast. 123456789101112// adding float and int produces a float9.1 + 2 =&gt; float result;// however, going from float to int requires cast4.8 $ int =&gt; int foo; // foo == 4//这里的$是什么意思？// this function expects two floatsMath.rand2f( 30.0, 1000.0 );// this is ok because of implicit castMath.rand2f( 30, 1000 ); #% (modulo(取模)) The modulo operator % computes the remainder(余数) after integer(整数), floating point, duration, and time/duration division. 1234567891011// 7 mod 4 (should yield(产生) 3)7 % 4 =&gt; int result;// 7.3 mod 3.2 floating point mod (should yield .9)7.3 % 3.2 =&gt; float resultf;// duration mod5::second % 2::second =&gt; dur foo;// time/duration modnow % 5::second =&gt; dur bar; the latter (time/duration mod) is one of many ways to dynamically(动态地) synchronize(同步) timing in shreds. the examples otf_01.ck through otf_07.ck (see under examples) make use of this to on-the-fly(运行时) synchronize its various parts, no matter when each shred is added to the virtual(虚拟的) machine: 1234567891011// define period (agreed upon by several shreds).5::second =&gt; dur T;// compute the remainder(余数) of the current period ...// and advance time by that amountT - (now % T) =&gt; now;// when we reach this point, we are synchronized to T period boundary// the rest of the code// ... This is one of many ways to compute and reason about(思考) time in ChucK. The appropriate(适当的) solution(解决方案)(s) in each case depends on the intended(打算的) functionality(功能). #&amp;&amp; || == != &gt; &gt;= &lt; &lt;= (logic)(逻辑) Logical operators - each of these need two operands(操作数). The result is an integer value of 0 or 1. &amp;&amp; : and || : or == : equals != : does not equal : greater than = : greater than or equal to &lt; : less than &lt;= : less than or equal to 123// test some universal truths(普遍的真理)if( 1 &lt;= 4 &amp;&amp; true ) &lt;&lt;&lt;"horray"&gt;&gt;&gt;; #&gt;&gt; &lt;&lt; &amp; | ^ (bitwise)(按位) These are used on int values at the bit level, often for bit masking. 12345&gt;&gt; : shift bits right(右移位) ( 8 &gt;&gt; 1 = 4 )&lt;&lt; : shift bits left ( 8 &lt;&lt; 1 = 16 )&amp; : bitwise AND| : bitwise OR^ : bitwise XOR #++ -- (inc / dec) Values may be incremented or decremented by appending(附加) the ++ or -- operators. 1234 =&gt; int foo;foo++;foo--; #! + - new (unary(一元的)) These operators come before(位于...之前) one operand(操作数). 123456789// logical invertif( !true == false ) &lt;&lt;&lt;"yes"&gt;&gt;&gt;;// negative-1 =&gt; int foo;// instantiate objectnew object @=&gt; object @ bar;]]></content>
      <categories>
        <category>编程与生活</category>
      </categories>
      <tags>
        <tag>ChucK</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[chuck4]]></title>
    <url>%2Flangs%2Fchuck%2Fchuck4%2F</url>
    <content type="text"><![CDATA[arrays * declaring * multi-dimensional * lookup * associative arrays * assignment #Arrays This sections specifies(指定) how arrays are declared and used in ChucK. Some quick notes: * arrays can be indexed by integer(整数) (0-indexed). * any array can also be used as an associative(联想的) map, indexed by strings. * it is important to note that the integer-indexed portion(部分) and the associative portion of an array are stored in separate namespaces * arrays are objects, and will behave similarly under reference assignment(引用赋值) and other operations common to objects. #declaration Arrays(数组) can be declared in the following way: // declare 10 element array of int, called foo int foo[10]; // since array of int (primitive type), the contents // are automatically initialized to 0 Arrays can also be initialized(初始化): // chuck intializer(初始化器，程序) to array reference [ 1, 1, 2, 3, 5, 8 ] @=&gt; int foo[]; In the above code, there are several things to note: * initializers must contain the same or similar types. the compiler(编译器) will attempt to find the highest common base type of all the elements(元素). if no such common element is found, an error is reported. * the type of the initializer [ 1, 1, 2, 3, 5, 8 ] is int[]. the intializer is an array that can be used directly when arrays are expected. * the at-chuck operator (@=&gt;) means assignment(分配), and is discussed at length(详细地) in operators and operations. * int foo[] is declaring an empty reference(引用) to an array(数组). the statement(声明) assigns(分配) the initializer array to foo. * arrays are objects. When declaring an array of objects, the objects inside the array are automatically(自动的) instantiated(实例化). // objects in arrays are automatically instantiated Object group[10]; If you only want an array of object references:(对象引用数组) // array of null object references Object @ group[10]; Check here more information on object declaration and instantation in Chuck. The above examples are 1-dimensional arrays (or vectors(矢量)). #multi-dimensional arrays It is possible (and equally easy) to declare multi-dimensional arrays: // declare 4 by 6 by 8 array of float float foo3D[4][6][8];//和C还是很像 Initializers work in similar ways: // declare 2 by 2 array of int [ [1,3], [2,4] ] @=&gt; int bar[][]; In the above code, note the two [][] since we make a matrix. #lookup Elements in an array can be accessed using [] /(in the appropriate quantities). // declare an array of floats [ 3.2, 5.0, 7 ] @=&gt; float foo[]; // access the 0th element (debug print) &lt;&lt;&lt; foo[0] &gt;&gt;&gt;; // hopefully 3.2 // set the 2nd element 8.5 =&gt; foo[2]; Looping over the elements of an array: // array of floats again [ 1, 2, 3, 4, 5, 6 ] @=&gt; int foo[]; //官方的例子这里是float，但是实际测试，整型不可以被分配到float里。 // loop over the entire array for( 0 =&gt; int i; i &lt; foo.cap(); i++ )//foo.cap() { // do something (debug print) &lt;&lt;&lt; foo[i] &gt;&gt;&gt;;//自带换行 } Accessing multi-dimensional array: // 2D array int foo[4][4]; // set an element 10 =&gt; foo[2][2]; If the index exceeds(超过) the bounds of the array in any dimension(标出尺寸), an exception(异常) is issued(被放出) and the current shred(片段) is halted(停止). // array capacity is 5 int foo[5]; // this should cause ArrayOutOfBoundsException // access element 6 (index 5) &lt;&lt;&lt; foo[5] &gt;&gt;&gt;; a longer program: otf_06.ck from examples: // the period .5::second =&gt; dur T; // synchronize to period (for on-the-fly(运行中) synchronization) T - (now % T) =&gt; now; // our patch SinOsc s =&gt; JCRev r =&gt; dac;//JCRev是指什么类型？ // initialize .05 =&gt; s.gain; .25 =&gt; r.mix; // scale (pentatonic(五音阶的); in semitones(半音程)) [ 0, 2, 4, 7, 9 ] @=&gt; int scale[]; // infinite time loop while( true ) { // pick something from the scale scale[ Math.rand2(0,4) ] =&gt; float freq; // get the final freq Std.mtof( 69 + (Std.rand2(0,3)*12 + freq) ) =&gt; s.freq; // reset phase for extra bandwidth(为额外带宽重置相位) 0 =&gt; s.phase; // advance time if( Std.randf() &gt; -.5 ) .25::T =&gt; now; else .5::T =&gt; now; } #associative arrays(关联数组) (类似于python中的字典，用字符串索引) Any array(数组) can be used also as an associative array, indexed on strings. Once the regular array is instantiated, no further work has to be done to make it associative as well - just start using it as such. // declare regular array(正规数组) (capacity(容量) doesn&#39;t matter so much) float foo[4]; // use as int-based array 2.5 =&gt; foo[0]; // use as associative array 4.0 =&gt; foo[&quot;yoyo&quot;]; // access as associative (print) &lt;&lt;&lt; foo[&quot;yoyo&quot;] &gt;&gt;&gt;; // access empty element &lt;&lt;&lt; foo[&quot;gaga&quot;] &gt;&gt;&gt;; // -&gt; should print 0.0 It is important to note (again), that the address space of the integer(整数) portion(部分) and the associative portion of the array are completely separate. For example: // declare array int foo[2]; // put something in element 0 10 =&gt; foo[0]; // put something in element &quot;0&quot; 20 =&gt; foo[&quot;0&quot;]; // this should print out 10 20 &lt;&lt;&lt; foo[0], foo[&quot;0&quot;] &gt;&gt;&gt;; The capacity(容量) of an array relates only to the integer portion of it. An array with an integer portion of capacity 0, for example, can still have any number of associative indexes. // declare array of 0 capacity int foo[0]; // put something in element &quot;here&quot; 20 =&gt; foo[&quot;here&quot;]; // this should print out 20 &lt;&lt;&lt; foo[&quot;here&quot;] &gt;&gt;&gt; // this should cause an exception &lt;&lt;&lt; foo[0] &gt;&gt;&gt; Note: The associative capacity of an array is not defined(定义), so objects used in the associative namespace must be explicitly(明确的) instantiated, in contrast(对比) to those in the integer namespace (此处不甚明白) Accessing an uninstantiated element(元素) of the associate array will return a null reference. Please check the class documentation page for an explanation of ChucK objects and references. class Item { float weight; } Item box[10]; // integer indices(指数；目录（index的复数）) ( up to capacity ) are pre-instantiated. 1.2 =&gt; box[1].weight; // instantiate element &quot;lamp&quot;; new Item @=&gt; box[&quot;lamp&quot;]; // access allowed to &quot;lamp&quot; 2.0 =&gt; box[&quot;lamp&quot;].weight; // access causes a `NullPointerException` 2.0 =&gt; box[&quot;sweater&quot;].weight; #array assignment Arrays are objects. So when we declare an array, we are actually (1) declaring a reference to array (reference variable(引用变量)) (2) instantiating a new array and reference assigned(分配) to the variable. A (null) reference is a reference variable that points to no object or null. A null reference to an array can be created in this fashion: // declare array reference (by not specifying(指定) a capacity) int foo[]; // we can now assign any int[] to foo [ 1, 2, 3 ] @=&gt; foo; // print out 0th element &lt;&lt;&lt; foo[0] &gt;&gt;&gt;; This is also useful in declaring functions that have arrays(数组) as arguments or return type. // our function fun void print( int bar[] ) { // print it for( 0 =&gt; int i; i &lt; bar.cap(); i++ ) &lt;&lt;&lt; bar[0] &gt;&gt;&gt;; } // we can call the function with a literal print( [ 1, 2, 3, 4, 5 ] ); // or can we can pass a reference variable int foo[10]; print( foo ); Like other objects, it is possible make multiple references(多个引用) to a single array. Like other objects, all assignments(分配) are reference assignments, meaning the contents are NOT copied, only a reference to array is duplicated(被复制).(传递引用) // our single array int the_array[10]; // assign reference to foo and bar the_array =&gt; int foo[] =&gt; int bar[]; // (the_array, foo, and bar now all reference the same array) // we change the_array and print foo... // they reference the same array, changing one is like changing the other // 连锁反应，内存中的存储信息改变了 5 =&gt; the_array[0]; &lt;&lt;&lt; foo[0] &gt;&gt;&gt;; // should be 5 It is possible to reference sub-sections(小节) of multi-dimensional(多维) arrays. // a 3D array int foo3D[4][4][4]; // we can make a reference to a sub-section foo3D[2] =&gt; int bar[][]; // (note that the dimensions must add up!)]]></content>
      <categories>
        <category>编程与生活</category>
      </categories>
      <tags>
        <tag>ChucK</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[chuck1]]></title>
    <url>%2Flangs%2Fchuck%2Fchuck1%2F</url>
    <content type="text"><![CDATA[Build/Install Instructions 如是直接安装（win）可以忽略上面的。* The ChucK Tutorial* This tutorial(个别指导) was written for the command line version of ChucK (currently the most stable(稳定的) and widely supported). Other methods of running ChucK includes the miniAudicle (now on all major platforms) and the Audicle (in pre-pre-alpha). The code is the same, but the way to run them differs, depending the ChucK system. ...generate a sine wave and send to the speaker... ...connecting audio processing modules (unit generators) and having them work together to compute the sound. // connect sine oscillator to D/A convertor (sound card) SinOsc s =&gt; dac; The above does several things: (1) it creates a new unit generator of type &#39;SinOsc&#39; (sine oscillator(振荡器)), and store its reference(引用) in variable(变量的) &#39;s&#39;. (2) &#39;dac&#39; (D/A convertor(转炉)) is a special *unit generator* (created by the system) which is our abstraction(抽象) for the underlying(潜在的) audio interface(界面). (3) we are using the ChucK operator (=&gt;) to ChucK &#39;s&#39; to &#39;dac&#39;. In ChucK, when one unit generator is ChucKed to another, we connect them. We can think of this line as setting up a data flow from 's', a signal generator, to 'dac', the sound card/speaker. Collectively(集体的), we will call this a 'patch'. ...we simply have to &quot;allow time to pass&quot; for data to be computed...time and audio data are both inextricably(密不可分) related in ChucK (as in reality), and separated in the way they are manipulated(操纵). let's generate our sine wave and hear it by adding one more line: // connect sine oscillator to D/A convertor (sound card) SinOsc s =&gt; dac; // allow 2 seconds to pass 2::second =&gt; now; Let's now run this (assuming(假设) you saved the file as 'foo.ck'): %&gt; chuck foo.ck For now, we can just take the second line of code to mean &quot;let time pass for 2 seconds (and let audio compute during that time)&quot;. If you want to play it indefinitely(无限制地), we could write a loop: //////////// //example1// //////////// // connect sine oscillator to D/A convertor (sound card) SinOsc s =&gt; dac; // loop in time while( true ) { 2::second =&gt; now; //(we used 2::second here, but we could have used any number of //&#39;ms&#39;, &#39;second&#39;, &#39;minute&#39;, &#39;hour&#39;, &#39;day&#39;, and even &#39;week&#39;) } In ChucK, this is called a 'time-loop' (in fact this is an 'infinite time loop'). To stop a ongoing ChucK program from the command line, hit (ctrl - c). Now, let's try changing the frequency randomly every 100ms: // make our patch SinOsc s =&gt; dac; // time-loop, in which the osc&#39;s frequency is changed every 100 ms while( true ) { 100::ms =&gt; now; Std.rand2f(30.0, 1000.0) =&gt; s.freq; } Two more things to note here. (1) We are advancing time inside the loop by 100::ms durations. (2) A random value between 30.0 and 1000.0 is generated and &#39;assigned&#39; to the oscillator&#39;s frequency, every 100::ms. 目前运行的结果是有并不规律的声音产生，这就是那个时刻变形的声波 Now let's write another (slightly longer) program: (these files can be found in the examples/ directory, so you don't have to type them in) //////////// //example2// //////////// // impulse(脉冲信号) to filter to dac //Biquad filter（双二阶滤波器） Impulse i =&gt; BiQuad f =&gt; dac; // set the filter&#39;s pole radius( = prad) .99 =&gt; f.prad; // set equal gain zero&#39;s 1 =&gt; f.eqzs;//不理解 // initialize float variable 0.0 =&gt; float v; // infinite time-loop while( true ) { // set the current sample/impulse 1.0 =&gt; i.next; // sweep the filter resonant frequency(共振频率) Std.fabs(Math.sin(v)) * 4000.0 =&gt; f.pfreq; // increment(增量) v v + .1 =&gt; v; // advance time 100::ms =&gt; now; } Name this moe.ck, and run it: chuck moe.ck Now, make two copies of moe.ck - larry.ck and curly.ck. Make the following modifications(修改). 1) change larry.ck to advance time by 99::ms (instead of 100::ms). 2) change curly.ck to advance time by 101::ms (instead of 100::ms). 3) optionally, change the 4000.0 to something else (like 400.0 for curly). Run all three in parallel: chuck moe.ck larry.ck curly.ck What you hear (if all goes well) should be 'phasing' between moe, larry, and curly, with curly emitting(发出) the lower-frequency pulses(脉冲). ChucK supports sample-synchronous concurrency(并发性), via the ChucK timing mechanism(机制). Given any number of source files that uses the timing mechanism above, the ChucK VM can use the timing information to automatically(自动地) synchronize(合拍) all of them... Note that each process do not need to know about each other - it only has to deal with time locally. The VM will make sure things happen correctly and globally. A large collection of pre-made examples have been arranged and provided with this distribution in the /doc/examples directory, and are mirrored here]]></content>
      <categories>
        <category>编程与生活</category>
      </categories>
      <tags>
        <tag>ChucK</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[chuck10]]></title>
    <url>%2Flangs%2Fchuck%2Fchuck10%2F</url>
    <content type="text"><![CDATA[classes and objects introduction existing classes working with objects writing a class members (data + functions) static (data + functions) inheritance overloadation (overloading + overriding) #introduction Chuck implements(实现) an object system that borrows from both C++ and Java conventions. In our case this means: You can define(定义) custom classes as new types and instantiate objects自定义类 ChucK supports polymorphic inheritance(多态继承) (this is the same model used in Java, and also known as virtual inheritance in C++) All object variables(变量) are references (like Java), but instantiation(实例化) resembles(类似于) C++. We will discuss this in detail below. There is a default class library. All objects inherit(继承) from the Object class (as in Java) For the sake(目的) of clarity(清楚) we will define(定义) these terms: a class is an abstraction of data (members) and behavior(行为) (methods) a class is a type. an object is an instantiation of that class a reference variable refers indirectly to an object - it is not the object itself. All ChucK object variables are reference variables(变量) (like in Java). similarly, reference assignment(引用赋值) duplicates a reference to an object and assigns(分配) the reference to a reference variable. The object itself is not duplicated. All ChucK object assignments are reference assignments.所有对象赋值都是引用赋值 #built-in classes ChucK has a number of classes defined(定义) within the language. Object : base class to all ChucK objects. Event : ChucK's basic synchronization(同步) mechanism(机制); may be extended(延伸) to create custom Event functionality(功能) (discussed here). Shred : basic abstraction(抽象) for a non-preemptive ChucK process(非抢占式进程). UGen : base unit generator class (discussed here). These are some of the more commonly used classes in ChucK. #working with objects Let's begin with some examples. For these examples, let's assume Foo is a defined class. // create a Foo object; stored in reference variable bar Foo bar; The above code does two things: a reference variable bar is declared; its type is Foo. a new instance of Foo is created, and its reference is assigned to bar. Note that in contrast to(与...相比) Java, this statement both declares a reference variable and instantiates a instance of that class and assigns the reference to the variable. Also note that in contrast to C++, bar is a reference, and does not represent the object itself. To declare a reference variable that refers to nothing (also called a null reference): // create a null reference to a Foo object Foo @ bar; The above code only declare a reference and initializes it to null. (random note: the above statement may be read as &quot;Foo at bar&quot;) We can assign a new instance to the reference variable: // assign new instance of Foo to bar new Foo @=&gt; Foo @ bar; // (this statement is equivalent to &#39;Foo bar&#39;, above) The new operator creates an instance of a class, in this case Foo. The @=&gt; operator performs the reference assignment. (see here for more information on @=&gt;) It is possible to make many references to same object: // make a Foo Foo bar; // reference assign to duh bar @=&gt; Foo @ duh; // (now both bar and duh points to the same object) ChucK objects are reference counted(引用计数) and garbage collection takes place automatically. (note: this is still being implemented!)引用计数，垃圾回收 As stated above(如上所述), a classes may contain data and behavior, in the form of member variables and member functions, respectively. Members are accessed by using 'dot notation' - reference.memberdata and reference.memberfunc(). To invoke(调用) a member function of an object (assuming class Foo has a member function called compute that takes two integers and returns an integer): 12345// make a FooFoo bar;// call compute(), store result in boobar.compute( 1, 2 ) =&gt; int boo; #writing a class If a class has already been defined in the ChucK virtual machine (either in the same file or as a public class in a different file) then it can be instantiated similar to primitive types. Unless declared public, class definitions are scoped to the shred and will not conflict with identically named classes in other running shreds.除非声明是公共的，类的定义作用于该进程，并将不会与在其他运行进程中的命名相同的类发生冲突。 Classes encapsulate(封装) a set of behaviors and data. To define a new object type, the keyword class is used followed by the name of that class. 12345// define class Xclass X&#123; // insert code here&#125; If a class is defined as public, it is integrated(整合) into the central namespace (instead of the local one), and can be instantiated from other programs that are subsequently compiled. 在随后编译的其他程序中，公共类也可以被实例化。 There can be at most one public class per file.(每个文件中至多一个公共类) 1234567891011121314// define public class MissPopularpublic class MissPopular&#123; // ...&#125;// define non-public class Flargclass Flarg&#123; // ...&#125;// both MissPopular and Flarg can be used in this file// only MissPopular can be used from another file We define member data and methods to specify the data types and functionality(数据类型和功能) required of the class. Members, or instance data and instance functions are associated with individual instances of a class, whereas(然而) static data and functions are only associated with the class (and shared by the instances). 成员 或者 实例数据和实例函数，关联各个类实例，而静态数据和函数是关联于类的，各实例共享。 #members (instance data + functions) Instance data and methods are associated with an object. 123456789101112131415161718192021222324252627282930313233343536373839// define class Xclass X&#123; // declare instance variable 'm_foo' int m_foo; // another instance variable 'm_bar' float m_bar; // yet another, this time an object Event m_event; // function that returns value of m_foo fun int getFoo() &#123; return m_foo; &#125; // function to set the value of m_foo fun void setFoo( int value ) &#123; value =&gt; m_foo; &#125; // calculate something fun float calculate( float x, float y ) &#123; // insert code &#125; // print some stuff fun void print() &#123; &lt;&lt;&lt; m_foo, m_bar, m_event &gt;&gt;&gt;; &#125;&#125;// instantiate an XX x;// set the Foox.setFoo( 5 );// print the Foo&lt;&lt;&lt; x.getFoo() &gt;&gt;&gt;;// call printx.print(); class constructors In the initial release(初始版本), we do not support constructors yet. However, we have a single pre-constructor. The code immediately inside a class definiton(定义) (and not inside any functions) is run every time an instance of that class is created. 类实例化时就自动运行类定义里而不是任何函数里的代码。 123456789101112131415161718192021222324252627// define class Xclass X&#123; // we can put any ChucK statements here as pre-constructor // initialize an instance data 109 =&gt; int m_foo; // loop over stuff for( 0 =&gt; int i; i &lt; 5; i++ ) &#123; // print out message how silly &lt;&lt;&lt; "part of class pre-constructor...", this, i &gt;&gt;&gt;; &#125; // function fun void doit() &#123; // ... &#125;&#125;// when we instantiate X, the pre-constructor is runX x;// print out m_foo&lt;&lt;&lt; x.m_foo &gt;&gt;&gt;; #static (data + functions) Static data and functions are associated with a class, and are shared by all instances of that class -- in fact, static elements can be accessed without an instance, by using the name of the class: Classname.element. 123456789101112131415161718192021222324252627282930313233// define class Xclass X&#123; // static data static int our_data; // static function fun static int doThatThing() &#123; // return the data return our_data; &#125;&#125;// do not need an instance to access our_data2 =&gt; X.our_data;// print out&lt;&lt;&lt; X.our_data &gt;&gt;&gt;;// print&lt;&lt;&lt; X.doThatThing() &gt;&gt;&gt;;// create instances of XX x1;X x2;// print out their static data - should be same&lt;&lt;&lt; x1.our_data, x2.our_data &gt;&gt;&gt;;// change use one5 =&gt; x1.our_data;// the other should be changed as well&lt;&lt;&lt; x1.our_data, x2.our_data &gt;&gt;&gt;; 静态数据是同一块内存 #inheritance Inheritance in object-oriented(面向对象的) code allows the programmer to take an existing class to extend(扩展) or alter(改变) its functionality. In doing so we can create a taxonomy(分类法) of classes that all share a specific(特定的) set of behaviors(行为), while implementing(实施) those behaviors in different, yet well-defined(定义明确的), ways. We indicate(表明) that a new class inherits(继承) from another class using the extends keyword. The class from which we inherit(继承) is referred to as the parent class, and the inheriting class is the child class. The Child class receives all of the member data and functions from the parent class, although functions from the parent class may be overridden(重写) ( below ). Because the children contain the functionality(功能) of the parent class, references to instances(实例) of a child class may be assigned(分配) to a parent class reference type. For now, access modifiers(存取修改器) (public, protected, private) are included but not fully implemented. Everything is public by default. 12345678910111213141516171819202122232425262728293031323334353637383940// define class Xclass X&#123; // define member function fun void doThatThing() &#123; &lt;&lt;&lt;"Hallo"&gt;&gt;&gt;; &#125; // define another fun void hey() &#123; &lt;&lt;&lt;"Hey!!!"&gt;&gt;&gt;; &#125; // data int the_data;&#125;// define child class Yclass Y extends X&#123; // override doThatThing() fun void doThatThing() &#123; &lt;&lt;&lt;"No! Get away from me!"&gt;&gt;&gt;; &#125;&#125;// instantiate a YY y;// call doThatThingy.doThatThing();// call hey() - should use X's hey(), since we didn't overridey.hey();// data is also inherited from X&lt;&lt;&lt; y.the_data &gt;&gt;&gt;; Inheritance provides us a way of efficiently sharing code between classes which perform similar roles. We can define a particular complex pattern of behavior, while changing the way that certain aspects of the behavior operate. 1234567891011121314151617181920212223242526272829303132333435363738394041// parent class defines some basic data and methods class Xfunc&#123; int x; fun int doSomething( int a, int b ) &#123; return 0; &#125;&#125;// child class, which overrides the doSomething function with an addition operationclass Xadds extends Xfunc&#123; fun int doSomething ( int a, int b ) &#123; return a + b ; &#125;&#125;// child class, which overrides the doSomething function with a multiply operation class Xmuls extends Xfunc&#123; fun int doSomething ( int a, int b ) &#123; return a * b; &#125;&#125;// array of references to XfuncXfunc @ operators[2];// instantiate two children and assign reference to the array new Xadds @=&gt; operators[0];new Xmuls @=&gt; operators[1];// loop over the Xfuncfor( 0 =&gt; int i; i &lt; operators.cap(); i++ )&#123; // doSomething, potentially different for each Xfunc &lt;&lt;&lt; operators[i].doSomething( 4, 5 ) &gt;&gt;&gt;;&#125; because Xmuls and Xadds each redefine(重新定义) doSomething( int a, int b ) with their own code, we say that they have overridden(重写) the behavior of the parent class. They observe the same interface, but have potentially different implementation. This is known as polymorphism(多态性). #Overloading Function overloading in classes is similar to that of regular functions. see functions.]]></content>
      <categories>
        <category>编程与生活</category>
      </categories>
      <tags>
        <tag>ChucK</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[chuck11]]></title>
    <url>%2Flangs%2Fchuck%2Fchuck11%2F</url>
    <content type="text"><![CDATA[unit generators(单元发生器) declaring connecting controlling (timing mechanism) mono + stereo creating (coming soon) #Unit Generators Unit Generators are function generators that output(输出) signals that can be used as audio or control signals. However, in ChucK, there is no fixed control rate. Any unit generator may be controlled at any rate. Using the timing mechanism(机制), you can program your own control rate, and can dynamically(动态地) vary(变化) the control over time. Using concurrency(并发性), it is possible to have many different parallel(平行的) controls rates, each at any granularity(间隔尺寸). Some more quick facts about ChucK unit generators All ChucK unit generators are objects (not primitive(原始的) types).是对象，非原始类型 All ChucK unit generators inherit(继承) from the UGen class.继承自UGen类 The operation foo =&gt; bar, where foo and bar are UGen's, connects foo to bar. Unit generators are controlled by calling/chucking to member functions over time.通过随时间唤起成员函数而控制单元发生器 All unit generators have the functions gain, op, channels, chan, and last. (see below) Three default, global unit generators are provided. They are adc, dac, and blackhole. (see below) Unit generators are specially integrated(集合) into the virtual machine such that audio is computed for every sample(取样) as time is advanced(随时间被推进). Via the timing mechanism(机制), we have the ability to assert(维护) control over the audio generate process at any point in time and at any desired control rate. View a list of ChucK's built-in(嵌入的) unit generator classes View sample code for unit generators #declaring Unit generators (UGens) are objects, and need to be instantiated before they can be used(在使用前需要被实例化). We declare unit generators the same way we declare objects. // instantiate a SinOsc, assign reference to variable s SinOsc s; #connecting The ChucK operator (=&gt;) is specially overloaded for unit generators: ChucKing one UGen to another connects their respective(分别的) output(s) and input(s). // instantiate a SinOsc, connect its output to dac&#39;s input SinOsc s =&gt; dac; It is also possible to linearly(线性地) chain many UGens together in a single statement.在一个单独声明中，线性连接许多单元发生器 // connect SinOsc to Gain to reverb(混响) to dac SinOsc s =&gt; Gain g =&gt; JCRev r =&gt; dac; Furthermore(此外), it is possible to introduce feedback(反馈) in the network.网络中可以引入反馈 // connect adc to Gain(增益) to delayline(延迟线) to dac; (feedforward(正反馈)) adc =&gt; Gain g1 =&gt; DelayL d =&gt; dac; // adc to Gain to dac (feedforward) adc =&gt; Gain g2 =&gt; dac; // our delayline to Gain back to itself (feedback) d =&gt; Gain g3 =&gt; d; UGens may be dynamically(动态地) connected in this fashion(以这种方式) into an audio synthesis network(音频合成网络). It is essential to note that the above only connects the unit generators, but does not actually generate(形成) audio - unless time is advanced. (see manipulating time and using events)要注意上面只是链接了单元发生器，并未形成音频，除非时间被推进 // connect SinOsc to dac SinOsc s =&gt; dac; // set initial frequency (see next section) 440 =&gt; s.freq; // advance time; allow audio to compute 1::second =&gt; now; It is also possible to dynamically disconnect(断开) unit generators, using the UnChucK operator (=&lt; or !=&gt;): 1234567891011121314151617// connect SinOsc to dacSinOsc s =&gt; dac;// let time pass for 1 second letting audio be computed for that amount of time1::second =&gt; now;// disconnect s from the dacs =&lt; dac;// let time pass for another second - should hear silence1::second =&gt; now;// duh, connect them agains =&gt; dac;// let time pass...1::second =&gt; now; #controlling (over time) In ChucK, parameters(参数) of unit generators may be controlled and altered at any point in time and at any control rate. We only have to move through time and assert(维护) the control at appropriate(适当的) points in time, by setting various parameters on the unit generator. 通过在单元发生器设定各种各样的参数 To set the a value for a parameter of a unit generator, a value of the proper type should be ChucKed to the corresponding control fucntion. 为了设定一个单元发生器的参数值，一个合适的类型的值应该被ChucK到相应的控制函数上。 // connect SinOsc to dac SinOsc s =&gt; dac; // set initial frequency to 440 hz 440 =&gt; s.freq; // let time pass for 1 second 1::second =&gt; now; // change the frequency to 880 hz 880 =&gt; s.freq; Since the control functions are member functions of the unit generator, 控制函数就是单元发生器的成员函数 the above syntax(语法) is equivalent to calling functions(等价于调用函数). // connect SinOsc to dac SinOsc s =&gt; dac; // set frequency to 440 s.freq( 440 ); // let time pass 1::second =&gt; now; For a list of unit generators and their control methods, consult(查阅) UGen reference. To read the current value of certain parameters(参数) (not all parameters can be read), we may call an overloaded function of the same name. 为了读取某个参数的当前值，需要调用一个同名的重载函数 // connect SinOsc to dac SinOsc s =&gt; dac; // store the current value of the freq s.freq() =&gt; float the_freq; You can chain assignments(分配) together when you want to assign(分配) one value to multiple targets. Note that the parentheses(括号) are only needed when the read function is on the very left. 只有当读函数位于最左边时，才需要括号 // SinOsc to dac SinOsc foo =&gt; dac; // triosc to dac triosc bar =&gt; dac; // set frequency of foo and then bar 500 =&gt; foo.freq =&gt; bar.freq; // set one freq to the other foo.freq() =&gt; bar.freq; // the above is same as: bar.freq( foo.freq() ); Of course, varying(不同的) parameters over time is often more interesting.不同参数随时间推移是很有趣的。 // SinOsc to dac SinOsc s =&gt; dac; // infinite time loop while( true ) { // set the frequency ( s.freq() + 200 ) % 5000 =&gt; s.freq; // advance time 100::ms =&gt; now; } All ugen's have at least the following three control parameters: 以下参数至少有三个 gain(float) (of type float): set/get the gain of the UGen's output(输出).设置或获取单元发生器输出的增益 last() (of type float): get the last sample computed by the UGen. if UGen has more than one channel, the average of all components(成分) channels are returned. 得到被单元发生器计算的最后的样本，如果单元发生器有不止一个通道，则返回所有通道的平均值。 channels() (of type int): get the number of channels in the UGen.获取单元发生器的通道数 chan(int) (of type UGen): return reference to nth channel (or null if no such channel).返回第几个通道引用，没有的话就返回null op(int) (of type int): set/get operation at the UGen. 设定或获取单元发生器的操作 Values: 0 : stop - always output 0 1 : normal operation, add all inputs (default) 2 : normal operation, subtract(减去) inputs starting from the earliest connected减去从最早的链接开始的输入(不甚理解？？？) 3 : normal operation, multiply(乘以) all inputs 4 : normal operation, divide inputs starting from the earlist connected -1 : passthru - all inputs to the ugen are summed and passed directly to output所有单元生成器的输入被加在一起并且直接传递到输出 #mono + stereo(单声道立体声) ChucK supports stereo(立体声) (default) and multi-channel audio (see command line options to select interfaces(界面) and number of channels). The dac and the adc are now multi-channel UGens. By default, ChucKing two UGens containing the same number of channels (e.g. both stereo(立体声) or both mono(单声道放音)) automatically(自动地) matches the output(输出) channels with the input(输入) channels (e.g. left to left, right to right for stereo). Stereo UGens mix their output channels when connecting to mono UGens. Mono UGens split their output channels when connecting to stereo UGens. Stereo UGens contain the parameters(参数) .left and .right, which allow access(访问) to the individual(个人的) channels. // adding separate reverb(混响) to left and right channels adc.left =&gt; JCRev rl =&gt; dac.left; adc.right =&gt; JCRev rr =&gt; dac.right; The pan2 stereo object takes a mono signal and split it to a stereo signal, with control over the panning. The pan position may be changed with the .pan parameter (-1 (hard left) &lt;= p &lt;= 1 (hard right)范围是固定的) pan2立体声对象将单声道分离成立体声，通过控制panning(平移？)，平移位置可能被用.pan参数改变。 // white noise to pan to dac noise n =&gt; pan2 p =&gt; dac; // infinite time loop while( true ) { // modulate(调整) the pan Math.sin( now / 1::second * 2 * pi ) =&gt; p.pan; // advance time 10::ms =&gt; now; } #creating ( coming soon! ) #built-in unit generators ChucK has a number of built-in(嵌入的) UGen classes, included most of the Synthesis ToolKit (STK). A list of built-in ChucK unit generators can be found here(url:.../ugen.html).]]></content>
      <categories>
        <category>编程与生活</category>
      </categories>
      <tags>
        <tag>ChucK</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[chuck6]]></title>
    <url>%2Flangs%2Fchuck%2Fchuck6%2F</url>
    <content type="text"><![CDATA[control structures if / else while &amp; do...while... until for break / continue #Control Structures ChucK includes standard control structures similar to those in most programming languages. A condition (of type 'int') is evaluated and then a proceeding block is potentially executed. Blocks are separated either by semicolons(分号) or by curly brackets(花括号). #if / else The if statement executes a block if the condition is evaluated as non-zero. 1234if( condition )&#123; // insert code here&#125; In the above code, condition is any expression that evaluates to an int. (条件是一个值为整数的表达式) The else statement(声明) can be put after the if block to handle the case where the condition evaluates(求值) to 0. 12345678if( condition )&#123; // your code here&#125;else&#123; // your other code here&#125; If statements can be nested(嵌套). #while &amp; do...while... 123456789// here is an infinite loopwhile( true )&#123; // your code loops forever! // (sometimes this is desirable because we can create // infinite time loops this way, and because we have // concurrency)&#125; 123do &#123; // your code executes here at least once&#125; while( condition ); A few more points: while statements can be nested. see break/continue for additional(附加的) control over your loops #until The until statement is the opposite of while, semantically(语义地). A until loop repeatedly executes the body until the condition evaluates as non-zero. 12345// an infinite loopuntil( false )&#123; // your great code loops forever!&#125; A few more points: while statements can be nested. see break/continue for additional(附加的) control over your loops #for A loop that iterates(迭代) a given number of times.(迭代给定次数) A temporary(暂时的) variable(变量) is declared that keeps track(跟踪) of the current index and is evaluated and incremented at each iteration(迭代). 123456// for loopfor( 0 =&gt; int foo; foo &lt; 4 ; foo++ )&#123; // debug-print value of 'foo' &lt;&lt;&lt;foo&gt;&gt;&gt;;&#125; #break / continue Break allows the program flow to jump out of a loop. 123456// infinite loopwhile( 1 )&#123; if( condition ) break;&#125; Continue allows a loop to continue looping but not to execute(实行) the rest of the block for the iteration where continue was executed.(跳过当前的循环) 123456789// another infinite loopwhile( 1 )&#123; // check condition if( condition ) continue; // some great code that may get skipped (if continue is taken)&#125;]]></content>
      <categories>
        <category>编程与生活</category>
      </categories>
      <tags>
        <tag>ChucK</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[chuck13]]></title>
    <url>%2Flangs%2Fchuck%2Fchuck13%2F</url>
    <content type="text"><![CDATA[Events In addition to the built-in(嵌入的) timing mechanisms(机制) for internal(内部的) control, ChucK has an event class to allow exact synchronization(精确同步) across an arbitrary(任意的) number of shreds. 事件类允许在任意的进程间实现精确同步 View sample code for events what they are ChucK events are a native class(原始类) within the ChucK language. We can create an event objects, and then chuck (=&gt;) that event to now. The event places the current shred on the event's waiting list, suspends(暂停) the current shred (letting time advance from that shred's point of view). 时间放置在当前进程的事件的等待列表里，暂停当前进程(从时间的观测点推进时间) When the event is triggered(引发), one or more of the shreds on its waiting list is shreduled to run immediately. 时间被引发时，在进程的等待列表里调用运行 This trigger(触发器) may originate(引起) from another ChucK shred, or from activities taking place outside the Virtual Machine ( MIDI, OSC, or IPC ). 12345678910111213141516171819202122232425262728293031323334353637383940// declare eventEvent e;// function for shredfun void eventshred( Event event, string msg )&#123; // infinite loop while ( true ) &#123; // wait on event event =&gt; now; // print &lt;&lt;&lt;msg&gt;&gt;&gt;; &#125;&#125;// create shredsspork ~ eventshred ( e, "fee" );spork ~ eventshred ( e, "fi" );spork ~ eventshred ( e, "fo" );spork ~ eventshred ( e, "fum" );// infinite time loopwhile ( true )&#123; // either signal or broadcast(信号或广播) if( maybe ) &#123; &lt;&lt;&lt;"signaling..."&gt;&gt;&gt;; e.signal(); &#125; else &#123; &lt;&lt;&lt;"broadcasting..."&gt;&gt;&gt;; e.broadcast(); &#125; // advance time 0.5::second =&gt; now;&#125; use Chucking an event to now suspends the current shred, letting time advance: 12345678910// declare EventEvent e;// ...// wait on the evente =&gt; now;// after the event is trigger&lt;&lt;&lt; "I just woke up" &gt;&gt;&gt;; as shown above, events can be triggered in two ways, depending on the desired behavior(行为). 12// signal one shred waiting on the event ee.signal(); signal() releases the first shred in that event's queue, and shredule it to run at the current time, respecting(考虑) the order in which shreds were added to the queue. 12// wake up all shreds waiting on the event ee.broadcast(); broadcast() releases all shreds queued by that event, in the order they were added, and at the same instant in time(在同一瞬间). The released shreds are shreduled to run immediately. But of course they will respect(涉及) other shreds also shreduled to run at the same time. Furthermore(此外), the shred that called signal() or broadcast() will continue to run until it advances time itself, or yield the virtual(虚拟的) machine without advancing time. (see me.yield() under concurrency) MIDI events ChucK contains built-in(嵌入的) MIDI classes to allow for interaction(相互作用) with MIDI based software or devices(装置). 1234567891011121314151617181920MidiIn min;MidiMsg msg;// open midi receiver, exit on failif ( !min.open(0) ) me.exit(); while( true )&#123; // wait on midi event min =&gt; now; // receive midimsg(s) while( min.recv( msg ) ) &#123; // print content &lt;&lt;&lt; msg.data1, msg.data2, msg.data3 &gt;&gt;&gt;; &#125;&#125;... MidiIn is a subclass(子类) of Event, and as such can be ChucKed to now. MidiIn then takes a MidiMsg object to its .recv() method to access the MIDI data. As a default, MidiIn events trigger(引发) the broadcast() event behavior. OSC events In addition to MIDI, ChucK has OSC communication classes as well: 12345678910111213141516171819202122232425262728293031...// create our OSC receiverOscRecv orec;// port 64496449 =&gt; orec.port;// start listening (launch thread)orec.listen();function void rate_control_shred()&#123; // create an address in the receiver // and store it in a new variable. orec.event("/sndbuf/buf/rate,f") @=&gt; OscEvent rate_event; while ( true ) &#123; rate_event =&gt; now; // wait for events to arrive. // grab the next message from the queue. while( rate_event.nextMsg() != 0 ) &#123; // getFloat fetches the expected float // as indicated in the type string ",f" buf.play( rate_event.getFloat() ); 0 =&gt; buf.pos; &#125; &#125; &#125;... The OscRecv class listens for incoming OSC packets on the specified(特定的) port. Each instance(实例) of OscRecv can create OscEvent objects using its event() method to listen for packets at any valid OSC Address pattern.(在任何合法的OSC地址模式，使用事件方法来监听数据包) An OscEvent object can then be ChucKed to now to wait for messages to arrive, after which the nextMsg() and get{Float|String|Int}() methods can be used to fetch message data. creating custom events Events, like any other class, can be subclassed to add functionality(功能) and transmit(传输) data: 123456789101112131415161718192021222324252627282930313233343536373839// extended event扩充事件class TheEvent extends Event&#123; int value;&#125;// the eventTheEvent e;// handlerfun int hi( TheEvent event )&#123; while( true ) &#123; // wait on event event =&gt; now; // get the data &lt;&lt;&lt;e.value&gt;&gt;&gt;; &#125;&#125;// sporkspork ~ hi( e );spork ~ hi( e );spork ~ hi( e );spork ~ hi( e );// infinite time loopwhile( true )&#123; // advance time 1::second =&gt; now; // set data Math.rand2( 0, 5 ) =&gt; e.value; // signal one waiting shred e.signal();&#125;]]></content>
      <categories>
        <category>编程与生活</category>
      </categories>
      <tags>
        <tag>ChucK</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[chuck2]]></title>
    <url>%2Flangs%2Fchuck%2Fchuck2%2F</url>
    <content type="text"><![CDATA[#Overview ChucK is a strongly-typed, strongly-timed, concurrent(并发的) audio and multimedia(多媒体的) programming language. It is compiled(编译) into virtual(虚拟的) instructions, which is immediately run in the ChucK Virtual Machine. This guide documents the features(特色) of the Language, Compiler, and Virtual Machine for a ChucK programmer. #running ChucK ...this is a quick overview(综述), see VM options for a more complete guide to command line options. To run ChucK with a program/patch called foo.ck simply run chuck and then the name of the file: chuck foo.ck To run ChucK with multiple patches concurrently(同时发生) (or the same one multiple times): chuck foo.ck bar.ck bar.ck boo.ck ...the following probes(探查) the audio system and prints out all available audio devices and MIDI devices. You may then refer to them (by number usually) from the command line or from your program. (again, see VM Options for a complete list) chuck --probe ChucK can be run in a different terminal as a host/listener that patches may be sent to. The server should invoke(调用) the --loop flag to specify that the virtual machine should not halt(停止) automatically(自动地) (when the current programs exit). chuck --loop (See the guide to On-the-fly Programming for more information) If a ChucK listener is running, we can (from a second terminal) send a program/patch to the listener by using the + command line option: chuck + foo.ck Similarly, you can use - and = to remove/replace a patch in the listener, and use ^ to find out the status. Again, see On-the-fly Programming for more information. To run most of the code or examples in this language specification, you only need to use the basic chuck program. #comments(注释) (Note: block comments cannot be nested(嵌入的)) // this is a comment int foo; // another comment /* this is a block comment still going... */ #debug print(调试输出) ...we have provided a debug print syntax(语法): // prints out value of expression &lt;&lt;&lt; expression &gt;&gt;&gt;; This will print the values and types of any expressions placed within them. This debug print construction may be placed around any non-declaration expression ( non l-value ) and will not affect the execution(执行) of the code. Expressions which represent an object will print the value of that object's reference(引用) address: // assign 5 to a newly declared variable 5 =&gt; int i; // prints &quot;5 : (int)&quot; &lt;&lt;&lt;i&gt;&gt;&gt;; // prints &quot;hello! : (string)&quot; &lt;&lt;&lt;&quot;hello!&quot;&gt;&gt;&gt;; //prints &quot;hello! : (string)&quot; // prints &quot;3.5 : (float)&quot; &lt;&lt;&lt;1.0 + 2.5 &gt;&gt;&gt; =&gt; float x; (ChucK中似乎是没有了print这一类) (Chuck中有;，还是类似C的) For more formatted(格式化) data output(输出), a comma-separated list of expressions will print only their respective(分别的) values (with one space between): //接上段 // prints &quot;the value of x is 3.5&quot; (x from above) &lt;&lt;&lt;&quot;the value of x is&quot; , x &gt;&gt;&gt;; // prints &quot;4 + 5 is 9&quot; &lt;&lt;&lt;&quot;4 + 5 is&quot;, 4 + 5&gt;&gt;&gt;; // prints &quot;here are 3 random numbers ? ? ?&quot; &lt;&lt;&lt;&quot;here are 3 random numbers&quot;, Std.rand2(0,9), Std.rand2(0,9), Std.rand2(0,9) &gt;&gt;&gt;; 输出： C:1&gt;chuck &quot;debug print.ck&quot; 5 :(int) &quot;hello!&quot; : (string) 3.500000 :(float) the value of x is 3.500000 4 + 5 is 9 here are 3 random numbers 1 8 8 #reserved words(关键字) (primitive types原始类型) int float time dur void same (unimplemented未实现的) (control structures) if else while until for repeat break continue return switch (unimplemented) (class keywords) class extends public static pure this super (unimplemented) interface (unimplemented) implements (unimplemented) protected (unimplemented) private (unimplemented) (other chuck keywords) function fun spork const new (special values) now true false maybe null NULL me pi (special : default durations(默认持续时间)) samp ms second minute hour day week (special : global ugens(不理解)) dac adc blackhole]]></content>
      <categories>
        <category>编程与生活</category>
      </categories>
      <tags>
        <tag>ChucK</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[chuck3]]></title>
    <url>%2Flangs%2Fchuck%2Fchuck3%2F</url>
    <content type="text"><![CDATA[#Types, Values, and Variables(变量) ChucK is a strongly-typed language, meaning that types are resolved(决定) at compile-time. However, it is not quite statically-typed, because the compiler/type system is a part of the ChucK virtual(虚拟的) machine, and is a runtime component(成分). This type system helps to impose(强加) precision(精度) and clarity(清楚) in the code, and naturally lends to organization of complex(复杂的) programs. At the same time, it is also dynamic in that changes to the type system can take place (in a well-defined(定义明确的) manner) at runtime. This dynamic(动态的) aspect(方面) forms the basis(基础) for on-the-fly programming. This section deals with types, values, and the declaration(声明) and usage(使用) of variables. As in other strongly-typed programming languages, we can think of a type as associated(关联的) behaviors(行为) of data. (For example, an 'int' is a type that means integer(整数), and adding two integer is defined(定义) to produce a third integer representing the sum.) Classes and objects allow us to extend(延伸) the type system with our own custom types, but we won't cover them in this section. We will focus mainly on primitive(原始的) types here, and leave the discussion of more complex types for classes and objects. #primitive types(原始类型) The primitive(原始的), or intrinsic(本质的) types are those which are simple datatypes (they have no additional(附加的) data attributes(属性)). Objects are not primitive types. Primitive types are passed by value. Primitive types cannot be extended(延伸). The primitive types in ChucK are: int : integer(整数) (signed) float : floating point number (in ChucK, a float is by default double-precision(双精度)) time : ChucKian time dur : ChucKian duration(持续) void : (no type) complex : complex number in rectangular(矩形的) form a + bi (see [below][1]) polar: complex number in polar(极面) form (see [below][1]) For a summary of operations on these types, go to operations and operators. All other types are derived(派生) from 'object', either as part of the ChucK standard library, or as a new class that you create. For specification(规格), go to classes and objects. #values (literals(字面值)) Literal values are specified(指定) explicitly(明确地) in code and are assigned(分配) a type by the compiler(编译器).The following are some examples of literal values: int: 42 int (hexidecimal): 0xaf30 float: 1.323 dur: 5.5::second //In the above code, second is an existing duration(持续) variable(变量). //For more on durations, see the [manipulating time(时间调节)][4] section. #variables Variables(变量) are locations in memory that hold data. Variables have to be declared in ChucK before they are used. For example, to declare a variable of type int called foo: // declare an &#39;int&#39; called &#39;foo&#39; int foo; We can assign(分配) a value to an existing variable by using the ChucK operator (=&gt;). This is one of the most commonly used operators in ChucK, it's the way to do work and take action! (后面会讨论) // assign value of 2 to &#39;foo&#39; 2 =&gt; foo; It is possible to combine the two statements(声明) into one: // assign 2 to a new variable &#39;foo&#39; of type &#39;int&#39; 2 =&gt; int foo; To use a variable, just refer to it by name: // debug-print the value of foo &lt;&lt;&lt; foo &gt;&gt;&gt;; To update the value of foo, for example: // multiply &#39;foo&#39; by 10, assign back to &#39;foo&#39; foo * 10 =&gt; foo; You can also do the above using a *=&gt; (mult-chuck): // multiply &#39;foo&#39; by 10, and then assign to &#39;foo&#39; 10 *=&gt; foo; Here is an example of a duration(持续): // assign value of &#39;5 seconds&#39; to new variable bar 5::second =&gt; dur bar; Once you have bar, you can inductively(归纳的) use it to construct new durations: // 4 bar, a measure? 4::bar =&gt; dur measure; 输出： C:1&gt;chuck test.ck 882000.000000 :(dur) Since time is central to programming ChucK, it is important to understand time, dur, the relationship and operations between them. There is more information in the manipulating time section. #reference types(引用类型) Reference(参考) types are types which inherit(继承) from the object class. Some default reference types include: Object : base type that all classes inherit from (directly or indirectly)所有类继承的基本类型 array : N-dimensional ordered(有序的) set of data (of the same type) Event : fundamental(基本的), extendable(可扩展的), synchronization(同步) mechanism(机制) UGen : extendable unit generator(单元发生器) base class (U = unit, Gen = generator) string : string (of characters) New classes can be created. All classes are reference types. We will leave the full discussion to the objects and classes section. #complex types (虚数：直角坐标系，极坐标系) Two special primitive types are available to to represent complex (复杂的)data, such as the output (输出)of an FFT: complex and polar. A complex number of the form a + bi can be declared as #(2,3) =&gt; complex cmp; //cmp is now 2 + 3i where the #(...) syntax(语法) explicitly(明确地) denotes(表示) a complex number in rectangular form(矩形). Similarly, explicit complex numbers can be manipulated(操纵) directly: #(5, -1.5) =&gt; complex cmp; // cmp is 5 - 1.5i #(2,3) + #(5,6) + cmp =&gt; complex sum; // sum is now 12 + 7.5i The (floating point) real and imaginary parts(实虚部) of a complex number can be accessed(存取) with the .re and .im components of a complex number: #(2.0,3.5) =&gt; complex cmp; cmp.re =&gt; float x; // x is 2.0 cmp.im =&gt; float y; //y is 3.5 The polar type(极坐标) offers an equivalent(等价的), alternative(供选择的) representation(表示) of complex numbers in terms of a magnitude(大小) and phase(相) value. A polar representation of a complex number can be declared as %(2, .5*pi) =&gt; polar pol; // pol is 2∠.5π(没有想到，竟然有这个(●&#39;◡&#39;●)) The magnitude(大小) and phase(相) values can be accessed via .mag and .phase: %(2, .5*pi) =&gt; polar pol; pol.mag =&gt; float m; // m is 2 pol.phase =&gt; float p; //p is .5π polar and complex representations(代表) can be cast to each other and multiplied/added/assigned(分配)/etc.: %(2, .5*pi) =&gt; polar pol; #(3, 4) =&gt; complex cmp; pol $ complex + #(10, 3) + cmp =&gt; complex cmp2; cmp $ polar + %(10, .25*pi) - pol =&gt; polar pol2; (这里的$实现了两种坐标系下表示的转换) &gt;输出： C:1&gt;chuck test.ck %(2.0000,0.5000pi) :(polar) #(3.0000,4.0000) :(complex) #(13.0000,9.0000) :(complex) %(13.5540,0.2334pi) :(polar)]]></content>
      <categories>
        <category>编程与生活</category>
      </categories>
      <tags>
        <tag>ChucK</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++基础5]]></title>
    <url>%2Flangs%2Fcpp%2FCpp%E5%9F%BA%E7%A1%80_5%2F</url>
    <content type="text"><![CDATA[程序文件拆分 函数总是申明在前，调用在后，拆分的程序文件中也要遵循这样的规则，所以，在拆分文件中才需要在多处申明函数。 头文件 包含头文件，就是将那些函数声明做成一个.h文件，用指令#include来将他们加在程序文件的开始处 1234567891011//===========================================//abc.h//=========================================== void f1(); void f2(); void f3(); void g1(); void g2(); void p(); void h();//=========================================== 然后在每个程序文件的开端包含它，这对于所要使用的函，就无需再次声明了 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758//===========================================//a1.cpp//=========================================== #include "abc.h" void f1(...) &#123; if(...) &#123; p(); g1(); &#125; else &#123; g2(); h(); &#125; &#125; //============================================ //a2.cpp //============================================ #include "abc.h" int main() &#123; f1(); f2(); f3(); &#125; void f3() &#123; f1(); &#125; void p() &#123; f3(); &#125; //============================================= //a3.cpp //=============================================4#include "abc.h" void h() &#123; ... &#125; viod f2() &#123; g1(); g2(); &#125; void g1() &#123; ... &#125; void g2() &#123; ... &#125; 界面头文件 头文件更重要的作用是在设计阶段（相较于编程阶段）规定界面，也就是通过头文件可以明白的看出，某个程序文件提供了什么服务，这种文件称为用户界面， 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980//a1.h4void f1();//a2.h4void p();//a3.h4void g1();4void g2();4void f2();4void h();通过使用用户界面的形式，上面呢三个文件就可以这样表达：//==============================================//a1.cpp//==============================================4#include "a2.h"4#include "a3.h"44void f1() &#123;44if()44&#123;&#125;44else44&#123;&#125;4&#125;4//==============================================//a2.cpp//============================================== 4#include "a1.h"4#include "a3.h"4static void f3();44int main() &#123;44f1();44f2();44f3();4&#125;4void f3() &#123; f1();4&#125;4void p() &#123; f3(); &#125; //===============================================//a3.h//===============================================4#include "a3.h"44void h() &#123;&#125;4void f3() &#123; g1(); g2();4&#125;4void g1() &#123;&#125;4void g2() &#123;&#125;//===============================================3. 头文件内容//===============================================//header.h//===============================================4extern int n;4extern int a[];4void fn();4class A;4const float pi = 3.14;4inline void fn()&#123;&#125;;4template&lt;class T&gt; class A&#123;&#125;;4namespace N&#123;&#125;4enum COLOR&#123;&#125;;4class A&#123;&#125;;4#include &lt;iostream&gt;4// 2016年7月23日22:33:54//=============================================== 由于头文件可能出现在一个程序的若干个源程序文件中，所以将一些实体定义放在文件中是不明智的，因为一种定义体在一个程序中只能出现一次 全局数据区的整个区域在程序启动时，初始化为零。]]></content>
      <categories>
        <category>编程与生活</category>
      </categories>
      <tags>
        <tag>C++&amp;C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++基础4]]></title>
    <url>%2Flangs%2Fcpp%2FCpp%E5%9F%BA%E7%A1%80_4%2F</url>
    <content type="text"><![CDATA[//程序文件拆分 函数总是申明在前，调用在后，拆分的程序文件中也要遵循这样的规则，所以，在拆分文件中才需要在多处申明函数。 0. 头文件 包含头文件，就是将那些函数声明做成一个.h文件，用指令#include来将他们加在程序文件的开始处 //=========================================== //abc.h //=========================================== void f1(); void f2(); void f3(); void g1(); void g2(); void p(); void h(); //=========================================== 然后在每个程序文件的开端包含它，这对于所要使用的函，就无需再次声明了 //=========================================== //a1.cpp //=========================================== #include &quot;abc.h&quot; void f1(...) { if(...) { p(); g1(); } else { g2(); h(); } } //============================================ //a2.cpp //============================================ #include &quot;abc.h&quot; int main() { f1(); f2(); f3(); } void f3() { f1(); } void p() { f3(); } //============================================= //a3.cpp //============================================= #include &quot;abc.h&quot; void h() { ... } viod f2() { g1(); g2(); } void g1() { ... } void g2() { ... } 界面头文件]]></content>
      <categories>
        <category>编程与生活</category>
      </categories>
      <tags>
        <tag>C++&amp;C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++基础3]]></title>
    <url>%2Flangs%2Fcpp%2FCpp%E5%9F%BA%E7%A1%80_3%2F</url>
    <content type="text"><![CDATA[未初始化的数组的内容是未定义的，且其末尾的空字符是不确定的，有可能在限定字节外。 未初始化的 string 对象长度自动设定为0。 wchar_t, char16_t, char32_t 三种字符串 wchar_t title[] = L&quot;Chief Astrogator&quot;; char16_t name[] = u&quot;Felonia Ripova&quot;; char32_t car[] = U&quot;Humber Super Snipe&quot;; 原始(raw)字符串 cout &lt;&lt; R&quot;(l&quot;s&quot; / ; &quot; &quot;&quot; lafjlj.)&quot; &lt;&lt; endl; 原样输出； 上面的方式有不足，会把第一个 ' )&quot; ' 认为是字符串到此结尾； cout &lt;&lt; R&quot;+(&quot;(dkshfk)&quot;), jsfjldsjf.)+&quot; &lt;&lt; endl; 输入时会忽视特殊字符的特殊用途，回车会被添加到原始字符串中； 可以使用 Ru UR 等配合wchar_t 等类型的原始字符串； 结构 C: struct inflatable goose; C++: inflatable vincent; *访问类成员函数的点号方式即使从访问结构成员变量的方式衍生而来； -------------------------- struct test { std::string name; flaot volume; double price; }; struct inflatable { char name[20]; float colume; double prince; }; int main() { inflatable guest = { &quot;lasfj&quot;, 1.88, 29.99 }; inflatable pal1 = {&quot;sakdfh&quot;, 2.5, 3.0}; inflatable pal2 {&quot;sakdfh&quot;, 2.5, 3.0}; inflatable pal3 {};//全部字节置零**不允许格式上的缩窄转换； ... return 0; } --------------------- (the same struct) choice = bouquet; --------------------- struct perks { int sdlkfj; double skdf; char a[20]; } mr_dlasjfl = { 7, 23.0, &quot;dsafhk&quot; };//分开写的话可能更便于阅读； -------------------- struct { int x; int y; } position; //只有position这一个这种类型的结构，后面也将无法创建； -------------------- struct widget { char brand[20]; int type; union id { long id_num; char id_char[20]; } id_val; }; widget prize; cin &gt;&gt; prize.id_val.id_char; ----------------------- struct widget { char brand[20]; int type; union//匿名共用体(anonymous union) { long id_num; char id_char[20]; } id_val; }; widget prize; cin &gt;&gt; prize.id_char; enum 枚举类型 可用于设置符号常量，枚举量(enumerator)； enum {a, b, c, d}//0,1,2,3 枚举只定义了赋值运算符，没有定义算术运算； 指针使用是一定要先确定地址； int* pt; pt = (int*) 0xB8000000//地址； new 运算符 指针的真正用武之地在于在运行阶段分配未命名的内存以存储值； C中可以使用库函数malloc()来分配； C++中可以使用new运算符； 传统通过内存名称来访问该 int： int higgens; int* pt = &amp;higgens; 新方式： int* pn = new int; //此处pn指向的是内存是没有名称的，可以说指向一个数据对象，指的是为数据项分配的内存块； delete 运算符 使得用完的内存归还内存池； 与 new 搭配使用。 int* ps = new int; delete ps; //仅仅释放ps所指向的内存； 一定要配对使用 new 与 delete,否则会发生内存泄漏(memory leak)，也就是说，被分配的内存再也无法使用。 如果泄露严重，则程序会不断寻找更多内存而中止。 int ps = new int; delete ps; delete ps;//已释放的内存块再进行释放操作，这样的出的结果是不确定的，意味着什么都会发生，但是对于空指针而言则是安全的 int jugs = 5; int* pi = %jugs; delete pi;//delete只能用来释放由new分配的内存。]]></content>
      <categories>
        <category>编程与生活</category>
      </categories>
      <tags>
        <tag>C++&amp;C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++基础2]]></title>
    <url>%2Flangs%2Fcpp%2FCpp%E5%9F%BA%E7%A1%80_2%2F</url>
    <content type="text"><![CDATA[有效的下标值 int a[10]; a[10] = 10; 数组初始化 只有定义数组时才可以初始化； int a[2] = {1,2}; 可以用下标分别给数字元素初始化； int a[2]; a[0] = 1; a[1] = 2; 部分初始化时，未言明部分自动初始化为零； //将数组整体初始化为零，可以显示的将数组第一个元素初始化为零即可 //int a[5] = {0}; 可以不明确指定数组元素数目； int a[] = {1,2,3}; int num_elements = sizeof things / sizeof ( int); 初始化时可以省略&quot;=&quot;; int a[2] {1,2}; //大括号内可以空白，全部元素置零； //int a[2] {}; //列表示初始化是不允许缩窄的，要保证数据无误； //int a[] = {1,3.4}; C-风格字符串 以空白符结尾，'\0'，ascii = 0； int a[2] = {'a', 'b'}; //不是字符串 int a[2] = {'a', '\0'}; //是字符串 //字符串常量(string constant)或字符串字面值(string literal); char a[10] = &quot;god is girl&quot;; char a[] = &quot;god is girl&quot;; //C++对字符串长度无限制； 带引号的字符串 cout &lt;&lt; “sdlfjl&quot; &quot;sldfjlj&quot; &lt;&lt; endl;//可以在中间处隔行； cout &lt;&lt; “sdlfjlsldfjlj&quot; &lt;&lt; endl; strlen()与sizeof(); （老式实现为string.h） 提供了很多关于字符串相关的其他函数的声明； strlen();//只计算可见的字符数 sizeof();//算出整个数组的长度 ==&gt;&gt;int a[strlen(strings) + 1]; cin小缺陷 cout &lt;&lt; &quot;Your name&quot; &lt;&lt; endl; char name[10]; cin &gt;&gt; name; //输入&quot;Lart Pang&quot;; cout &lt;&lt; &quot;Your university&quot; &lt;&lt; endl; char u_name[10]; //想要输DUT； cin &gt;&gt; u_name; ... //结果，name[10] == &quot;Lart&quot;; //u_name[10] == &quot;Pang&quot;; ==&gt;&gt; //cin 使用空白（空格，制表，换行符）来确定字符串结尾 //此处，name中被放入Lart，之后的Pang仍在输入队列中，被存到了u_name中； 读取行输入 getline();//到 '', 然后停止读取并删掉 ''； get();// 不删； cin.getline(name, 20); //name为要存储输入行的数组名； //20为要读取的字符数； //一行最多读取19个字符； //在存储字符串时用空字符替换换行符； cin.getline(name, 20).getline(u_name. 20); //连续读入两行； cin.get(name, 20); 由于在第一次cin.get();读完后，输入队列中还存在换行符，所以紧跟在其后的另一个cin.get();可能会直接吃掉换行符； 所以可以使用下面的两种方法来解决： cin.get(name, 20); cin.get(); cin.get(u_name, 20); --------------------- cin.get(name, 20).get();//cin会返回一个cin对象； cin.get(u_name, 20); --------------------- (cin &gt;&gt; name).get();//cin后也会残留''； ==&gt;&gt; get(),getline()的性质上的差异，使得两者有了一些奇特的作用，getline()使用起来明显方便，但是get()的特性使得操作者，可以明确读取停止的原因，是因为数组填满还是读完了一整行； --------------------- 稍微特别用法： getline(cin ,str); 将数据读入到string对象中； 这里的getline不是类方法； string类 using namesapce std; string str1; string str2 = &quot;asd&quot;; //string str2 = {&quot;asd&quot;}; //string str2 {&quot;asd&quot;}; cin &gt;&gt; str1; cout &lt;&lt; str1 &lt;&lt; str2[2] &lt;&lt; str2 &lt;&lt; str1[2] &lt;&lt; endl; //string对象和字符数组之间主要区别，可以讲string对象声明为简单变量而不是数组； //string对象能在初始化时自动调节大小； string简单操作 string str3; str3 = str1 + str2; str3 = str1; str1 += str2;//字符串拼接； int len1 = str1.size(); //str1是string类中的一个对象，而size()是string类的一个方法。 //方法是一个函数，只能通过其所属的类的对象进行调用； //C++中的类，对象，方法 //C函数使用参数来确定要使用那个字符串，而C++string类对象，是使用对象名和句点运算符来指出要使用那个字符串； int len2 = strlen(str1);]]></content>
      <categories>
        <category>编程与生活</category>
      </categories>
      <tags>
        <tag>C++&amp;C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++基础1]]></title>
    <url>%2Flangs%2Fcpp%2FCpp%E5%9F%BA%E7%A1%80_1%2F</url>
    <content type="text"><![CDATA[OOP的本质就是设计并扩展自己的数据类型。 变量名命名时，以两个下划线或下划线和大写字母打头的名称被保留给实现（编译器及其使用的资源）使用，以一个下划线开头的名称被保留给，实现，用作全局标识符。 C++中对于名称长度没有限制，但是有些平台有长度限制。 C++赋值方式： （大括号初始化器，适用于任何类型，等号可有可无） int x = 1; int x = {1};//将大括号初始化器用于单变量 int x{1}； int x{};//置零 int x = {1}；//置零 int类型被设定为对于目标计算机而言效率最高的长度。 cout 关于进制转换 std::cout; std::endl; std::hex; std::oct; code: using namespace std; int main() { int chest = 42; int waist = 42; int inseam = 42; cout &lt;&lt; &quot;chest = &quot; &lt;&lt; chest &lt;&lt; &quot; (decimal for 42)&quot; &lt;&lt; endl; cout &lt;&lt; hex; cout &lt;&lt; &quot;waist = &quot; &lt;&lt; waist &lt;&lt; &quot; (hexadecimal for 42)&quot; &lt;&lt; endl; cout &lt;&lt; oct; cout &lt;&lt; &quot;inseam = &quot; &lt;&lt; inseam &lt;&lt; &quot; (octal for 42)&quot; &lt;&lt; endl; return 0; } (cout &lt;&lt; hex;不会显示任何内容，只是会改变cout显示整数的方式。） 数值类型 220L; 220LU == 220UL; 220ll == 220LL; 220ull == 220ULL == 220uLL == 220Ull; (十六进制常用来表示内存地址，而内存地址是没有符号的，所以多用 &quot;usigned int&quot; 类型来表示十六位地址） ‘字符’ “字符串” cout.put();//cout的成员函数 显示一个字符； int main() { char ch = 'M'; int i = ch; cout &lt;&lt; &quot;The ASCII code for &quot; &lt;&lt; ch &lt;&lt; &quot; is &quot; &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; &quot;Add one to the character code:&quot; &lt;&lt; endl; ch = ch + 1; i = ch; cout &lt;&lt; &quot;The ASCII code for &quot; &lt;&lt; ch &lt;&lt; &quot; is &quot; &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; &quot;Displaying char ch using cout.put(ch): &quot;; cout.put(ch) //&lt;&lt; &#39;!&#39;; //cout.put(&#39;!&#39;);//两个二选一即可； cout &lt;&lt; endl &lt;&lt; &quot;Done&quot; &lt;&lt; endl; return 0; } bool bool is_ready = true; //&quot;is_ready&quot; assigned true or 1; 创建符号常量 尽量使用const来创建，而非&quot;#define&quot;; const type name = value; 声明时没有提供值，则该常量的值将是不确定的，且无法修改。 好处： 1, 限定类型 2, 限定范围 +d.dddE+n 指的是将小数点向右移动n位， +换成~时，表示将小数点向左移动n位。 setf成员函数可以把强行把浮点数输出时用定点表示法 int main() { cout.setf(ios_base::fixed, ios_base::floatfield); cout &lt;&lt; &quot;Integer division: 9/5 = &quot; &lt;&lt; 9 / 5 &lt;&lt; endl; cout &lt;&lt; &quot;Floating-point division: 9.0 / 5.0 = &quot;; cout &lt;&lt; 9.0 / 5.0 &lt;&lt; endl; cout &lt;&lt; &quot;Mixed division: 9.0 / 5 = &quot; &lt;&lt; 9.0 / 5 &lt;&lt; endl; cout &lt;&lt; &quot;double constants: 1e7 / 9.0 = &quot;; cout &lt;&lt; 1.e7 / 9.0 &lt;&lt; endl; cout &lt;&lt; &quot;float constants: 1e7f / 9.0f = &quot;; cout &lt;&lt; 1.e7f / 9.0f &lt;&lt; endl; return 0; } 浮点类型默认为double类型 以{}方式初始化时进行的转换 使用大括号的初始化，陈作列表初始化，因为这种初始化，常用于给复杂的数据类型提供值列表，对类型转换更为严格， 此类初始化不允许对数据进行缩窄（narrowing），即使得变量类型有可能无法表示赋给它的值。 整型提升（integral promotion） 例如将 bool,char,unsigned char,...值转换为 int 强制转换 (typeName) value typeName (value) static_cast (value)//转换要求很严格 运算符重载 使用相同符号，进行多种操作，叫做运算符重载(operator overloading)]]></content>
      <categories>
        <category>编程与生活</category>
      </categories>
      <tags>
        <tag>C++&amp;C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[认证无线电网络的多目标资源优化-论文阅读]]></title>
    <url>%2Fee%2F%E8%AE%A4%E8%AF%81%E6%97%A0%E7%BA%BF%E7%94%B5%E7%BD%91%E7%BB%9C%E7%9A%84%E5%A4%9A%E7%9B%AE%E6%A0%87%E8%B5%84%E6%BA%90%E4%BC%98%E5%8C%96-%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%2F</url>
    <content type="text"><![CDATA[Multi-Objective Resource Allocation in a NOMA Cognitive Radio Network With a Practical Non-Linear Energy Harvesting Model Yuhao Wang, Senior Member, IEEE, Yuhang Wu, Fuhui Zhou, Member, IEEE, Zheng Chu, Member, IEEE, Yongpeng Wu, Senior Member, IEEE, Fei Yuan 主要内容： 文章提出了一种基于同时传输信息与功率的无线传输技术的非正交多址的认证无线电网络的多目标资源优化（每个收集能量的次级用户收集的能量都为最大时）问题。 主要提出了一种偏重于实际的非线性能量收集模型，相应的提出了一种连续凸逼近的解决方法来解决这种情况下的最优分配策略。 文章背景： 目前固定的频谱分配策略不再适应频谱使用的需求的增长。 下一代通信技术的提出，有6大新能指标和3大效率指标。 6大性能指标：用户体验速率，流量密度，连接数密度，端到端时延，峰值速率，移动性 3大效率指标：频谱效率(SE)，能效(EE)，成本效率。 新的多址接入技术的采用（非正交多址接入，文中主要指基于功率域复用的非正交多址接入技术，多天线PD-NOMA）。 主要思想是恨据用户信道条件差异分配功率,为了保证用户的公平性,给差用户分配更多的功率;从而在保证差的用户的性能条件下,提高系统的整体性能。接收端利用串行干扰消除(SIC)技术来移除不同用户间的干扰。 新的能量供应手段（使用能量获取技术供能）。 通过从周围环境中获取能量，提供几乎无限的能量，从而极大地延长网络的运行时间；同时使用能量获取设备，可以免去布线等约束，从而极大地提高部暑节点的便利性。与传统能量供电网络不同的是，传统供能网络由于能量不是约束条件，其优化的目标是提高网络服务质量，如提高系统的吞吐量或降低用户的阻塞率，而在基于能量获取计数的无线系统中，由于能量获取技术的限制，必须要在优化能量使用的基础上考虑网络中的服务质量优化问题。 本文中，关于能量获取的无线通信研究主要是SWIPT，信息与能量流同时传输系统。SWIPT是一种新的传输模式,可提高5G网络的能量效率。 对于能量获取设备的组网技术采用认知无线电网络。 在认知无线电网络中，认知节点具备学习能力，通过与周围环境交互信息来感知和利用该空间中的可用频谱。 因此，认知无线电及数的出现将极大的提高无线通信系统的频谱利用率。通常假设次级用户使用能量获取技术。 其中发送端的能量有电网或其他稳定的能量来源供应，而接收端通信使用的能量则从发送端的电磁波中获取之后再用于信息的发送，类似于无线充电技术，一般称为无线能量传输，即SWIPT。 更为详细的记录： 频谱使用现状 目前世界上大多数国家的频谱管理都采用固定的频谱分配策略，频谱资源由政府部门管理并分配给固定的授权用户，这样能确保各个用户之间避免过多的相互干扰，同时使得用户能够在一个稳定的环境中更好的利用频谱，然而，随着频谱使用的需求的不断增长，这种固定频谱分配策略的缺点也越来越明显，已经不能满足日益发展的通信需要了。 频谱资源一般可以分为两类，一类是受到严格限制和保护的频谱，另一类是开放的频谱资源，满足某一规范和标准的设备都可以接入和使用该频谱，但必须要保证不对其他用户造成干扰，称之为未授权频谱。现实的情况可以知道，仅有一小部分授权频谱被充分利用，而大部分未授权频谱的使用却非常拥挤。 多址接入技术 多址接入技术是每一代通信技术的关键，其目的是让多个用户能同时接入基站，享受基站提供的通信服务，保证各个用户之间的信号不会互相干扰。 在传统的正交多址接入(OrthogonalMultipleAccess,OMA)方式中,不同用户被分配到相互独立或彼此正交的资源上进行传输,比如:时域、频域、码域等正交资源,以避免不同资源块之间的干扰。 为了进一步提高频谱利用率,第四代移动通信系统引入了正交频分多址(OFDMA)接入技术,即通过将一系列在频域互不重叠的子载波分配给不同用户来完成多址接入。由于正交多址接入方式中一个正交资源只允许分配一个用户,这严重限制了区域的吞吐量和设备连接数。为了满足5G网络海量接入和超高容量需求,非正交多址接入技术(NOMA)被认为是下一代移动通信中最为关键的技术。从根本上来说,非正交多址允许可控的多用户干扰在接收机检测复杂度可容忍条件下来增加非正交的资源分配,从而提高系统的频谱效率。 这里就得提到5G技术的6大性能指标： 6大性能指标：用户体验速率，流量密度，连接数密度，端到端时延，峰值速率，移动性 3大效率指标：频谱效率(SE)，能效(EE)，成本效率。 主流的非正交多址接入主要包括: 基于功率域复用的非正交多址接入技术-PD-NOMA; 引基于码域复用的稀疏码多址接入技术-SCMA PD-NOMA引入了新的维度-功率域,通过叠加编码的思想来发送信号,使得信道条件不同的用户可共享相同的频谱资源,比如时域、频域、码域等正交资源。功率复用的主要思想是恨据用户信道条件差异分配功率,为了保证用户的公平性,给差用户分配更多的功率;从而在保证差的用户的性能条件下,提高系统的整体性能。接收端利用串行干扰消除(SIC)技术来移除不同用户间的干扰。 SIC的主要思想是接收信号根据用户信道条件的差异性逐级消除用户间干扰。比如下行PD-NOMA,某个用户对接收的信号从信道条件最差的用户开始检测其信号,并把该信号从多址干扰中移除；接若检测信道条件次差的用户的信号并移除,以此类推,消除所有信道条件比该用户差的信号。 目前对PD-NOMA技术的研究主要包巧: 单天线PD-NOMA; 协作PD-NOMA； 多天线PD-NOMA。 能量获取技术 在传统的能量受限的无线网络(如无线感知网络)中，感知节点通常使用电池供电, 乏稳定可靠的能量来源，运行时长受限。尽管可以适过替换电池或给电池重靳充电来廷长网络的运行时间，但通常存在替换不便、成本本过高或非常危险(如安装在腐蚀性环境中的传感器)等问题, 有时甚至不可能进行替换(如植入人体的传感器器)。在这些网络中，使用能量获取技术供能的设备优势明显：通过从周围环境中获取能量，提供几乎无限的能量，从而极大地延长网络的运行时间；同时使用能量获取设备，可以免去布线等约束，从而极大地提高部暑节点的便利性。 对能量获取拉术的研究最初集中在以太阳能、风能等可再生能源为能量来源的设备，而能量获取技术的含义井不仅仅包括可再生能源。通信节点从周围环境中获取的能量并不一定指太阳能、风能等清洁能源，也可能指其它设备特定发送的能量，类似于无线充电技术。 在无线通信系统中应用能量获取技术的时候，由于能量来源的变化，传统稳定的电网能量或有限的电池能量供能的网络问题即约束条件不再适用，需要基于能量获取技术的他特点对无线通信的算法、网络协议甚至传输节点的硬件进行重新设计。与传统能量供电网络不同的是，传统供能网络由于能量不是约束条件，其优化的目标是提高网络服务质量，如提高系统的吞吐量或降低用户的阻塞率，而在基于能量获取计数的无线系统中，由于能量获取技术的限制，必须要在优化能量使用的基础上考虑网络中的服务质量优化问题。 本文中，关于能量获取的无线通信研究主要是SWIPT，信息与能量流同时传输系统。主要研究的是能量来源稳定的发送节点向对个接收终端同时进行信息与能量流的传输问题。 对于能量获取设备的组网研究，本文主要研究了认知无线电网络。在认知无线电网络中，认知节点具备学习能力，通过与周围环境交互信息来感知和利用该空间中的可用频谱。通常假设次级用户使用能量获取技术。 对于能量获取设备组网，其能量获取的节点为发送节点，即发送端从周围环境中获取能量，并将收集的能量用于信息的发送。目前已有研究者将目关投向通信过程中信息的接收方获取能量的研究。其中发送端的能量有电网或其他稳定的能量来源供应，而接收端通信使用的能量则从发送端的电磁波中获取之后再用于信息的发送，类似于无线充电技术，一般称为无线能量传输，即SWIPT。 SWIPT技术研究的可行性是基于以下事实：传输信息的无线电波在电磁能量可以被获取的情况下，也是一种能量的来源，也可以被获取。在这个研究方向中，接收端可以接受信息，也可以接收能量，或者两者同时进行。受实际电路限制，接收端不可能同时对同一个信息进行解调与能量收集。因此，SWIPT中接收端同时对信息解调和能量接收的无线电磁流的接受模式通常有两种，一种是时域切换，另一种为能量分割（PS）。本文介绍的是能量分割的工作模式。接受的信号被一个能量分割器分割为两路，一路传输给能量获取单元，一路传输给信息处理单元。 对于SWIPT系统方向地研究，多与物理层多输入多输出天线技术相关，即发送节点与接受节点都装备了多天线，而研究的场景相对较为简单。 本文为了提高能量效率和频谱效率，在实际的非线性能量获取模型下，研究了一种同时具有无线信息和功率传输的非正交多址认知无线网络。提出了一种多目标资源优化问题，以最大限度地提高每个能量采集接收机的收集力。这个问题是非凸的，而且很难解决。本文采用加权Tchebycheff方法求解该问题 结果表明，非线性能量收集模型的性能优于线性能量收集模型。 SWIPT是一种新的传输模式,可提高5G网络的能量效率。其主要思想是节点可从自然界获取能量,如风能、太阳能、机械振动等。 认知无线电 软件无线电视近几年来提出的一种实现无线通信的新概念和新体制，是作为多频带多模式的个人通信系统平台而出现的。其以硬件作为无线通信的基本平台，无线通信功能尽可能用软件实现。这样设计的无线通信系统具有很好的通用性、灵活性，使系统互联合升级备案的非常方便。 软件无线电为扩展平台的认知无线电是一种新的智能无线通信技术，它可以感知到周围环境得环境特征，采用构建理解的方法进行学习，通过无线电知识描述语言（RKRL）与通信网络进行智能交流，实时调整传输参数，是系统的无线规则与输入的无线电激励的变化相适应，已达到无论和是何地通信系统的高可靠性和频谱利用的高效性，认知无线电的一个最大优势是无线用户可以通过该技术实现“频谱共享”，认知无线电在特定频段上进行探索，如果发现该频段当前未被使用，可以在不影响受邀用户的前提下使用该频段。 这种被分配给某出示授权用户但在特定时间和具体位置该用户没有使用的频带被称为“频带空穴”。如果该频段的首要用户恢复无线传输，那么认知无线电设备就跳转到其他频段或者改变传输功率、调制方式等手段来避免对首要用户产生干扰。因此，认知无线电及数的出现将极大的提高无线通信系统的频谱利用率。 认知无线电技术具备认知能力与重构能力，认知能力指的是感知的能力，并且可以从周围环境中收集信息，例如传输频率、带宽、功率等。重构能力指的是为了达到最佳的性能，根据感知信息自适应地调整操作参数。 认知无线电的关键技术是频谱感知与频谱接入。频谱感知、频谱接入、频谱管理、频谱切换。 文章概述 认为，将NOMA与SWIPT相结合，可以同时改善SE和EE。 第I部分主要介绍了一些相关领域的研究成果。其中在B部分中，提到了，本文研究的特别之处。将SWIPT技术应用于NOMA认知无线电网络中，在多目标资源分配问题中研究了一个实际的非线性EH模型。 在实际的非线性能量收集模型下，研究了非正交多址接入技术下的认知无线电系统的多目标资源优化问题，使得在最小传输速率和最大干扰功率的约束下，每个单元的收获能量最大。 由于该问题具有非凸性不好解决，这里利用了加权切比雪夫方法，转化为单目标优化问题，并提出了一种基于逐次凸逼近的求解算法来解决这个问题。 通信网络中相关设定 PBS表示主基站(PrimaryBaseStation)，通过光缆可以将各类监测数据、感知数据、计量数据等业务数据传输到变电站内的各种应用系统子站，也可以根据需要将数据通过电力骨干网络(SDH等)传输到省电力公司内的系统主站。 CBS表示认知基站(CognitiveBaseStation)，通过光缆与主基站连接进行信息交互，通过无线方式与次用户通信。 PU表示主用户即授权用户(PrimaryUser)，SU表示次用户即认知用户(SecondaryUser)，这里的用户在实际应用场景中泛指各种无线通信终端，各类业务数据通过授权用户或次用户将数据传输到基站，SB表示频谱经纪人(SpectrumBroker)，通过光缆或者网线形式与认知基站进行信息交互。 认知基站负责认知用户的控制和管理，主要包括对认知用户的感知结果进行融合、空闲信道资源分配、接入及切换管理。 频谱使用区域分授权频段区域和非授权频段区域，在授权频段区域，认知基站与主基站进行信息交互，降低感知目标频段的盲目性，认知用户根据认知基站的交互信息，感知授权用户的授权频段的空闲情况并利用。 在非授权频段区域，认知用户感知非授权频段的使用情况并进行竞争利用，能够及时规避干扰频段，使用动态分配的频谱资源，在该区域中频谱经纪人充当协调者角色，负责不同认知网络之间的频谱资源协调管理。 接受的信号被一个能量分割器分割为两路，一路传输给能量获取单元，一路传输给信息处理单元。其中由两个SU（SUi，SUj）来解码，处理信息，而剩余的N-2个SU来执行能量获取。所有设备都配备了单天线。PBS向所有M个PU传输信息，而CBS则使用一个功率域NOMA方案为SUi，SUj提供SWIPT服务，并将能量传输给其他SU，只要CBS强加于该系统的干扰是可以容忍的。 文中假设，涉及到的信道都是频率平坦慢衰落信道（即为如果信号带宽远小于相干带宽，则可以近似认为在信号的带宽内，信道的功率谱包络是平的（幅度增益为常数），此时称信号经历了平坦衰落） 给出了SUi，SUj和其他能量收集SU接收到的信号以及CBS施加在PUm上的干扰信号表达式。并对相关参数进行了假设。 模型设定 先提了线性能量收集模型。由于实际中，功率转换效率与输入功率水平有很大关系。特别是，效率首先随着输入功率的增加而增加，然后在一个常数处饱和。此外，最大可能的收获效率也有限制。引出了本文的更偏向于实际的非线性能量收集模型。这里引入了逻辑斯蒂函数，进而描述了由硬件限制引起的各种非线性现象的联合效应。 这些模型表示的是RF到直流(DC)转换电路的关系。 问题的约束与提出 最小传输速率、最大干扰功率、每个单元的收获能量最大。假定了SUi比SUj的信道条件差，这里SUi信道条件差，基站发送信号时提供更大的功率。进而给出了各自的信息解码速率。同时还要保证其各自的速率要满足不小于最小值。 而对于SUj对于本要SUi解码的信息进行解码的速率也有限制，因为要实现连续干扰消除，需要先处理功率更强的信号，需要对其解码重构，而这个操作是有速度要求的。同样，由前面提到可知，这里CBS对于PU的干扰必须要在允许范围内。 由以上条件，Pi和Pj是最优变量，为了最大化每个收集能量的次级用户收集的能量，得出了一个多目标优化问题。 这里的MOOP最优解构成一个可行的最优区域，定义为Pareto最优(多目标规划问题最优解)，即当且仅当存在唯一一组解，使得每个次级用户收集的能量最大化。 问题的变形 引入了理想收集能量（Utopia Harvesting Energy），表示每个用户能获得的最大量。上面的多目标优化问题可以表述为在最优参数Pi与Pj下，加上约束条件后，对于每个收集能量的次级用户收集的能量都为最大时的解。 进一步可以变形为一个关于Pi，Pj的凸问题，可以利用拉格朗日乘数法来解决。进而得到一个最优Pi，Pj分配策略，来获得理想收集能量。同时，提出了一种最优功率分配算法，从而可以获得理想收集能量。 获得理想收集能量后，多目标优化问题可以通过使用加权切比雪夫方法，转化为单目标优化问题。利用权重关系可以解决前面的多目标优化问题。帕累托最优收集能量，可以通过理想能量加权获得。 通过代换，设参数，一阶Taylor级数展开，替换约束条件，将问题转化为一个相对于Pi与Pj为凸的问题，从而利用拉格朗日乘数法来解决。进而得到了帕累托最优收集能量。 仿真结果 利用文献33与35设置非线性能量收集参数。也设置了一个线性能量收集模型，加上前面的约束条件，进行了测试。所有涉及的信道都被假定为瑞利平坦衰落。 仿真测试了不同PU干扰容限值下，理想收集功率与迭代次数的关系。该算法仅需少量迭代就能收敛到一个常数值。这验证了我们提出的算法的有效性。 也测试了在非线性与线性模型下，最大PU干扰容限值与理想收集效率的关系。可见都随最大干扰容限值而增加。这是因为CBS可以在更宽松的功率约束下，即更大的Γm值下，使用更多的功率将信息传输给SU。 但是可见这里的非线性模型分配方案可以获得更大的理想收集功率。其原因是线性EH模型采用固定功率转换效率ηn=0.5，导致资源分配不匹配。 测试了SUi不同服务质量下的PU最大干扰容限值与理想收集功率的关系。可见理想收集功率随最大容限值增加而增加。这里可以类似地由以下事实来解释：较宽松的干扰约束可以让CBS提供更高的发射功率。这样，SU就能收获更多的功率。 还可以观察到，SUi的QoS较低导致了更大的理想收集功率。这是因为在能量收集和信息传输之间存在着一种平衡。具体来说，当第SUi的QoS增加时，收集功率可能会降低。 测试了用户1的功率分配权重与帕累托收集功率之间的关系。将理想收集功率设置为每个用户收集能量的上限值，从结果可见，随着权重的增大，趋于1，则逐步趋向理想收集功率，帕累托收集功率与权重成正比。 仿真结果表明，非线性能量采集模型的性能要好于线性能量采集模型下的性能，并且信息解码用户的速率与采集能量之间存在权衡。 参考： 5G移动网络非正交多址接入及相关技术研究_杨正 Non-Orthogonal Multiple Access (NOMA): Evolution towards 5G Cellular Networks - 28 April 2016 基于能量获取的无线通信系统研究 频谱管理的现状及其发展概述（(20180118130630) 多用户信能同传系统的收发机优化设计 多用户无线信能同传系统能效优化方法 基于能量获取的无线通信系统研究 认知MIMO系统下行链路干扰抑制算法研究 认知无线电关键技术研究 认知无线电网络性能分析以及能量收集研究_崔飞 认知无线电中无线频谱感知技术的研究 无线协作中继网络的资源分配和信息能量同传技术的研究 信道质量对网络性能的影响 下载链接： 链接: https://pan.baidu.com/s/1bqzim3H 密码: xh79]]></content>
      <categories>
        <category>技术与进步</category>
      </categories>
      <tags>
        <tag>通信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[生成任意字体的“福”字]]></title>
    <url>%2Flangs%2Fpython%2F%E5%A4%9A%E7%A7%8D%E5%AD%97%E4%BD%93%E7%9A%84%E7%A6%8F%E7%9A%84%E7%94%9F%E6%88%90%2F</url>
    <content type="text"><![CDATA[生成任意字体的“福”字 具体代码见后，相关不足见下 最大的问题就是 我电脑中的字体很多对于此处代码的中文无法正常显示，如何保证最终的字体图片中只保留正常的图片 使产生不同的福字除了改变字体外还可以使用什么手段 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041# 调用cmdimport os# 处理字符串import re# 文字转化为图片from PIL import Image, ImageFont, ImageDraw# 列出所有的字体文件，主要是用ttf（TrueType字体)文件return_cmd = os.popen("C: &amp; cd / &amp; cd C:\Windows\Fonts\ &amp; tree /f")fonts = return_cmd.read()print(fonts)# 只保留ttf部分pattern = re.compile('\S.*?ttf', re.I)result_list = pattern.findall(fonts)# 去掉中文名称的字体result_list = result_list[1:-9]print(result_list)# 文字处理text = "福"# 指定图片保存文件夹path_img = 'D:\\编程\\py-font-fu\\img\\'if os.path.isdir(path_img): passelse: os.mkdir(path_img)# 绘制，保存for index in range(len(result_list)): # 新建一个300*300的空白图像 img = Image.new("RGB", (300, 300), (255, 255, 255)) # 创建画笔 drawer = ImageDraw.Draw(img) # 字体 path_font = 'C:\\Windows\\Fonts\\' + result_list[index] font = ImageFont.truetype(path_font, 200) drawer.text((10, 10), text=text, font=font, fill=(0, 0, 0)) # 保存 img.save(path_img + result_list[index][0:-3] + 'png')]]></content>
      <categories>
        <category>编程与生活</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一些汇编练习]]></title>
    <url>%2Flangs%2Fasm%2F8086%E6%B1%87%E7%BC%96%E6%80%BB%E7%BB%93-%E4%B8%80%E4%BA%9B%E6%B1%87%E7%BC%96%E7%BB%83%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[作者：lart 时间：2017年11月27日22:33:58 GitHub 习题4： 从屏幕上输入大写字母，转换为小写字母并输出（生成.com文件） 要求：程序具有可读性、容错性 思路： 由于要生成.com文件，所以需要将文件代码设置到一个代码段里。本问题涉及到读入与显示，这里可以使用21h中断的1,2,9号子功能。 读入字符后，将al中存放的字符通过判断其是否为大写字母来保证程序的正确性。利用大小写ascii码上的对应关系，实现了大小写的转化。 代码如下： 12345678910111213141516171819202122232425262728293031323334353637code segment para assume cs:code, ds:code, ss:code org 0100h main proc near again: lea dx, str_dis mov ah, 9 int 21h ;显示初始字符串，提示输入 mov ah, 1 int 21h ;获得输入字符，存到al里 cmp al, &apos;A&apos; ;判断输入字符是否是A~Z的字符 jb error cmp al, &apos;Z&apos; ja error ;保证输入合法 add al, 20h ;大写+20h=小写 mov str_num, ax ;将ax保存 lea dx, str_res mov ah, 9 int 21h ;显示结果提示字符串 mov ax, str_num ;将ax恢复 mov dl, al mov ah, 2 int 21h ;显示最终结果 mov ax, 4c00h int 21h error: lea dx, str_err mov ah, 9 int 21h jmp again main endp str_num dw 0000h str_dis db 0dh, 0ah, &apos;Please input(A~Z):$&apos; str_res db 0dh, 0ah, &apos;The result is:$&apos; str_err db 0dh, 0ah, &apos;The data of input is invalid!$&apos;code ends end main 编写一子程序 asc2bin ，将 ASCII 转换为二进制数 要求： 输入参数：AL 中存放需要转换的 ASCII 输出参数：AL 中存放转换后的二进制数并返回 思路： 对于ascii码，先都当做数字来处理，即都减30h，在与9比大小，大于9的说明是10~15，再减7即可。 代码如下： 123456789asc2bin proc sub al, 30h ;先都当做表示数字的acsii cmp al, 9 ;与9比较，小于等于9的，直接跳转，大 ;于9的，仍然需要处理 jbe asc2bin_sub ;跳转子程序 sub al, 7 ;继续减7asc2bin_sub: ret ;返回主程序asc2bin endp 内存中存放8个16位有符号数，求8个数值之和，并将结果存放在内存变量SUM中 注：程序中应用到字扩展为双字的指令CWD 思路： 通过使用循环加法，扩展双字的指令，转化为双字的计算加和。 代码如下： 123456789101112131415161718192021222324252627data segment para buf dw -1, 2, -33, 44, -555, 666, -7777, 8888 sum dd 0data endsss_seg segment stack dw 100 dup(0)ss_seg endscode segment para assume cs:code, ds:data, ss:ss_seg main proc far mov ax, data mov ds, ax ;指定数据位置 lea bx, buf ;bx指向buf首地址 mov cx, 8 ;指定循环次数 w2d: mov ax, [bx] cwd ;有符号数字扩展为双字，默认使用&#123;dx,ax&#125; add word ptr sum, ax ;32 位数相加 adc word ptr sum + 2, dx inc bx inc bx loop w2d ;循环 8 次 mov ax, 4c00h int 21h main endpcode ends end main 内存中存放 8 个 8 位有符号数，请按从大到小顺序排列 思路： 利用冒泡排序，设置两个循环，将相邻的数字进行比较，大的放在低位地址，小的放在高位地址。 对于循环的次数的设置这里有些需要注意的地方。一般而言，n个数的问题，外层循环需要n-1次，而内层循环也是需要n-1次比较，所以可以设置使用相同的循环计数器。只需要内层循环计数的时候将之前的压栈保存即可。 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748;低地址到高地址，大数到小数。data segment para buf db -1, 2, -33, 44, -55, 66, -77, 88data endsstack segment stack dw 100 dup(0)stack endscode segment para assume cs:code, ds:data, ss:stack main proc far ;将ds:bx指向存放数据的位置 mov ax, data mov ds, ax mov cx, 7 ;主循环仅需要7次 loop_main: lea bx, buf push cx ;cx=n, 子循环正好也要循环n次 ;压栈保存外循环循环次数 mov si, 0 ;标志是否有交换，当后面检测si==0时，说明 ;内部已经排序完毕 loop_sub: ;取得第一个数据到ax里，将之与第二个数据比较大小 ;ax大等于[bx]的话，保留原样 ;ax小的话，就得将两个数据进行交换位置 mov al, [bx] cmp al, [bx+1] jge not_xchg ;&gt;=不交换 ;ax小，进行交换 xchg al, [bx+1] mov [bx], al mov si, 1 ;标志有交换 not_xchg: ;第一步交换完成，需要依次进行一遍 inc bx loop loop_sub ;完毕后，只完成了初步的重排，这时数据段中的情况是，高地址存放最小的数 ;还需要继续执行，之后每次都减少一次 cmp si, 0 je done_xchg ; 仍有交换，还需重复 pop cx ;出栈，恢复cx loop loop_main done_xchg: mov ax, 4c00h int 21h main endpcode ends end main 内存中有8个16位数，请编写程序将8个数倒序排放 例：定义内存中8个数 buf dw 100, 3, 1, 20, 40, -2, 7, 10 程序运行后，buf 开始应为： buf dw 10, 7, -2, 40, 20, 1, 3, 100 思路： 要实现倒序存放，利用栈的入栈出栈，或者反复循环交换。但是使用栈，更为便捷。 代码如下： 12345678910111213141516171819202122232425262728data segment para buf dw -1, 2, -33, 44, -555, 666, -7777, 8888data endsstack segment stack dw 100 dup(0)stack endscode segment para assume cs:code, ds:data, ss:stack main proc far mov ax, data mov ds, ax lea bx, buf mov cx, 8 stack_push: push [bx] add bx, 2 loop stack_push lea bx, buf mov cx, 8 stack_pop: pop [bx] add bx, 2 loop stack_pop mov ax, 4c00h int 21h main endpcode ends end main 从键盘输入 4 位十进制数，然后以 16 进制形式显示在屏幕上 例：键盘输入：1024 屏幕上应显示：0400H 要求：键盘输入和显示结果时均应有提示 思路： 输入四位十进制数，将ascii码利用中断功能，读入（此处会对输入字符做出合法性判断），转换为十进制数并以二进制的形式存在内存里，最后，转换为十六进制，并拆分各个数字，显示ascii码输出。具体流程详见注释。 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100;具体流程：ASCII码输入-&gt;十进制-&gt;十六进制-&gt;ASCII码显示;故需要子函数完成进制转换、ascii转换data segment para buf db 4 dup(0) var_10 dw 0 str_input db 0dh, 0ah, &apos;Please input four numbers(0-9):$&apos; str_error db 0dh, 0ah, &apos;The input is error, please try again.$&apos; str_output db 0dh, 0ah, &apos;The hex result is:$&apos;data endsstack segment stack dw 100 dup(0)stack endscode segment para assume cs:code, ds:data, ss:stack main proc far mov ax, data mov ds, ax loop_again: ;输入有错误需要重新读取输入 lea dx, str_input ;显示数据输入提示信息 mov ah, 9 int 21h lea bx, buf ;用bx来作为buf的指代 mov cx, 4 ;循环输入4个数 loop_input: mov ah, 1 ;输入数据 int 21h cmp al, &apos;0&apos; ;判断输入字符是否为‘0’~‘9’ jb error cmp al, &apos;9&apos; ja error ;非法字符，进行错误处理 ;直接输入一个字符，处理一个字符 sub al, 30h ;ASCII转换为二进制，得到 0-9 mov [bx], al ;存入缓冲区 inc bx loop loop_input jmp input_valid ;数据输入正确后 ,跳转到后续处理 error: lea dx, str_error ;显示错误提示信息 mov ah, 9 int 21h jmp loop_again ;跳转到重新输入 input_valid: ;现在数据以二进制的形式存储 mov ax, 0 ;以(((0*10+dl3)*10+dl2)*10+dl1)*10+dl0计算 ;十进制数据结果存放到ax中 mov dx, 0 ;因为ax可以满足存放四位十进制数的需求 mov si, 10 mov bx, 0 mov cx, 4 loop_mul10: mul si ;相乘后dx仍然保持 0 mov dl, [bx] ;将buf数据取到dl中 mov dh, 0 add ax, dx inc bx loop loop_mul10 ;循环4次乘10 mov var_10, ax ;得到的 4 位十进制数存放到 var_10 中 ;var_10共16位，存放十进制数对应的二进制 lea dx, str_output mov ah, 9 int 21h ;显示输出提示符 mov ch, 4 ;以16进制显示输入的数据，循环四次 mov cl, 4 loop_display: rol var_10, cl ;循环左移4位，因为要先显示高位 mov ax, var_10 and ax, 000fh ;仅保留最低四位 call bin2asc ;二进制转换为 ASCII call pchar ;显示一个十六进制字符 dec ch jnz loop_display mov al, &apos;H&apos; ;显示十六进制‘H’记号 call pchar mov ax, 4c00h int 21h main endp ;功能: 将一个二进制数字转换为ASCII ;输入参数 : AL中存放二进制数（有效位只有低四位） ;输出参数 : AL中存放ASCII bin2asc proc and al, 0fh add al, 30h cmp al, 39h jbe done_b2a add al, 07h ;是A~Z done_b2a: ret ;返回 bin2asc endp ;功能：显示单个字符 ;输入参数：AL中存放ASCII ;输出参数：无 pchar proc mov dl, al mov ah, 2 int 21h ret ;返回 pchar endpcode ends end main 数据段从100H开始存放字符串str1，从200H开始存放str2，二者均以NULL字符为结束符，编写程序将str2拷贝到str1末尾，形成一个完整字符串 例： ORG 100H str1 db 0dh, 0ah, ‘Hello ’, 0 ORG 200H str2 db ‘Automation!’, 0 程序运行后结果应为： str1 db 0dh, 0ah, ‘Hello Automation!’, 0 思路： 利用repnz scasb指令，将扫描的字符与al中预存的0比较，即查找str_first的结束位置，找到后，利用mov cx, count &amp; rep movsb两条命令，以及count equ ($-str_second)，将str_secon复制到str_first之后。 最后再利用lodsb，配合中断功能，显示最终的合并字符串。 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647data segment para ORG 100H str_first db 0dh, 0ah, &apos;Hello &apos;, 0 ORG 200H str_second db &apos;Automation! &apos;, 0 count equ ($-str_second)data endsss_seg segment stack dw 100 dup(0)ss_seg endscode segment para assume cs:code, ds:data, ss:ss_seg main proc far mov ax, data mov ds, ax mov es, ax lea di, str_first ;es:di 指向str_first首地址 mov al, 0 repnz scasb ;查找到str_first结束符NULL，最后di会多加一次 dec di ;让es:di指向该位置 lea si, str_second ;ds:si指向str_second首地址 cld ;DF置零，右移 mov cx, count rep movsb ;重复搬移 lea si, str_first ;ds:si 指向拷贝后的 str_first 首地址 display: lodsb ;显示拷贝后的 str_first 字符串 cmp al, 0 jz exit ;显示完毕 call pchar jmp display exit: mov ax, 4c00h int 21h main endp ;功能：显示单个字符 ;输入参数：AL中存放ASCII ;输出参数：无 pchar proc mov dl, al mov ah, 2 int 21h ret pchar endpcode ends end main 以 10 进制形式显示 内存中一有符号字节数据 例：var db 0ffH 屏幕应显示：The result is: -1 代码如下： 思路： 主要是二进制转化为十进制后拆分成单个数字，在将之处理为ascii码。 首先需要与0比较，利用jg/jl等有符号数比较指令实现跳转处理。分别将第一个字符设置为对应的符号。 再将实际数值部分进行处理，转换为ascii码，进行显示。 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142;思路：二进制-&gt;十进制-&gt;ascii码data segment para var_signed db 0ffH str_result db 0dh, 0ah, &apos;The result is: &apos; num_signed db 4 dup(&apos; &apos;);因为有符号字节数，最多就是三位十进制 db &apos;$&apos;data endsstack segment stack dw 100 dup(0)stack endscode segment para assume cs:code, ds:data, ss:stack main proc far mov ax, data mov ds, ax mov num_signed, &apos;+&apos; cmp var_signed, 0 ;判断 var_signed 是正数 ,还是负数 jge is_pos ;&gt;= 为正数 mov num_signed, &apos;-&apos; ;&lt; 为负数 neg var_signed ;若 var_signed 为负，则补码的相反数 is_pos: mov al, var_signed mov cx, 3 mov dl, 10 ;进制 lea bx, num_signed+3;倒着放数据 again: mov ah, 0 ;高八位置零 div dl add ah, 30h ;余数 ah mov [bx], ah dec bx loop again ;循环 3 次,分别得到百、十、个位 done: lea dx, str_result ;显示 10 进制数 mov ah, 9 int 21h exit: mov ax, 4c00h int 21h main endpcode ends end main 将一个16位的无符号数var，转换为非压缩格式BCD码，存放在内存中buf开始的单元中。（按高位在 前、低位在后的顺序存放） 思路： 利用二进制转换十进制：((02 + B15)2 + B14)2 + ? + )2 + B0 在运算过程中利用非压缩格式bcd码调整指令aaa，处理为非压缩格式bcd码，使得最终结果即为非压缩格式bcd码。 代码如下： 1234567891011121314151617181920212223242526272829303132333435;二进制数 0FFFH，十进制 4095，非压缩BCD 4 0 9 5 各一个字节的低四位;二进制转换十进制：((0*2 + B15)*2 + B14)*2 + ? + )*2 + B0data segment para buf db 4 dup(0) var dw 0FFFH data endsstack segment stack dw 100 dup(0)stack endscode segment para assume cs:code, ds:data, ss:stack main proc far mov ax, data mov ds, ax mov cx, 16 ;要进行十六次移位，利用adc获得 loop_wai: shl var, 1 ;得到 var 的 Bi 位 mov bx, 3 push cx mov cx, 4 loop_nei: mov al, [bx] ;执行 buf*2 + Bi 操作 adc al, al aaa ;非压缩格式 BCD 码调整 mov [bx], al dec bx loop loop_nei ;内循环为 4 次 pop cx loop loop_wai ;外循环为 16 次 exit: mov ax, 4c00h int 21h main endpcode ends end main 内存中有两个32位有符号数，请编写完整汇编语言程序，将二者相乘，结果保存在64位有符号数RESULT中 思路： 两个32位与符号数相乘，只要处理好符号位，就可以转化为无符号数相乘。 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566data segment para num_1 dd 80000002h num_2 dd 80005000h result dw 4 dup (?)data endsss_seg segment stack dw 100 dup (0)ss_seg endscode segment para assume cs:code, ds:data, ss:ss_seg main proc far mov ax, data mov ds, ax shl byte ptr [num_1+3], 1 ;处理符号位 jc num_1_l0 ;num_1&lt;0 xor ax, ax shr byte ptr [num_1+3], 1 ;剥离符号位 mov bh, 0h ;用bh存放符号位 jmp next ;符号位被置零 num_1_l0:;num_1&lt;0 mov bh, 1h ;用bh存放符号位 next: shl byte ptr [num_2+3], 1 ;对num_2做相同处理 jc num_2_l0 xor ax, ax shr byte ptr [num_2+3], 1 mov bl, 0h jmp continue num_2_l0:;num_2&lt;0 mov bl, 1h continue: ; 当做无符号数处理，计算相乘 lea si, num_1 lea di, num_2 mov ax, [si] mov dx, [di] mul dx mov [result],ax mov [result+2],dx mov ax, [si+2] mov dx, [di] mul dx add [result+2],ax adc [result+4],dx mov ax, [si] mov dx, [di+2] mul dx add [result+2],ax adc [result+4],dx adc [result+6],0 mov ax, [si+2] mov dx, [di+2] mul dx add [result+4],ax adc [result+6],dx sub bh, bl ;处理符号 jnz bh_nz_bl ;num_1 num_2异号 and [result+7], 01111111b ;同号就将结果最高位置0 jmp exit bh_nz_bl:;不同号 or [result+7], 10000000b ;异号就将结果最高位置1 exit: mov ah, 4ch int 21h main endpcode ends end main 将一个 8 位压缩 BCD 码转换为二进制数 思路： 对于四位压缩bcd码的过程比较简单，可以利用不断循环左移四位，将高位字节的两个bcd码置于字单元的最后位置，整体赋给寄存器，现在寄存器里存放的是一位压缩bcd码，乘以10再加上下一位如此获得的bcd码，反复如此，就可以获得四位的压缩bcd对应的十进制，存放到内存中，就变为了二进制。 而对于八位压缩bcd码，则可以拆成高四位对应的十进制，乘以10000，加上低四位对应的十进制数。这里就是这样处理的。 高四位低四位分别求出了对应的十进制，按上述规则相加，得到了最终结果。 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445data segment para BCD_num dd 12345678h bin_num db 4 dup(0) loop_num db 2data endsss_seg segment stack dw 100 dup(0)ss_seg endscode segment para assume cs:code, ds:data, ss:ss_seg main proc far mov ax, data mov ds, ax mov si, 10 mov ax, 0 mov dl, 2 ;分两段 mov di, 2 again_loop: mov cx, 0404h ;ch 乘法循环计数器； cl 移位计数器 again_mul: mul si rol word ptr [BCD_num+di], cl mov bx, word ptr [BCD_num+di] and bx, 000fh add ax, bx dec ch jnz again_mul mov word ptr [bin_num+di], ax xor di, di xor ax, ax sub [loop_num], 1 jnz again_loop ; 高四位对应的十进制乘以10，加上低四位对应的十进制 mov ax, word ptr [bin_num+2] mov bx, 10000 mul bx add ax, word ptr [bin_num] adc dx, 0 mov word ptr [bin_num], ax mov word ptr [bin_num+2], dx mov ax, 4c00h int 21h main endpcode ends end main 选作题： 内存中从str开始存放一字符串，结束符为NULL字符，请编写程序统计该字符串中单词的个数 例：str1 db 0dh, 0ah, ‘Hello world, welcome to DUT. CPU is central processing unit!’, 0h 统计 ’….’ 中的单词个数，结果为10 思路： 如题所述，主要统计空格。通过扫描字符串，统计空格，但是有效的空格前一个字符是有效的字符，只有这样的空格才会统计。 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546data segment parajj string db 0dh, 0ah, &apos;Hello world, welcome to DUT. CPU is central &apos; db &apos;processing unit!&apos;, 0h words dw 0data endsstack segment stack db 256 dup(0)stack endscode segment para assume cs:code, ds:data, ss:stack main proc far mov ax, data mov ds, ax mov cx, 0 ;用 cx 存放单词数 lea si, string mov bl, &apos; &apos; ;bl 总保存当前字符的前一个字符 cld ;保证右移 load_al: lodsb ;从ds:si中以字节为单位获取数据，al只判断0以及空格 and al, al ;判断 al 是否为结束符 0，al=0 zf=1，al!=0，zf=0 jz al_0 cmp al, &apos; &apos; ;比较是否是空格，只对空格计数 jnz bl_new al_douhao: ;处理重复计数：计数只是根据空格的个数来计算。 ;重复计数主要是因为多个空格以及逗号空格连续所致。 cmp bl, &apos; &apos; ;比较前一个字符是否为空格，如果是则此空格 ;不能算一个单词，即为了防止多个空格的情况 jz bl_new inc cx ;只有当前字符为 &apos; &apos;或&apos;,&apos; 而且前一个字符为有 ;效字符时，才对单词数加 1 jmp bl_new bl_new: mov bl, al ;进入这里表明此时 al 中内容不是 0 或者 &apos; &apos; ;符号 ,保存 al 到 bl jmp load_al al_0: ;判断结束符前面是否有&apos; &apos;，删掉多余的计数 cmp bl, &apos; &apos; jz done inc cx ;若结束符前是一个有效字符，那么单词数应该加 1 done: mov words, cx mov ax, 4c00h int 21h main endpcode ends end main]]></content>
      <categories>
        <category>编程与生活</category>
      </categories>
      <tags>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的豆瓣短评爬虫的多线程改写]]></title>
    <url>%2Flangs%2Fpython%2Fspyderformultithread%2F</url>
    <content type="text"><![CDATA[对之前我的那个豆瓣的短评的爬虫，进行了一下架构性的改动。尽可能实现了模块的分离。但是总是感觉不完美。暂时也没心情折腾了。 同时也添加了多线程的实现。具体过程见下。 改动 独立出来的部分： MakeOpener MakeRes GetNum IOFile GetSoup main 将所有的代码都置于函数之中，显得干净了许多。(*^__^*) 嘻嘻…… 使用直接调用文件入口作为程序的起点 12if __name__ == "__main__": main() 注意，这一句并不代表如果该if之前有其他直接暴露出来的代码时，他会首先执行。 12345678print("首先执行")if __name__ == "__main__": print("次序执行")# 输出如下：# 首先执行# 次序执行 该if语句只是代表顺序执行到这句话时进行判断调用者是谁，若是直接运行的该文件，则进入结构，若是其他文件调用，那就跳过。 多线程 这里参考了【Python数据分析】Python3多线程并发网络爬虫-以豆瓣图书Top，和我的情况较为类似，参考较为容易。 仔细想想就可以发现，其实爬10页（每页25本），这10页爬的先后关系是无所谓的，因为写入的时候没有依赖关系，各写各的，所以用串行方式爬取是吃亏的。显然可以用并发来加快速度，而且由于没有同步互斥关系，所以连锁都不用上。 正如引用博文所说，由于问题的特殊性，我用了与之相似的较为直接的直接分配给各个线程不同的任务，而避免了线程交互导致的其他问题。 我的代码中多线程的核心代码不多，见下。 1234567891011121314thread = []for i in range(0, 10): t = threading.Thread( target=IOFile, args=(soup, opener, file, pagelist[i], step) ) thread.append(t)# 建立线程for i in range(0, 10): thread[i].start()for i in range(0, 10): thread[i].join() 调用线程库threading，向threading.Thread()类中传入要用线程运行的函数及其参数。 线程列表依次添加对应不同参数的线程，pagelist[i]，step两个参数是关键，我是分别为每个线程分配了不同的页面链接，这个地方我想了半天，最终使用了一些数学计算来处理了一下。 同时也简单试用了下列表生成式： 1pagelist = [x for x in range(0, pagenum, step)] 这个和下面是一致的： 123pagelist = []for x in range(0, pagenum, step): pagelist.append(x) threading.Thread的几个方法 值得参考：多线程 start() 启动线程 jion([timeout])，依次检验线程池中的线程是否结束，没有结束就阻塞直到线程结束，如果结束则跳转执行下一个线程的join函数。在程序中，最后join()方法使得当所调用线程都执行完毕后，主线程才会执行下面的代码。相当于实现了一个结束上的同步。这样避免了前面的线程结束任务时，导致文件关闭。 注意 使用多线程时，期间的延时时间应该设置的大些，不然会被网站拒绝访问，这时你还得去豆瓣认证下&quot;我真的不是机器人&quot;（尴尬）。我设置了10s，倒是没问题，再小些，就会出错了。 完整代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166# -*- coding: utf-8 -*-"""Created on Thu Aug 17 16:31:35 2017@note: 为了便于阅读，将模块的引用就近安置了@author: lart"""import timeimport socketimport reimport threadingfrom urllib import parsefrom urllib import requestfrom http import cookiejarfrom bs4 import BeautifulSoupfrom matplotlib import pyplotfrom datetime import datetime# 用于生成短评页面网址的函数def MakeUrl(start): """make the next page's url""" url = 'https://movie.douban.com/subject/26934346/comments?start=' \ + str(start) + '&amp;limit=20&amp;sort=new_score&amp;status=P' return urldef MakeOpener(): """make the opener of requset""" # 保存cookies便于后续页面的保持登陆 cookie = cookiejar.CookieJar() cookie_support = request.HTTPCookieProcessor(cookie) opener = request.build_opener(cookie_support) return openerdef MakeRes(url, opener, formdata, headers): """make the response of http""" # 编码信息，生成请求，打开页面获取内容 data = parse.urlencode(formdata).encode('utf-8') req = request.Request( url=url, data=data, headers=headers ) response = opener.open(req).read().decode('utf-8') return responsedef GetNum(soup): """get the number of pages""" # 获得页面评论文字 totalnum = soup.select("div.mod-hd h2 span a")[0].get_text()[3:-2] # 计算出页数 pagenum = int(totalnum) // 20 print("the number of comments is:" + totalnum, "the number of pages is: " + str(pagenum)) return pagenumdef IOFile(soup, opener, file, pagestart, step): """the IO operation of file""" # 循环爬取内容 for item in range(step): start = (pagestart + item) * 20 print('第' + str(pagestart + item) + '页评论开始爬取') url = MakeUrl(start) # 超时重连 state = False while not state: try: html = opener.open(url).read().decode('utf-8') state = True except socket.timeout: state = False # 获得评论内容 soup = BeautifulSoup(html, "html.parser") comments = soup.select("div.comment &gt; p") for text in comments: file.write(text.get_text().split()[0] + '\n') print(text.get_text()) # 延时1s time.sleep(10) print('线程采集写入完毕')def GetSoup(): """get the soup and the opener of url""" main_url = 'https://accounts.douban.com/login?source=movie' formdata = &#123; "form_email": "your-email", "form_password": "your-password", "source": "movie", "redir": "https://movie.douban.com/subject/26934346/", "login": "登录" &#125; headers = &#123; "User-Agent": "Mozilla/5.0 (Windows NT 5.1; U; en; rv:1.8.1)\ Gecko/20061208 Firefox/2.0.0 Opera 9.50", 'Connection': 'keep-alive' &#125; opener = MakeOpener() response_login = MakeRes(main_url, opener, formdata, headers) soup = BeautifulSoup(response_login, "html.parser") if soup.find('img', id='captcha_image'): print("有验证码") # 获取验证码图片地址 captchaAddr = soup.find('img', id='captcha_image')['src'] # 匹配验证码id reCaptchaID = r'&lt;input type="hidden" name="captcha-id" value="(.*?)"/' captchaID = re.findall(reCaptchaID, response_login) # 下载验证码图片 request.urlretrieve(captchaAddr, "captcha.jpg") img = pyplot.imread("captcha.jpg") pyplot.imshow(img) pyplot.axis('off') pyplot.show() # 输入验证码并加入提交信息中，重新编码提交获得页面内容 captcha = input('please input the captcha:') formdata['captcha-solution'] = captcha formdata['captcha-id'] = captchaID[0] response_login = MakeRes(main_url, opener, formdata, headers) soup = BeautifulSoup(response_login, "html.parser") return soup, openerdef main(): """main function""" timeout = 5 socket.setdefaulttimeout(timeout) now = datetime.now() soup, opener = GetSoup() pagenum = GetNum(soup) step = pagenum // 9 pagelist = [x for x in range(0, pagenum, step)] print('pageurl`s list=&#123;&#125;, step=&#123;&#125;'.format(pagelist, step)) # 追加写文件的方式打开文件 with open('秘密森林的短评.txt', 'w+', encoding='utf-8') as file: thread = [] for i in range(0, 10): t = threading.Thread( target=IOFile, args=(soup, opener, file, pagelist[i], step) ) thread.append(t) # 建立线程 for i in range(0, 10): thread[i].start() for i in range(0, 10): thread[i].join() end = datetime.now() print("程序耗时： " + str(end-now))if __name__ == "__main__": main() 运行结果 效率有提升 推荐使用ipython作为shell或者直接使用jupyter notebook，因为可以直接在终端显示出验证码图片。 对应的单线程程序在github上。单线程： 单线程.jpg 可见时间超过30分钟。修改后时间缩短到了11分钟。 多线程.jpg 文件截图 ScreenShot00080.jpg 我的项目 具体文件和对应的结果截图我放到了我的github上。 mypython]]></content>
      <categories>
        <category>编程与生活</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[xpath&css选择器]]></title>
    <url>%2Flangs%2Fhtml%2Fxpathcss_selector%2F</url>
    <content type="text"><![CDATA[XPATH（参考 w3school 和 静觅 和 阮一峰的网络日志） 在 XPath 中，有七种类型的节点：元素、属性、文本、命名空间、处理指令、注释以及文档节点（或称为根节点）。 节点实际上就是各种html标签，属性，以及被标签包围的文字。 搜索方法 xpath使用路径表达式在xml文档中选取节点。节点通过路径或者step来选取。在形式上，&quot;路径表达式&quot;与传统的文件系统非常类似。 斜杠（/）作为路径内部的分割符。 同一个节点有绝对路径和相对路径两种写法。 绝对路径（absolute path）必须用&quot;/&quot;起首，后面紧跟根节，比如/step/step/...。 相对路径（relative path）则是除了绝对路径以外的其他*法，比如 step/step，也就是不使用&quot;/&quot;起首。 &quot;.&quot;表示当前节点。 &quot;..&quot;表示当前节点的父节点 下面是详细介绍： 路径表达式 结果 bookstore 选取 bookstore 元素的所有子节点。 /bookstore 选取根元素 bookstore。注释：假如路径起始于正斜杠( / )，则此路径始终代表到某元素的绝对路径！ bookstore/book 选取属于 bookstore 的子元素的所有 book 元素。 //book 选取所有 book 子元素，而不管它们在文档中的位置。 bookstore//book 选择属于 bookstore 元素的后代的所有 book 元素，而不管它们位于 bookstore 之下的什么位置。 //@lang 选取名为 lang 的所有属性。 谓语（Predicates）谓语用来查找某个特定的节点或者包含某个指定的值的节点。谓语被嵌在方括号中。 路径表达式 结果 /bookstore/book[1] 选取属于 bookstore 子元素的第一个 book 元素。 /bookstore/book[last()] 选取属于 bookstore 子元素的最后一个 book 元素。 /bookstore/book[last()-1] 选取属于 bookstore 子元素的倒数第二个 book 元素。 /bookstore/book[position()&lt;3] 选取最前面的两个属于 bookstore 元素的子元素的 book 元素。 //title[@lang] 选取所有拥有名为 lang 的属性的 title 元素。 //title[@lang='eng'] 选取所有 title 元素，且这些元素拥有值为 eng 的 lang 属性。 /bookstore/book[price&gt;35.00] 选取 bookstore 元素的所有 book 元素，且其中的 price 元素的值须大于 35.00。 /bookstore/book[price&gt;35.00]/title 选取 bookstore 元素中的 book 元素的所有 title 元素，且其中的 price 元素的值须大于 35.00。 XPath 通配符可用来选取未知的 XML 元素。 通配符 描述 * 匹配任何元素节点。 @* 匹配任何属性节点。 node() 匹配任何类型的节点。 在下面的表格中，我们列出了一些路径表达式，以及这些表达式的结果： 路径表达式 结果 /bookstore/* 选取 bookstore 元素的所有子元素。 //* 选取文档中的所有元素。 //title[@*] 选取所有带有属性的 title 元素。 通过在路径表达式中使用“|”运算符，可以选取若干个路径。且供选择的路径之间并无关联。互不干扰，必须各自是完整的独立的路径。 xpath轴可定义相对于当前节点的节点集。 轴名称 结果 ancestor 选取当前节点的所有先辈（父、祖父等）。 ancestor-or-self 选取当前节点的所有先辈（父、祖父等）以及当前节点本身。 attribute 选取当前节点的所有属性。 child 选取当前节点的所有子元素。 descendant 选取当前节点的所有后代元素（子、孙等）。 descendant-or-self 选取当前节点的所有后代元素（子、孙等）以及当前节点本身。 following 选取文档中当前节点的结束标签之后的所有节点。 namespace 选取当前节点的所有命名空间节点。 parent 选取当前节点的父节点。 preceding 选取文档中当前节点的开始标签之前的所有节点。 preceding-sibling 选取当前节点之前的所有同级节点。 self 选取当前节点。 步（step）包括： 轴（axis） 定义所选节点与当前节点之间的树关系 节点测试（node-test） 识别某个轴内部的节点 零个或者更多谓语（predicate） 更深入地提炼所选的节点集 步的语法： 轴名称::节点测试[谓语] 实例 例子 结果 child::book 选取所有属于当前节点的子元素的 book 节点。 attribute::lang 选取当前节点的 lang 属性。 child::* 选取当前节点的所有子元素。 attribute::* 选取当前节点的所有属性。 child::text() 选取当前节点的所有文本子节点。 child::node() 选取当前节点的所有子节点。 descendant::book 选取当前节点的所有 book 后代。 ancestor::book 选择当前节点的所有 book 先辈。 ancestor-or-self::book 选取当前节点的所有 book 先辈以及当前节点（如果此节点是 book 节点） child::*/child::price 选取当前节点的所有 price 孙节点。 下面列出了可用在 XPath 表达式中的运算符： 运算符 描述 实例 返回值 | 计算两个节点集 //book | //cd 返回所有拥有 book 和 cd 元素的节点集 + 加法 6 + 4 10 - 减法 6 - 4 2 * 乘法 6 * 4 24 div 除法 8 div 4 2 mod 计算除法的余数 5 mod 2 1 = 等于 price=9.80 如果 price 是 9.80，则返回 true。如果 price 是 9.90，则返回 false。 != 不等于 price!=9.80 如果 price 是 9.90，则返回 true。如果 price 是 9.80，则返回 false。 &lt; 小于 price&lt;9.80 如果 price 是 9.00，则返回 true。如果 price 是 9.90，则返回 false。 &lt;= 小于或等于 price&lt;=9.80 如果 price 是 9.00，则返回 true。如果 price 是 9.90，则返回 false。 &gt; 大于 price&gt;9.80 如果 price 是 9.90，则返回 true。如果 price 是 9.80，则返回 false。 &gt;= 大于或等于 price&gt;=9.80 如果 price 是 9.90，则返回 true。如果 price 是 9.70，则返回 false。 or 或 price=9.80 or price=9.70 如果 price 是 9.80，则返回 true。如果 price 是 9.50，则返回 false。 and 与 price&gt;9.00 and price&lt;9.90 如果 price 是 9.80，则返回 true。如果 price 是 8.50，则返回 false。 这里主要使用是配合lxml库，下面是一些例子。 1234567891011121314151617181920212223242526272829303132#========# 文本读取#========from lxml import etreetext = '''&lt;div&gt; &lt;ul&gt; &lt;li class="item-0"&gt;&lt;a href="link1.html"&gt;first item&lt;/a&gt;&lt;/li&gt; &lt;li class="item-1"&gt;&lt;a href="link2.html"&gt;second item&lt;/a&gt;&lt;/li&gt; &lt;li class="item-inactive"&gt;&lt;a href="link3.html"&gt;third item&lt;/a&gt;&lt;/li&gt; &lt;li class="item-1"&gt;&lt;a href="link4.html"&gt;fourth item&lt;/a&gt;&lt;/li&gt; &lt;li class="item-0"&gt;&lt;a href="link5.html"&gt;fifth item&lt;/a&gt; &lt;/ul&gt; &lt;/div&gt;'''html = etree.HTML(text)result = etree.tostring(html)print(result)#========# 文件读取#========from lxml import etreehtml = etree.parse('hello.html')result = etree.tostring(html, pretty_print=True)print(result)#=============# 利用xpath解析#=============from lxml import etreehtml = etree.parse('hello.html')result_list = html.xpath('//li')print result_list CSS选择器（转自阮一峰的网络日志） 基本选择器 最基本的就是针对标签，类以及id了。 序号 选择器 含义 1. * 通用元素选择器，匹配任何元素 2. E 标签选择器，匹配所有使用E标签的元素 3. .info class选择器，匹配所有class属性中包含info的元素 4. #footer id选择器，匹配所有id属性等于footer的元素 1234567* &#123; margin:0; padding:0; &#125;p &#123; font-size:2em; &#125;.info &#123; background:#ff0; &#125;p.info &#123; background:#ff0; &#125;p.info.error &#123; color:#900; font-weight:bold; &#125;#info &#123; background:#ff0; &#125;p#info &#123; background:#ff0; &#125; 多元素的组合选择器(这个蛮实用的) 序号 选择器 含义 5. E,F 多元素选择器，同时匹配所有E元素或F元素，E和F之间用逗号分隔 6. E F 后代元素选择器，匹配所有属于E元素后代的F元素，E和F之间用空格分隔 7. E &gt; F 子元素选择器，匹配所有E元素的子元素F 8. E + F 毗邻元素选择器，匹配所有紧随E元素之后的同级元素F 12345div p &#123; color:#f00; &#125;#nav li &#123; display:inline; &#125;#nav a &#123; font-weight:bold; &#125;div &gt; strong &#123; color:#f00; &#125;p + p &#123; color:#f00; &#125; CSS 2.1 属性选择器 序号 选择器 含义 9. E[att] 匹配所有具有att属性的E元素，不考虑它的值。（注意：E在此处可以省略，比如&quot;[cheacked]&quot;。以下同。） 10. E[att=val] 匹配所有att属性等于&quot;val&quot;的E元素 11. E[att~=val] 匹配所有att属性具有多个空格分隔的值、其中一个值等于&quot;val&quot;的E元素 12. E[att|=val] 匹配所有att属性具有多个连字号分隔（hyphen-separated）的值、其中一个值以&quot;val&quot;开头的E元素，主要用于lang属性，比如&quot;en&quot;、&quot;en-us&quot;、&quot;en-gb&quot;等等 12345p[title] &#123; color:#f00; &#125;div[class=error] &#123; color:#f00; &#125;td[headers~=col1] &#123; color:#f00; &#125;p[lang|=en] &#123; color:#f00; &#125;blockquote[class=quote][cite] &#123; color:#f00; &#125; CSS 2.1中的伪类 序号 选择器 含义 13. E:first-child 匹配父元素的第一个子元素 14. E:link 匹配所有未被点击的链接 15. E:visited 匹配所有已被点击的链接 16. E:active 匹配鼠标已经其上按下、还没有释放的E元素 17. E:hover 匹配鼠标悬停其上的E元素 18. E:focus 匹配获得当前焦点的E元素 19. E:lang(c) 匹配lang属性等于c的E元素 1234p:first-child &#123; font-style:italic; &#125;input[type=text]:focus &#123; color:#000; background:#ffe; &#125;input[type=text]:focus:hover &#123; background:#fff; &#125;q:lang(sv) &#123; quotes: "\201D" "\201D" "\2019" "\2019"; &#125; CSS 2.1中的伪元素 序号 选择器 含义 20. E:first-line 匹配E元素的第一行 21. E:first-letter 匹配E元素的第一个字母 22. E:before 在E元素之前插入生成的内容 23. E:after 在E元素之后插入生成的内容 1234567p:first-line &#123; font-weight:bold; color;#600; &#125;.preamble:first-letter &#123; font-size:1.5em; font-weight:bold; &#125;.cbb:before &#123; content:""; display:block; height:17px; width:18px; background:url(top.png) no-repeat 0 0; margin:0 0 0 -18px; &#125;a:link:after &#123; content: " (" attr(href) ") "; &#125; CSS 3的同级元素通用选择器 序号 选择器 含义 24. E ~ F 匹配任何在E元素之后的同级F元素 1p ~ ul &#123; background:#ff0; &#125; CSS 3 属性选择器 序号 选择器 含义 25. E[att^=&quot;val&quot;] 属性att的值以&quot;val&quot;开头的元素 26. E[att$=&quot;val&quot;] 属性att的值以&quot;val&quot;结尾的元素 27. E[att*=&quot;val&quot;] 属性att的值包含&quot;val&quot;字符串的元素 1div[id^="nav"] &#123; background:#ff0; &#125; CSS 3中与用户界面有关的伪类 序号 选择器 含义 28. E:enabled 匹配表单中激活的元素 29. E:disabled 匹配表单中禁用的元素 30. E:checked 匹配表单中被选中的radio（单选框）或checkbox（复选框）元素 31. E::selection 匹配用户当前选中的元素 1input[type="text"]:disabled &#123; background:#ddd; &#125; CSS 3中的结构性伪类(蛮实用的) 序号 选择器 含义 32. E:root 匹配文档的根元素，对于HTML文档，就是HTML元素 33. E:nth-child(n) 匹配其父元素的第n个子元素，第一个编号为1 34. E:nth-last-child(n) 匹配其父元素的倒数第n个子元素，第一个编号为1 35. E:nth-of-type(n) 与:nth-child()作用类似，但是仅匹配使用同种标签的元素 36. E:nth-last-of-type(n) 与:nth-last-child() 作用类似，但是仅匹配使用同种标签的元素 37. E:last-child 匹配父元素的最后一个子元素，等同于:nth-last-child(1) 38. E:first-of-type 匹配父元素下使用同种标签的第一个子元素，等同于:nth-of-type(1) 39. E:last-of-type 匹配父元素下使用同种标签的最后一个子元素，等同于:nth-last-of-type(1) 40. E:only-child 匹配父元素下仅有的一个子元素，等同于:first-child:last-child或 :nth-child(1):nth-last-child(1) 41. E:only-of-type 匹配父元素下使用同种标签的唯一一个子元素，等同于:first-of-type:last-of-type或 :nth-of-type(1):nth-last-of-type(1) 42. E:empty 匹配一个不包含任何子元素的元素，注意，文本节点也被看作子元素 12345678910p:nth-child(3) &#123; color:#f00; &#125;p:nth-child(odd) &#123; color:#f00; &#125;p:nth-child(even) &#123; color:#f00; &#125;p:nth-child(3n+0) &#123; color:#f00; &#125;p:nth-child(3n) &#123; color:#f00; &#125;tr:nth-child(2n+11) &#123; background:#ff0; &#125;tr:nth-last-child(2) &#123; background:#ff0; &#125;p:last-child &#123; background:#ff0; &#125;p:only-child &#123; background:#ff0; &#125;p:empty &#123; background:#ff0; &#125; CSS 3的反选伪类 序号 选择器 含义 43. E:not(s) 匹配不符合当前选择器的任何元素 1:not(p) &#123; border:1px solid #ccc; &#125; CSS 3中的 :target 伪类 序号 选择器 含义 44. E:target 匹配文档中特定&quot;id&quot;点击后的效果]]></content>
      <categories>
        <category>编程与生活</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[麦兜，幸福的麦兜]]></title>
    <url>%2Flife%2F%E9%BA%A6%E5%85%9C%E9%A5%AD%E5%AE%9D%E5%A5%87%E5%85%B5%2F</url>
    <content type="text"><![CDATA[这篇文章拖了好久。借此闲暇之时，写些自己的看法。 之前并未看过麦兜的其他片子，但是在高中的时候，经常看一些作文素材，会接触到许多的零零碎碎的世界之事，其中，麦兜也是这时候了解的。 似乎那是讲“麦兜之父”谢立文的故事。 印象中对于麦兜的记忆片段，似乎是麦兜成了宇航员，飞上了天空，也有麦兜妈妈的影像，只记得当时的场景很煽情，很催泪。 而这次的麦兜饭宝奇兵，不得不说，有笑点，有泪点，不过，终究是笑点更多，略带幻想的有丢丢励志的人类大战外星怪的搞怪动画。 影片开头，主要讲了外星怪物袭击地球，人类各种手段都无法战胜，甚至来自宇宙的扎肉超人都被打败。此怪兽，力大，体壮，能力强，无坚不摧，无法被战胜。 无奈的人类，只好寻求全世界的力量。最终麦兜的饭煲机器人成了人类的救星，和怪兽一起回到了怪兽的星球。拯救了地球。 全片极具恶搞意味。 扎肉超人的那句“s-o-o-r-y”以及被怪兽打回了家后面对家人的说辞；麦兜家乡邻里的言语交谈；麦兜最初那不切实际的各种创新想法；隐士高人的献身；机器人战斗之间的搞怪；怪兽的摇摆舞，高能臭气，无敌屎尿屁（。。。）；世界级富豪赤膊上阵造机器人；政府高官一心想用自己的机器人假意办比赛；等等。 各种普通人之间的温馨暖意，也有战斗双方的心怀恶意，还有理想梦想的闪烁耀眼，也有对于灾难的恶搞性表达。这些片段，各种各样的搞笑，实际有着不同的真实感情。终究还是人情，人心。 但是，打动我的，不只是这些并不流于表面的恶搞逗趣，而是片子很是重点描绘的感情。母子情，友情，以及一种有点略微浮夸的普世情怀（个人感受）。 而其中，主要让我感动的还是母子情。 毕竟，这种情感如何“浮夸”都不为过。 妈妈为了帮助儿子实现梦想，拼命地做鱼丸卖鱼丸那一段，还是很感动的。母亲作为一个普通人，想要赚到钱，而自己也只会做鱼丸，所以也就只能卖鱼丸，棒槌在肉上锤来锤去，漆黑的夜里，闪亮的灯点亮的不只是飞溅的汗水，还有一位作为母亲的伟大的灵魂。 再说说麦兜的饭煲，就是一个电饭煲，但是却有着极为出众的适应能力。可以自我供能——自己给自己做饭吃。（都是吃货）。而正是这种小强般的生命力，才使得他不断地战胜敌人，保护地球。 不过，编剧的脑洞还真大，电饭煲配洗衣机——饭煲机器人，操纵洗衣机。。。 这片子，大脑洞，大恶搞。 看的感觉还是蛮爽，有笑点，有泪点。 适合私人观看。]]></content>
      <categories>
        <category>电影与艺术</category>
      </categories>
      <tags>
        <tag>影视</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于近期爬虫学习的总结]]></title>
    <url>%2Flangs%2Fpython%2Fspyder_end%2F</url>
    <content type="text"><![CDATA[在之前的三篇文章中，我尝试了使用python爬虫实现的对于特定站点的《剑来》小说的爬取，对于豆瓣的短评的爬取，也有对于爬取的短评数据进行的词云展示，期间运用了不少的知识，现在是时间回顾一下。在此之后，我会再关注一些爬虫框架的使用，以及更多的爬虫的优化方法，争取做到尽量多的吸收新知识，巩固旧知识。 在参考文章爬虫（1）--- Python网络爬虫二三事的基础上，我写了这篇文章。 这篇文章主要的目的有两个，收集新知识，并用之丰富旧知识，巩固旧知识。 关于爬虫背后的（这一节是主要是http的概要，下一节是我的一些总结） 要想不限于代码表面，深入理解爬虫，就得需要了解一些关于网络的知识。 HTTP 协议 HTTP（Hypertext Transfer Protocol）是应用级协议，它适应了分布式超媒体协作系统对灵活性及速度的要求。它是一个一般的、无状态的、基于对象的协议。 可以参考的文章： 想要细致了解协议的可以查看： 中文 HTTP/1.0 RFC文档目录 深入理解HTTP协议（转） HTTP协议详解（真的很经典） HTTP请求方法大全&amp;HTTP请求头大全HTTP状态码大全HTTP Content-type 对照表 一些术语 请求（request）：HTTP的请求消息（在第五节定义） 响应（response）：HTTP的回应消息（在第六节定义） 资源（resource）：网络上可以用URI来标识的数据对象或服务。URI有许多名字，如WWW地址、通用文件标识（Universal Document Identifiers）、通用资源标识（Universal Resource Identifiers），以及最终的统一资源定位符（Uniform Resource Locators (URL)）和统一资源名（URN）。 实体（entity）：可被附在请求或回应消息中的特殊的表示法、数据资源的表示、服务资源的回应等，由实体标题（entity header）或实体主体（entity body）内容形式存在的元信息组成。 客户端（client）：指以发出请求为目的而建立连接的应用程序。 用户代理（user agent）：指初始化请求的客户端，如浏览器、编辑器、蜘蛛（web爬行机器人）或其它终端用户工具。用户代理请求标题域包含用户原始请求的信息，这可用于统计方面的用途。通过跟踪协议冲突、自动识别用户代理以避免特殊用户代理的局限性，从而做到更好的回应。虽然没有规定，用户代理应当在请求中包括此域。 服务器（server）：指接受连接，并通过发送回应来响应服务请求的应用程序。 代理（proxy）：同时扮演服务器及客户端角色的中间程序，用来为其它客户产生请求。请求经过变换，被传递到最终的目的服务器，在代理程序内部，请求或被处理，或被传递。代理必须在消息转发前对消息进行解释，而且如有必要还得重写消息。代理通常被用作经过防火墙的客户端出口，用以辅助处理用户代理所没实现的请求。 任何指定的程序都有能力同时做为客户端和服务器。我们在使用这个概念时，不是看程序功能上是否能实现客户及服务器，而是看程序在特定连接时段上扮演何种角色（客户或服务器）。同样，任何服务器可以扮演原始服务器、代理、网关、隧道等角色，行为的切换取决于每次请求的内容。 简单流程 HTTP协议是基于请求/回应机制的。客户端与服务器端建立连接后，以请求方法、URI、协议版本等方式向服务器端发出请求，该请求可跟随包含请求修饰符、客户信息、及可能的请求体（body）内容的MIME类型消息。服务器端通过状态队列（status line）来回应，内容包括消息的协议版本、成功或错误代码，也跟随着包含服务器信息、实体元信息及实体内容的MIME类型消息。 绝大多数HTTP通讯由用户代理进行初始化，并通过它来组装请求以获取存储在一些原始服务器上的资源。 一次HTTP操作称为一个事务，综上，其工作过程可分为四步： 首先客户机与服务器需要建立连接。只要单击某个超级链接，HTTP的工作开始。 建立连接后，客户机发送一个请求给服务器，请求方式的格式为：统一资源标识符（URL）、协议版本号，后边是MIME信息包括请求修饰符、客户机信息和可能的内容。 服务器接到请求后，给予相应的响应信息，其格式为一个状态行，包括信息的协议版本号、一个成功或错误的代码，后边是MIME信息包括服务器信息、实体信息和可能的内容。 客户端接收服务器所返回的信息通过浏览器显示在用户的显示屏上，然后客户机与服务器断开连接。 如果在以上过程中的某一步出现错误，那么产生错误的信息将返回到客户端，有显示屏输出。对于用户来说，这些过程是由HTTP自己完成的，用户只要用鼠标点击，等待信息显示就可以了。 HTTP 消息（HTTP Message） HTTP消息由客户端到服务器的请求和由服务器到客户端的回应组成。 HTTP-message = Simple-Request ; HTTP/0.9 messages | Simple-Response | Full-Request ; HTTP/1.0 messages | Full-Response 完整的请求（Full-Request）和完整的回应（Full-Response）都使用RFC822中实体传输部分规定的消息格式。两者的消息都可能包括标题域（headers，可选）、实体主体（entity body）。实体主体与标题间通过空行来分隔（即CRLF前没有内容的行）。 Full-Request = Request-Line *( General-Header | Request-Header | Entity-Header ) CRLF [ Entity-Body ] Full-Response = Status-Line *( General-Header | Response-Header | Entity-Header ) CRLF [ Entity-Body ] （想要了解更多，可以前往中文 HTTP/1.0 RFC文档目录 ） # 代码实现的流程 从我之前的代码中可以从一些方法中看出，我们利用urllib库，实际上完成了请求，并接受了响应。通过我们自己构造（例如添加headers）或者使用默认的请求信息，利用了urllib库的request模块的Request()方法构造请求，利用urlopen()方法接受响应返回的页面代码。 至于我们的爬虫工作的过程，在这里盗用(http://www.jianshu.com/p/0bfd0c48457f）一张图片： 爬虫是一个综合性的工具 在实现爬虫的过程中，为了实现我们的目的，我们借助了各种各样的工具。浏览器的开发者工具，正则表达式，以及python的各种功能库。可谓是无所不用其极。但是，对于这些工具，我们实际上用到的功能，目前来看，其实并不多，核心代码就是那点而已，所以说，抽离出汇总起来，日后重新使用，一旦对于这个工具不再熟悉，回过头来看这些小小的片段，总是会省下很多的时间。 所以，这篇文章的核心内容就要来了。 获取URL 这里可以借助浏览器的产看网页源代码，查看元素等开发者工具，且快捷键一般是F12。 获取页面及异常处理 常用的是利用urllib库。在python3中，没有了原来2中的urllib2，而是用urllib包含了。 主要是用urllib.request.Request()&amp;urllib.request.urlopen() urllib.request urllib is a package that collects several modules for working with URLs: urllib.request for opening and reading URLs urllib.error containing the exceptions raised by urllib.request urllib.parse for parsing URLs urllib.robotparser for parsing robots.txt files 12345678910111213141516171819202122232425262728293031323334import urllib.requestimport urllib.errorimport tracebackimport sysurl = "..."try: request = urllib.request.Request(url) html = urllib.request.urlopen(request).read().decode("")# 按情况解码 print(html) except urllib.error.URLError as error_1: if hasattr(error_1,"code"): print("URLError异常代码：") print(error_1.code) if hasattr(error_1,"reason"): print("URLError异常原因：") print(error_1.reason)except urllib.error.HTTPError as error_2: print("HTTPError异常概要：") print(error_2)except Exception as error_3: print("异常概要：") print(error_3) print("---------------------------") errorInfo = sys.exc_info() print("异常类型："+str(errorInfo[0])) print("异常信息或参数："+str(errorInfo[1])) print("调用栈信息的对象："+str(errorInfo[2])) print("已从堆栈中“辗转开解”的函数有关的信息："+str(traceback.print_exc()))作者：whenif链接：http://www.jianshu.com/p/0bfd0c48457f來源：简书著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 URLError 通常，URLError在没有网络连接(没有路由到特定服务器)，或者服务器不存在的情况下产生。 HTTPError 首先我们要明白服务器上每一个HTTP 应答对象response都包含一个数字“状态码”，该状态码表示HTTP协议所返回的响应的状态，这就是HTTPError。比如当产生“404 Not Found”的时候，便表示“没有找到对应页面”，可能是输错了URL地址，也可能IP被该网站屏蔽了，这时便要使用代理IP进行爬取数据。 两者关系 两者是父类与子类的关系，即 HTTPError是URLError的子类，HTTPError有异常状态码与异常原因，URLError没有异常状态码。所以，我们在处理的时候，不能使用URLError直接代替HTTPError。同时，Python中所有异常都是基类Exception的成员，所有异常都从此基类继承，而且都在exceptions模块中定义。如果要代替，必须要判断是否有状态码属性。 异常处理有还有else&amp;finally可以选择。 伪装浏览器 添加头信息。可以在浏览器的开发者工具中的网路选项卡中点击对应的html页面查看请求报文和相应报文信息。一般的，只需添加用户代理信息即可。 123456789101112131415161718import urllib.requesturl = 'http://www.baidu.com'# 构造方法1headers = &#123;'User-Agent': 'Mozilla/5.0 (Windows NT 6.3; Win64; x64; rv:55.0) Gecko/20100101 Firefox/55.0'&#125;request = urllib.request.Request(url, headers = headers)data = urllib.request.urlopen(request).read().decode('utf-8')# 构造方法2headers=("User-Agent", "Mozilla/5.0 (Windows NT 6.3; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.103 Safari/537.36") opener = urllib.request.build_opener()opener.addheaders = [headers]# # 打开方法1data = opener.open(url, timeout=3).read().decode('utf-8')# 打开方法2urllib.request.install_opener(opener)data = urllib.request.urlopen(url).read().decode('utf-8')print(data) 1class urllib.request.Request(url[, data][, headers][, origin_req_host][, unverifiable]) data 数据可以是指定要发送到服务器的附加数据的字符串，如果不需要这样的数据，则为None。目前HTTP请求是唯一使用数据的请求; 当提供数据参数时，HTTP请求将是POST而不是GET。 数据应该是标准的 application/x-www-form-urlencoded 格式。urllib.parse.urlencode()函数采用映射或2元组的序列，并以此格式返回一个字符串。 headers 应该是一个字典，并且将被视为使用每个键和值作为参数调用 add_header()。 这通常用于“欺骗”用户代理头，浏览器使用它来识别自己 - 一些HTTP服务器只允许来自普通浏览器的请求而不是脚本。 时间问题 超时重连 有时候网页请求太过频繁，会出现长时间没有响应的状态，这时候一般需要设置超时重连。下面是一个例子片段 123456789101112131415161718192021import urllib.requestimport socketurl = "..."NET_STATUS = Falsewhile not NET_STATUS: try: response = urllib.request.urlopen(url, data=None, timeout=3) html = response.read().decode('GBK') print('NET_STATUS is good') return html except socket.timeout: print('NET_STATUS is not good') NET_STATUS = False# 也可以直接设置全局超时进行捕获，用的还是`socket.timeout`异常import sockettimeout = 3socket.setdefaulttimeout(timeout) 线程延迟 线程推迟（单位为秒），避免请求太快。 12import timetime.sleep(3) 页面解析 目前掌握的方法是使用正则表达式和bs库。当然，之后会了解下XPath，这个也提供了一种搜索的思路。 正则匹配 这个用的函数并不多。有两种书写方式，面向对象和 12345678910import repattern = re.compile('[a-zA-Z]')result_list = pattern.findall('as3SiOPdj#@23awe')print(result_list)# re.search 扫描整个字符串并返回第一个成功的匹配。 searchObj = re.search( r'(.*) are (.*?) .*', "Cats are smarter than dogs", re.M|re.I)print(searchObj.group())# Cats are smarter than dogsprint(searchObj.group(1))# Catsprint(searchObj.groups())# ('Cats', 'smarter') python3正则表达式 beautifulsoup4 Python利用Beautiful Soup模块搜索内容详解 我个人感觉，这个库的使用，主要难点在于搜索时的麻烦。我觉得比较好用的是方法find()&amp;find_all()&amp;select()。 使用 find() 方法会从搜索结果中返回第一个匹配的内容，而 find_all() 方法则会返回所有匹配的项，返回列表。 select()中可以使用CSS选择器。很方便可以参考浏览器开发者工具。 1234567from bs4 import BeautifulSoup# 可以获取验证码图片地址并下载图片soup = BeautifulSoup(response_login, "html.parser")captchaAddr = soup.find('img', id='captcha_image')['src']request.urlretrieve(captchaAddr, "captcha.jpg")...totalnum = soup.select("div.mod-hd h2 span a")[0].get_text()[3:-2] 文件读写 12345678910# 要读取非UTF-8编码的文本文件，需要给open()函数传入encoding参数with open(filename, 'w+') as open_file: ...# 遇到有些编码不规范的文件，你可能会遇到UnicodeDecodeError，因为在文本文件中可能夹杂了一些非法编码的字符。遇到这种情况，open()函数还接收一个errors参数，表示如果遇到编码错误后如何处理。最简单的方式是直接忽略with open(filename, 'r', encoding='gbk', errors='ignore') as open_file: all_the_text = open_file.read([size]) list_of_all_the_lines = open_file.readlines() open_file.write(all_the_text) open_file.writelines(list_of_text_strings) 登录信息 我们构造好 POST 请求，这一旦发送过去, 就登陆上了服务器, 服务器就会发给我们 Cookies。继续保持登录状态时，就需要借助相关的库的方式，可以简化处理。 Cookies 是某些网站为了辨别用户身份、进行 session 跟踪而储存在用户本地终端上的数据(通常经过加密)。 12345678910111213141516171819202122232425from urllib import requestfrom urllib import parsefrom http import cookiejarmain_url = '...'formdata = &#123; # 看网站post页面需求 "form_email":"你的邮箱", "form_password":"你的密码", "source":"movie", "redir":"https://movie.douban.com/subject/26934346/", "login":"登录"&#125;user_agent = 'Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/27.0.1453.94 Safari/537.36'headers = &#123;'User-Agnet': user_agent, 'Connection': 'keep-alive'&#125;cookie = cookiejar.CookieJar()cookie_support = request.HTTPCookieProcessor(cookie)opener = request.build_opener(cookie_support)data = parse.urlencode(formdata).encode('utf-8')req_ligin = request.Request(url=main_url, data=data, headers=headers)html = opener.open(req_ligin).read().decode('utf-8')print(html) 代理 有一种反爬虫策略就是对IP进行封锁。所以我们有时需要设置代理。 原理：代理服务器原理如下图，利用代理服务器可以很好处理IP限制问题。 一般都是利用互联网上提供的一些免费代理IP进行爬取，而这些免费IP的质量残次不齐，出错是在所难免的，所以在使用之前我们要对其进行有效性测试。另外，对开源IP池有兴趣的同学可以学习Github上的开源项目：IPProxyPool。 123456789101112131415161718192021222324252627282930import urllib.requestdef use_proxy(url,proxy_addr,iHeaders,timeoutSec): ''' 功能：伪装成浏览器并使用代理IP防屏蔽 @url：目标URL @proxy_addr：代理IP地址 @iHeaders：浏览器头信息 @timeoutSec：超时设置（单位：秒） ''' proxy = urllib.request.ProxyHandler(&#123;"http":proxy_addr&#125;) opener = urllib.request.build_opener(proxy,urllib.request.HTTPHandler) urllib.request.install_opener(opener) try: req = urllib.request.Request(url,headers = iHeaders) #伪装为浏览器并封装request data = urllib.request.urlopen(req).read().decode("utf-8","ignore") except Exception as er: print("爬取时发生错误，具体如下：") print(er) return data url = "http://www.baidu.com"proxy_addr = "125.94.0.253:8080"iHeaders = &#123;"User-Agent":"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/49.0.2623.22 Safari/537.36 SE 2.X MetaSr 1.0"&#125;timeoutSec = 10data = use_proxy(url,proxy_addr,iHeaders,timeoutSec)print(len(data))作者：whenif链接：http://www.jianshu.com/p/0bfd0c48457f來源：简书著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 后续 后面我会在考虑学习多线程异或多进程改写之前的爬虫，研究研究前面引用的文章里的提到的一些我之前还未了解的技术，感觉要学的东西还是很多，快要开学了，自己的效率有点低，也不知道还能有多少时间给自己这样浪。]]></content>
      <categories>
        <category>编程与生活</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用豆瓣短评数据生成词云]]></title>
    <url>%2Flangs%2Fpython%2Fspyderforwordcloud%2F</url>
    <content type="text"><![CDATA[在之前的文章中，我们获得了豆瓣爬取的短评内容，汇总到了一个文件中，但是，没有被利用起来的数据是没有意义的。 前文提到，有一篇微信推文的关于词云制作的一个实践记录，准备照此试验一下。 思路分析 读文件 利用with open() as...将文件读进来。这里需要注意文件内容的大小。 分词 由于获取的是大量的短评文字，而制作词云需要的是各种词语，有了词，才能谈词云，所以目前第一步需求的就是讲短评内容拆分成一个个的中文词汇。 这里就用到了我所听过的一个库jieba，可以将中文语句拆解成一个个的词汇。这里是用的是lcut()方法，能将中文字符串拆解成一个列表，每项都是一个词。 清洗非中文 但是，我们在分析中，需要的就是中文文字，所以需要将非中文字符彻底清理，这里使用了正则表达式。短小精悍的一个模式[\u4e00-\u9fa5]+即可匹配。 使用正则表达式，我的习惯是现在网上的一些在线正则表达式工具上直接测试。其中oschina的不错，还给提供了一些例子。 在线正则表达式测试 这里是oschina的工具网站，做的很好。 工具分类索引 处理停词 由于这些词汇中，有很多词是没有实际分析价值的，所以我们需要利用一个停词文件来将不必要的词处理掉。 参考文章中，是利用pandas库汇总的方法read_csv()来处理停词文件。，利用一个isin()方法实现了停词。 聚合 词分开了，基本也处理干净了。接下来应该考虑制作词云的问题。 我们这里想要重点突出在所有评论中的重要的核心观点，为了实现这样的目的，我们使用了分词。 这似乎是一种有些“断章取义”的思路。借助词频的分布实现重点突出高词频内容的方式，来展现我们的词云。 所以现在我们需要做的事，就是处理词汇的聚合问题，统计词频而已。 参考文种中利用了类DataFrame的分组方法group()和聚合方法agg()。 关于这里，参考文章中在agg()中使用了一个显式的字典（可见文末参考文章），调用了numpy.size，但是似乎是这种用法将来会被移除，查了一些文章，说是可以这样用，就是不能自己定制字典了。 1FutureWarning: using a dict on a Series for aggregation is deprecated and will be removed in a future version 词云 这里使用了第三方库wordcloud。这个库在安装的时候，直接pip install wordcloud时，我出了问题，提示微软开发工具的问题，折腾了半天，最后还是直接在一个极为丰富的第三方库的集合站点上下载使用pip insatll了它的whl文件。 这下可以正常使用了。 同时，这里为了能够显示处理图片，使用了matplotlib.pyplot&amp;numpy来进行处理。 掩膜设置 由wordcloud项目主页README 了解，可以使用二值图像来设定掩膜(mask)。 出于提升数据的表现力，也出于学习的目的，这里使用了直接编写的rgb2gray()&amp;gray2bw()函数来实现真彩图像转换为二值图像的过程。获得了最终的二值图像掩膜。 这里开始我并不知道需要怎样的图像，看了给的示例代码，用的图片的是二值图像，才明白，白白浪费了好多时间。 而且，我的理解，由彩色转为二值图像，是必要经过灰度图像这个过程的。 关于matplotlib.pyplot的使用，网上都说，和matlab的语法很类似，以前了解过一点，所以看着例子中的imshow()，很自然的就想出了imread()，实现了图片的读取。 在查阅文档的过程中发现了一个有意思的地方。 文档 Return value is a numpy.array. For grayscale images, the return array is MxN. For RGB images, the return value is MxNx3. For RGBA images the return value is MxNx4. matplotlib can only read PNGs natively, but if PIL is installed, it will use it to load the image and return an array (if possible) which can be used with imshow(). Note, URL strings may not be compatible with PIL. Check the PIL documentation for more information. 我文中使用的是JPG图像，可见是调用了PIL处理。 而这里对于二值图像的获取，开始经历了一个误区。由于在网上搜索的时候，搜到的大多是利用PIL库的Image模块的open()&amp;convert()方法的处理，附加参数1，可以实现二值图像的转化，但是在这里使用，后面在使用词云的时候，会提示缺少属性，可见这里不适合这样处理。 词云设定 词云支持自定义字体，背景颜色，掩膜设置等等，可以直接在IDE中跳至源文件中查看。都有相关的介绍。 文末代码是一些参数的摘录。 词频选择 这里使用了刚才聚合排序好的数据，选择了前1000个词进行展示，并组合成字典，传入了词云的实例对象的方法fit_words()生成了词云。 词云展示 这里使用了matplotlib.pyplot的的几个函数，实现了图像的保存，显示，以及坐标轴的隐藏。 这里倒是有个小异或，有点分不清楚imshow()与show()了。两者从文档我也没看出个所以然来。不过他们有个最明显的区别就是后者依赖图形窗口，但是前者似乎不需要。 要是有明白的，还请大家留言或者发邮件给我。 完整代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990# -*- coding: utf-8 -*-"""Created on Thu Aug 17 16:31:35 2017@note: 为了便于阅读，将模块的引用就近安置了@author: lart"""# 读取事先爬取好的文件，由于文件较小，直接一次性读入。若文件较大，则最好分体积读入。with open('秘密森林的短评.txt', 'r', encoding='utf-8') as file: comments = file.readlines() comment = ''.join(comments)# 摘取中文字符，没有在下载时处理，正好保留原始数据。import repattern = re.compile(r'[\u4e00-\u9fa5]+')data = pattern.findall(comment)filted_comment = ''.join(data)# 分词import jiebaword = jieba.lcut(filted_comment)# 整理import pandas as pdwords_df = pd.DataFrame(&#123;'words': word&#125;)#停词相关设置。参数 quoting=3 全不引用stopwords = pd.read_csv( "stopwords.txt", index_col=False, quoting=3, sep="\t", names=['stopword'], encoding='utf-8' )words_df = words_df[~words_df.words.isin(stopwords.stopword)]# 聚合words_stat = words_df.groupby('words')['words'].agg(&#123;'size'&#125;)words_stat = words_stat.reset_index().sort_values("size", ascending=False)# 词云设置from wordcloud import WordCloudimport matplotlib.pyplot as pltimport numpy as npdef rgb2gray(rgb): return np.dot(rgb[...,:3], [0.299, 0.587, 0.114])def gray2bw(gray): for raw in range(len(gray)): for col in range(len(gray[raw])): gray[raw][col] = (0 if gray[raw][col]&gt;50 else 255) return grayimg = plt.imread('4.jpg')mask = rgb2gray(img)bw = gray2bw(mask)wordcloud = WordCloud( font_path="YaHei Consolas Hybrid.ttf", background_color="white", mask=bw, max_font_size=80 )# word_frequence 为字典类型，可以直接传入wordcloud.fit_words()word_frequence = &#123; x[0]:x[1] for x in words_stat.head(1000).values &#125;wordcloud = wordcloud.fit_words(word_frequence)# 存储显示plt.imsave('img.jpg', wordcloud)plt.subplot(131)plt.imshow(img)plt.axis("off")plt.subplot(132)plt.imshow(bw)plt.axis("off")plt.subplot(133)plt.imshow(wordcloud, interpolation='bilinear')plt.axis("off") 结果文件 使用的掩膜原图片： 秘密森林剧照 秘密森林剧照 输出图片 输出图片 IDE输出结果 这里写图片描述 停词文件 stopwords.txt 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293Parameters----------font_path : string Font path to the font that will be used (OTF or TTF). Defaults to DroidSansMono path on a Linux machine. If you are on another OS or don't have this font, you need to adjust this path.width : int (default=400) Width of the canvas.height : int (default=200) Height of the canvas.prefer_horizontal : float (default=0.90) The ratio of times to try horizontal fitting as opposed to vertical. If prefer_horizontal &lt; 1, the algorithm will try rotating the word if it doesn't fit. (There is currently no built-in way to get only vertical words.)mask : nd-array or None (default=None) If not None, gives a binary mask on where to draw words. If mask is not None, width and height will be ignored and the shape of mask will be used instead. All white (#FF or #FFFFFF) entries will be considerd "masked out" while other entries will be free to draw on. [This changed in the most recent version!]scale : float (default=1) Scaling between computation and drawing. For large word-cloud images, using scale instead of larger canvas size is significantly faster, but might lead to a coarser fit for the words.min_font_size : int (default=4) Smallest font size to use. Will stop when there is no more room in this size.font_step : int (default=1) Step size for the font. font_step &gt; 1 might speed up computation but give a worse fit.max_words : number (default=200) The maximum number of words.stopwords : set of strings or None The words that will be eliminated. If None, the build-in STOPWORDS list will be used.background_color : color value (default="black") Background color for the word cloud image.max_font_size : int or None (default=None) Maximum font size for the largest word. If None, height of the image is used.mode : string (default="RGB") Transparent background will be generated when mode is "RGBA" and background_color is None.relative_scaling : float (default=.5) Importance of relative word frequencies for font-size. With relative_scaling=0, only word-ranks are considered. With relative_scaling=1, a word that is twice as frequent will have twice the size. If you want to consider the word frequencies and not only their rank, relative_scaling around .5 often looks good. .. versionchanged: 2.0 Default is now 0.5.color_func : callable, default=None Callable with parameters word, font_size, position, orientation, font_path, random_state that returns a PIL color for each word. Overwrites "colormap". See colormap for specifying a matplotlib colormap instead.regexp : string or None (optional) Regular expression to split the input text into tokens in process_text. If None is specified, ``r"\w[\w']+"`` is used.collocations : bool, default=True Whether to include collocations (bigrams) of two words. .. versionadded: 2.0colormap : string or matplotlib colormap, default="viridis" Matplotlib colormap to randomly draw colors from for each word. Ignored if "color_func" is specified. .. versionadded: 2.0normalize_plurals : bool, default=True Whether to remove trailing 's' from words. If True and a word appears with and without a trailing 's', the one with trailing 's' is removed and its counts are added to the version without trailing 's' -- unless the word ends with 'ss'.]]></content>
      <categories>
        <category>编程与生活</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的第一个豆瓣短评爬虫]]></title>
    <url>%2Flangs%2Fpython%2Fspyderfordouban%2F</url>
    <content type="text"><![CDATA[豆瓣上有着大量的影视剧的评论，所以说，要是想要实现对广大人民群众的观点的分析，对一部片子的理解，综合来看大家的评论是很有必要的。而短评作为短小精干的快速评论入口，是值得一谈的。 所以先要实现对其的数据的爬取。 目前来看，基本内容是可以爬取的。最大的问题在于速度。后续考虑准备运用多线程的方式处理下。以及可以尝试其他提速的方法。 下面是这个程序的构思编写过程。 构思准备 爬取的思路，及反省与思考 盲目状态 最初，并不知道豆瓣对于未登陆用户的限制，盲目的爬取，看着评论文件，发现行数太少，也就是说评论内容太少，感觉不对劲。 我利用了即时打印写入内容的方式，发现，到了第十页左右的时候，出现无法获得页面内评论内容，思考了下后，试着将页面源代码打印出来，发现到了后面，就出现提示权限不足。我一下子知道了，是因为没有登录的原因。 登录 之前看过内容，明白这时候应该借助cookie的方式了。 但是又要处理验证码。而且，似乎初次登陆的时候并不需要验证码。为了方便，下面直接使用了存在验证码的方式。 由于开始不了解，不知道应该提交哪些信息，多方查找后，终于明白，就是在登录页面登陆后，打开浏览器的开发者工具里，查看里面的网络，注意关注里面的方法一列中的post所在行那项。在登陆点击后，随着页面的跳转，会出现一个post页面，点击后查看其参数，若是火狐的话有个专门的参数窗口，其中就有要提交的参数了。包括用户信息，还有登录跳转页面（redir）等等。 在最初，我直接将https://accounts.douban.com/login选作登录地址，当然也将从其登陆的信息复制了出来，但是发现登录到redir还可以，要是用opener.open()再登录'https://movie.douban.com/subject/26934346/comments?start=' + str(start) + '&amp;limit=20&amp;sort=new_score&amp;status=P' 这里构造的页面是登不上的。这里我也是测试了好久才发现的问题。具体原因我不清楚。可能是有哪些知识我是遗漏了的。 后来觉察到这一点后，我尝试使用现在的信息登录，如下。 12345678910main_url = 'https://accounts.douban.com/login?source=movie'formdata = &#123; "form_email":"你的邮箱", "form_password":"你的密码", "source":"movie", "redir":"https://movie.douban.com/subject/26934346/", "login":"登录"&#125;user_agent = r'Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/27.0.1453.94 Safari/537.36'headers = &#123;'User-Agnet': user_agent, 'Connection': 'keep-alive'&#125; 诶，竟然登上去了！ 关于验证码的纠结思考 由于豆瓣的验证码是登一次变一次的。所以在发生上面的问题时，在没有找到正确的处理办法之时，我怀疑是因为验证码，在我获取上一次验证码图片，并将验证信息输入到formdata这个提交信息的字典中后，再次使用request.Request(url=main_url, data=logingpostdata, headers=headers)与opener.open(req_ligin).read().decode('utf-8')的时候，会不会验证码发生了变化？而我提交的是刚才的验证码？ 又开始查资料，后来终于明白，这里提交的信息中指定了验证码的图片的captchaID，这样使得提交信息时候，返回来的验证码图片也就是这个，图片id是唯一的，当你自己修改了提交内容，豆瓣也会使用你提供的这个id来获取服务器里的验证码图片，所以保证了图片的一致。（这是我的理解，觉得有问题，或者更精确的理解的，欢迎留言） 使用库的考虑 BeautifulSoup， re 准备尝试下beautiful soup这个库，对于拆解html页面很便利。但是在实践中，还是可能会用到正则表达式re模块。可见，正则表达式还是很重要的。掌握基本可以查表使用时必须的。 在代码中可以看出，我对于该库的使用还是有些粗，不巧妙，还有待加强。 不过，今天尝试了下，用CSS选择器还是很方便的。select()方法，很方便，可以参考从浏览器开发者工具里选择元素对应的CSS选择器，很直接。 urllib.request，http.cookiejar 借鉴之前使用urllib.request的经验，尝试直接使用urllib.request.Request(url, headers=headers)与urllib.request.urlopen(request, data=None, timeout=3)发现，豆瓣的短评，最一开始还好，但是在爬取将近十多页的短评时，会报出Forbidden的异常，查询后得知，应该是豆瓣对于游客用户的限制，需要登录才可以。参考网上一些其他教程，可以使用设置cookie的方法来处理。 使用了cookiejar.CookieJar()声明对象，来保存cookie到了变量中。利用的request.HTTPCookieProcessor()来创建cookie处理器。利用request.build_opener()构造了一个 opener，后面利用opener.open()来打开直接网页或者处理请求。 socket 类似上一个爬虫里的设置，这里直接使用了全局的超时设定。 123import sockettimeout = 3socket.setdefaulttimeout(timeout) 限制三秒，超出就抛出socket.timeout异常。捕获后重新连接。 12345678# 超时重连state = Falsewhile not state: try: html = opener.open(url).read().decode('utf-8') state = True except socket.timeout: state = False time 为了防止爬取过快，设置了循环的延时。 123for ...: ... time.sleep(3) 完整代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117# -*- coding: utf-8 -*-"""Created on Thu Aug 17 16:31:35 2017@note: 为了便于阅读，将模块的引用就近安置了@author: lart"""# 用于生成短评页面网址的函数def MakeUrl(start): """make the next page's url""" url = 'https://movie.douban.com/subject/26934346/comments?start=' + str(start) + '&amp;limit=20&amp;sort=new_score&amp;status=P' return url# 登录页面信息main_url = 'https://accounts.douban.com/login?source=movie'formdata = &#123; "form_email":"你的邮箱", "form_password":"你的密码", "source":"movie", "redir":"https://movie.douban.com/subject/26934346/", "login":"登录"&#125;user_agent = r'Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/27.0.1453.94 Safari/537.36'headers = &#123;'User-Agnet': user_agent, 'Connection': 'keep-alive'&#125;# 保存cookies便于后续页面的保持登陆from urllib import requestfrom http import cookiejarcookie = cookiejar.CookieJar()cookie_support = request.HTTPCookieProcessor(cookie)opener = request.build_opener(cookie_support)# 编码信息，生成请求，打开页面获取内容from urllib import parselogingpostdata = parse.urlencode(formdata).encode('utf-8')req_ligin = request.Request(url=main_url, data=logingpostdata, headers=headers)response_login = opener.open(req_ligin).read().decode('utf-8')# 获取验证码图片地址from bs4 import BeautifulSouptry: soup = BeautifulSoup(response_login, "html.parser") captchaAddr = soup.find('img', id='captcha_image')['src'] # 匹配验证码id import re reCaptchaID = r'&lt;input type="hidden" name="captcha-id" value="(.*?)"/' captchaID = re.findall(reCaptchaID, response_login) # 下载验证码图片 request.urlretrieve(captchaAddr, "captcha.jpg") # 输入验证码并加入提交信息中，重新编码提交获得页面内容 captcha = input('please input the captcha:') formdata['captcha-solution'] = captcha formdata['captcha-id'] = captchaID[0] logingpostdata = parse.urlencode(formdata).encode('utf-8') req_ligin = request.Request(url=main_url, data=logingpostdata, headers=headers) response_login = opener.open(req_ligin).read().decode('utf-8')finally: # 获得页面评论文字 soup = BeautifulSoup(response_login, "html.parser") totalnum = soup.select("div.mod-hd h2 span a")[0].get_text()[3:-2] # 计算出页数和最后一页的评论数 pagenum = int(totalnum) // 20 commentnum = int(totalnum) % 20 print(pagenum, commentnum) # 设置等待时间，避免爬取太快 import time # 用于在超时的时候抛出异常，便于捕获重连 import socket timeout = 3 socket.setdefaulttimeout(timeout) # 追加写文件的方式打开文件 with open('秘密森林的短评.txt', 'w+', encoding='utf-8') as file: # 循环爬取内容 for item in range(pagenum): print('第' + str(item) + '页') start = item * 20 url = MakeUrl(start) # 超时重连 state = False while not state: try: html = opener.open(url).read().decode('utf-8') state = True except socket.timeout: state = False # 获得评论内容 soup = BeautifulSoup(html, "html.parser") comments = soup.select("div.comment &gt; p") for text in comments: file.write(text.get_text().split()[0] + '\n') print(text.get_text()) limit_num = 0 if item == pagenum - 1: limit_num =+ 1 if limit_num == commentnum: break time.sleep(3) print('采集写入完毕') 结果 可见至少也有9200条评论，不管是否有所遗漏，基数已经基本无差。 后续处理 数据已经到手，怎样玩耍就看自己的想法了，近期看到了一篇文章,讲了利用词频制作词云，生成图片，有点意思，决定模仿试试。 Python 爬虫实践：《战狼2》豆瓣影评分析 github:amueller/word_cloud]]></content>
      <categories>
        <category>编程与生活</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[纪念我的第一个完整的小说爬虫]]></title>
    <url>%2Flangs%2Fpython%2Fspyderfornovel%2F</url>
    <content type="text"><![CDATA[纪念我的第一个爬虫程序，一共写了三个白天，其中有两个上午没有看，中途遇到了各种奇怪的问题，伴随着他们的解决，对于一些基本的操作也弄清楚了。果然，对于这些东西的最号的学习方式，就是在使用中学习，通过解决问题的方式来搞定这些知识。按需索取，才能更有针对性。 大体记录下整个过程。 准备构思 出于对于python的热爱，想要尝试一些练手的项目，但是不论是看书，还是直接尝试别人的项目，到最后都会沦为不停地复制粘贴...最实际的就是自己来上手亲自写代码。思路都是一样的，但是具体的实现还得靠自己。 以前的复制粘贴给我的帮助也就是告诉了我大致的流程。 确定目标网址 目标网址是关键。我梦想中的爬虫是那种偏向于更智能的，直接给他一个想要获取的关键词，一步步的流程直接自己完成，可以自己给定范围，也可以直接爬取整个互联网或者更实际的就是整个百度上的内容，但是，目前就我而言，见到的爬虫，都是给定目标网址，通过目标页面上的内容进一步执行规定的操作，所以现在来看，我们在写爬虫之前，需要确定一个基准页面，这个是需要我们事先制定的。在考虑我们需要程序完成怎样的功能，获取页面文本还是相关链接内容还是其他的目的。 我这个程序想要获取的是《剑来》小说，把各个章节的内容爬去下载存储到文件里。 编程只是实现目的的工具。 所以重点是分析我们的需求。 获取小说目录页面是基本。这里有各个章节的链接，标题等等内容。这是我们需要的。 有了各个章节的链接，就需要进入其中获得各个章节的内容。 所以，我们需要获得页面内容，需要从中获得目标内容。 所以使用 urllib.request，re 库。 前者用来获得网页内容，后者获得目标信息。 headers 直接使用urllib.request的urlopen()，read()方法是会报类似以下的错误（这里是网上查找过来的，都是类似的）： raise HTTPError(req.get_full_url(), code, msg, hdrs, fp) HTTPError: HTTP Error 403: Forbidden 出现urllib2.HTTPError: HTTP Error 403: Forbidden错误是由于网站禁止爬虫，可以在请求加上头信息，伪装成浏览器。 headers = {&#39;User-Agent&#39;: &#39;Mozilla/5.0 (Windows NT 6.3; Win64; x64; rv:55.0) Gecko/20100101 Firefox/55.0&#39;} request = url_req.Request(url, headers=headers) response = url_req.urlopen(request, data=None, timeout=3) html = response.read().decode(&#39;GBK&#39;) 注意：这里存在两个容易出问题的地方。 编码：编码问题是使用爬虫中有时候会很头痛的问题，由于网页源代码编码格式不明确，所以这里尝试了许久。 使用chardet库的detect()方法可以检测字节字符串的编码。所以直接检测这里的html(先不要解码)。输出的是GB2312，但是在后面页面的爬取中，会出现提示有的字符的编码异常，所以这里采取了比其范围更广的中文字符集GBK，解决了这个问题。 设置超时范围：由于频繁的获取网页内容，目标网站有时候会出现没有响应的问题。 （这个问题可以见我在CSDN上的提问：关于python爬虫程序中途停止的问题） 于是我采取了捕获 urlopen()的socket.timeout异常，并在出现异常的时候再循环访问，直到获得目标页面。 获得目标内容 这里使用的是正则表达式。re模块。这里的使用并不复杂。 首先需要一个模式字符串。以re.I指定忽略大小写，编译后的对象拥有本身匹配的方法，这里使用的是findall()，返回一个所有结果组成的列表。可以及时返回输出其内容，进而选择合适的部分进行处理。 python 正则表达式 通过查看相关的符号，这里使用(.+?)来实现匹配非贪婪模式(尽量少的)下任意无限字符，对之使用()，进而匹配括号内的模式。 文件写入 使用with open() as file:，进而可以处理文件。并且可以自动执行打开和关闭文件，更为便捷安全。 with open(findall_title[0] + &#39;.txt&#39;, &#39;w+&#39;, encoding=&#39;utf-8&#39;) as open_file: 这里也要注意编码的问题，指定utf-8。会避免一些问题。 这里使用w+模式，追加写文件。 完整代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081# -*- coding: utf-8 -*-"""Created on Fri Aug 11 16:31:42 2017@author: lart"""import urllib.request as url_reqimport re, socket, timedef r_o_html(url): print('r_o_html begin') headers = &#123;'User-Agent': 'Mozilla/5.0 (Windows NT 6.3; Win64; x64; rv:55.0) Gecko/20100101 Firefox/55.0'&#125; request = url_req.Request(url, headers=headers) NET_STATUS = False while not NET_STATUS: try: response = url_req.urlopen(request, data=None, timeout=3) html = response.read().decode('GBK') print('NET_STATUS is good') print('r_o_html end') return html except socket.timeout: print('NET_STATUS is not good') NET_STATUS = Falsedef re_findall(re_string, operation, html): print('re_findall begin') pattern = re.compile(re_string, re.I) if operation == 'findall': result = pattern.findall(html) else: print('this operation is invalid') exit(-1) print('re_findall end') return resultif __name__ == '__main__': url_base = 'http://www.7kankan.la/book/1/' html = r_o_html(url_base) findall_title = re_findall(r'&lt;title&gt;(.+?)&lt;/title&gt;', 'findall', html) findall_chapter = re_findall(r'&lt;dd class="col-md-3"&gt;&lt;a href=[\',"](.+?)[\',"] title=[\',"](.+?)[\',"]&gt;', 'findall', html) with open(findall_title[0] + '.txt', 'w+', encoding='utf-8') as open_file: print('article文件打开', findall_chapter) for i in range(len(findall_chapter)): print('第' + str(i) + '章') open_file.write('\n\n\t' + findall_chapter[i][1] + '\n --------------------------------------------------------------------- \n') url_chapter = url_base + findall_chapter[i][0] html_chapter = r_o_html(url_chapter) findall_article = re_findall(r'&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;(.+?)&lt;br /&gt;', 'findall', html_chapter) findall_article_next = findall_chapter[i][0].replace('.html', '_2.html') url_nextchapter = url_base + findall_article_next html_nextchapter = r_o_html(url_nextchapter) if html_nextchapter: findall_article.extend(re_findall(r'&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;(.+?)&lt;br /&gt;', 'findall', html_nextchapter)) for text in findall_article: open_file.write(text + '\n') time.sleep(1) print('文件写入完毕')]]></content>
      <categories>
        <category>编程与生活</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GitHub入门]]></title>
    <url>%2Fbooks%2FGitHub%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[代码管理方式——集中与分散 集中型 以 Subversion 为代表的集中型，所示将仓库集中存放在服务器之中，所以只存在一个仓库。这就是为什么这种版本管理系统会被称作集中型。 集中型将所有数据集中存放在服务器当中，有便于管理的优点。但是一旦开发者所处的环境不能连接服务器，就无法获取最新的源代码，开发也就几乎无法进行。服务器宕机时也是同样的道理，而且万一服务器故障导致数据消失，恐怕开发者就再也见不到最新的源代码了。 分散型 GitHub 将仓库 Fork 给了每一个用户。Fork 就是将 GitHub 的某个特定仓库复制到自己的账户下。Fork 出的仓库与原仓库是两个不同的仓库，开发者可以随意编辑。 分散型拥有多个仓库，相对而言稍显复杂。不过，由于本地的开发环境中就有仓库，所以开发者不必连接远程仓库就可以进行开发。 GitHub相关 快捷键 在 GitHub 中，很多页面都可以使用键盘快捷键。在各个页面按下 shift ＋ / 都可以打开键盘快捷键一览表，查看当前页面的快捷键。 Explore 从各个角度介绍 GitHub 上的热门软件。 GitHub 公司特别介绍的软件（附开发者制作的视频） 按语言筛选本日 / 周 / 月的热门仓库 / 开发者 Gist Gist 功能主要用于管理及发布一些没必要保存在仓库中的代码，比如小的代码片段等。系统会自动管理更新历史，并且提供了 Fork 功能。在 Gist 上添加的代码示例可以嵌入博客中。当然，如果选择了语言，还会自动添加语法高亮。 Blog 这是到 GitHub 公司官方博客的超链接，GitHub 公司会在上面发布通知。新功能的通知、新入职员工的介绍、drinkup 聚会的信息等都会在上面定期发布。 github上的交流： GitHub 中可使用的描述方法并不止“@ 用户名”一种。 输入“@ 组织名”可以让属于该 Organization（组织）的所有成员收到通知 7。输入“@ 团队名”可以让该团队的所有成员收到通知。这就是同时向多人发送通知的方法。 输入“# 编号”，会连接到该仓库所对应的 Issue 编号。输入“用户名 / 仓库名 # 编号”则可以连接到指定仓库所对应的 Issue 编号。只要按照这类特定格式书写便会自动创建链接。 只要将感兴趣的仓库添加至 Watch 中，就可以在 News Feed 查 看该仓库的相关信息。 News Feed 显示当前已 Follow 的用户和已 Watch 的项目的活动信息，用户可以在这里查看最新动向。将右上角 RSS 标志的 URL 添加到 RSS 阅读器中，还可以通过 RSS 查看。 Issues 在这里可以查看用户拥有权限的仓库或分配给自己的 Issue。当用户同时进行多个项目时，可以在这里一并查看 Issue。 Broadcast 主要用于接收 GitHub 公司发来的通知或使用技巧的小贴士。 Your Repositories 按更新时间顺序显示用户的仓库。标有钥匙图案的是非公开仓库，标有类似字母 Y 图案的是用户 Fork 过的仓库。 Public contributions 一格表示一天，记录当日用户对拥有读取权限的仓库的大致贡献度。贡献度的衡量标准包括发送 Pull Request 的次数、写 Issue 的次数、进行提交的次数等。颜色越深代表贡献度越高。 Public Activity 从这里可以了解到该用户平常都在 GitHub 上做些什么。比如查看一下崇拜已久的程序员的公开活动，就可以知道他现在关注些什么，或者正在热心于开发些什么。 Pull Requests 在 Pull Requests 中可以列表查看并管理 Pull Request。代码的更改和讨论都可以在这里进行。旁边显示的数字表示尚未 Close 的 Pull Request的数量。 Pulse 显示该仓库最近的活动信息。该仓库中的软件是无人问津，还是在火热地开发之中，从这里可以一目了然。 Graphs 以图表形式显示该仓库的各项指标。让用户轻松了解该仓库的活动倾向。 Clone in Desktop 启动 GitHub 专用的客户端应用程序并进行 clone。 releases 显示仓库的标签（Tag）列表。同时可以将标签加入时的文件以归档形式（ZIP、tar.gz）下载到本地。软件在版本升级时一般都会打标签，如果需要特定版本的文件，可以从这里寻找。 Compare &amp; review 可以查看当前显示的分支与其他分支的差别，以便进行审查。点击这个按钮，会出现一个页面让用户选择比较对象。 行链接 文件内容的左侧会显示该文件的行号。假如我们点击第 10 行的行号，这一行就会被高亮标记为黄色，同时 URL 末尾会自动添加“#L10”。使用这个 URL，程序员们在交流时，就可以将讨论明确指向某一行。另外，如果将“#L10”改成“#L10-15”，则会标记该文件的第10～15 行。 在仓库页面试着按下键盘的 t 键，然后输入要找的目录或文件的部分名称。筛选器会在仓库的目录和文件中进行筛选，搜索出您要找的文件。 URL使用技巧 https://github.com/rails/rails/compare/4-0-stable...3-2-stable 这样，就可以查看两个分支间的差别。 https://github.com/rails/rails/compare/master@{7.day.ago}...master 查看 master 分支在最近 7 天内的差别，支持day，week，month，year。如果差别过大则不会列出所有提交，只显示最近的一部分。 https://github.com/rails/rails/compare/master@{2013-01-01}...master 查看 master 分支 2013 年 1 月 1 日与现在的区别。但是如果指定日期与现在的差别过大，或者指定日期过于久远，则无法显示。 Issue 用于 BUG 报告、功能添加、方向性讨论等，将这些以 Issue 形式进行管理。Pull Request 时也会创建 Issue。旁边显示的数字是当前处于Open 状态的 Issue 数。 在软件开发过程中，开发者们为了跟踪 BUG 及进行软件相关讨论，进而方便管理，创建了 Issue。管理 Issue 的系统称为 BTS（Bug Tracking System，BUG 跟踪系统）。当今具有代表性的 BTS 有 Redmine，Trac，Bugzilla等。GitHub 也为自身加入了 BTS 的功能。 支持markdown语法 支持指定语法时代码高亮 支持拖拽添加图片 支持添加标签整理 Issue 支持添加里程碑来管理 Issue（类似于进度条的一个东西） CONTRIBUTING.md 在描述 Issue 时，常常会看到贡献规范的链接。 在该仓库的根目录下添加 CONTRIBUTING.md 文件后该链接就 会显示出来。规范的内容一般包括报告时Issue的描述方法、Pull Request 时的规则或要求、许可证的相关信息等。为了在开源项目开发中能与其他人和谐相处，请务必在贡献之前仔细阅读这些规范。 Tasklist语法 使用 GFM 的一项独有功能，那就是 Tasklist 语法。 1234# 本月要做的任务- [ ] 完成图片- [x] 完成部署工具的设置- [ ] 实现抽签功能 提交与Issue的交互 在 Issue 一览表中我们可以看到，每一个 Issue 标题的下面都分配了诸如“#24”的编号。只要在提交信息的描述中加入“#24”，就能在 Issue 中显示该提交的相关信息，使关联的提交一目了然。这里只需轻轻点击一下便可以显示相应提交的具体内容，在代码审查时省去了从大量提交日志中搜索相应提交的麻烦，非常方便。 如果一个处于 Open 状态的 Issue 已经处理完毕，只要在该提交中以下列任意一种格式描述提交信息，对应的 Issue 就会被 Close。 fix #24 fixes #24 fixed #24 close #24 closes #24 closed #24 resolve #24 resolves #24 resolved #24 Issue与Pull Request 在 GitHub 上，如果给 Issue 添加源代码，它就会变成我们马上要讲到的 Pull Request。Issue 与 Pull Request 的编号相互通用，通过 GitHub的 API 可以将特定的 Issue 转换为 Pull Request，能够完成这一操作的是 hub 命令。 Pull Requests 显示用户已进行过的 Pull Request。通过这里，开发者可以很方便地追踪 Pull Request 的后续情况。 Pull Request 是用户修改代码后向对方仓库发送采纳请求的功能。在列表中点击特定的 Pull Request 就会进入详细页面。页面上方显示着这次是从谁的哪个分支向谁的哪个分支发送了 Pull Request。 链接妙用 假设 Pull…Request 的 URL 如下所示。 https://github.com/用户名/仓库名/pull/28 如果想获取 diff 格式的文件，只要像下面这样在 URL 末尾 添加 .diff 即可。 https://github.com/用户名/仓库名/pull/28.diff 同 理， 想 要 patch 格 式 的 文 件， 只 需 要 在 URL 末 尾 添加 .patch 即可。 https://github.com/用户名/仓库名/pull/28.patch Conversation 可以查看与当前 Pull Request 相关的所有评论以及提交的历史记录。提交日志的右侧有该提交的哈希值，点击链接即可确认相应提交的详细信息。 可以使用R键快速引用选中的评论。 Commits 在 Commits 标签页中，按时间顺序列表显示了与当前 Pull Request相关的提交。标签上的数字为提交的次数。每个提交右侧的哈希值可以连接到该提交的代码。 在评论中输入“:”（冒号）便会启动表情自动补全功能。只要输入几个与该表情相关的字母，系统就会为您筛选自动补全的对象。选择想要的表情，其相应代码（前后都有冒号的字符串）便会插入到文本框中。 （请登录 http://www.emoji - cheat - sheet.com/ 查找可使用的表情） Files Changed Files Changed 标签页中可以查看当前 Pull Request 更改的文件内容以及前后差别。标签上的数字表示新建及被更改的文件数。默认情况下系统会将空格的不同也高亮显示，所以在空格有改动的情况下会难以阅读。这时只要在 URL 的末尾添加“?w=1”就可以不显示空格的差别。将鼠标指针放到被更改行行号的左侧，我们会看到一个加号。点击这个加号可以在代码中插入评论。这样，评论是针对哪行代码的就一目了然了。 Wiki Wiki 是一种比 HTML 语法更简单的页面描述功能。常用于记录开发者之间应该共享的信息或软件文档。数字表示当前 Wiki 的页面数量。所有 有权限的人都可以对文章进行修改，所以比较适合多人共同编写文章的情况。创建、编辑文档时不必另外启动软件，用起来十分方便，非常适合用来针对更新频率较高的软件进行文档等信息方面的汇总。一般情况下，Wiki 中记载着软件相关的 FAQ、文档、代码示例及解说等信息。 支持GFM。 Wiki 功能本身的数据也在 Git 中进行管理。 用户能够通过 clone操作获取 Wiki 仓库，然后在本地创建、编辑页面，进行提交再 push，便可以完成对 Wiki 的创建及编辑工作。 在 Pages 标签页中可以列表查看 Wiki 页面。 在 History 标签页中可以查看 Wiki 的修改历史记录。 所有 Wiki 页面都可以显示侧边栏。 做法很简单，只要创建名为“_sidebar”的页面即可。_sidebar 页不会显示在 Pages 的页面一览中。在编辑各页面时页面下部会附加 Sidebar 段，用户可以在这里编辑侧边栏的内容。 Graphs 在 Graphs 页中，可以通过 4 种图表查看该仓库的相关统计信息。 Code Frequency Code Frequency 中显示了该仓库中代码行数的增加量和删除量。一款优秀的软件并不会一味地增加代码，在经过重构之后，代码量往往会降低。 Punchcard 从 Punchcard 的图中我们可以直观地掌握一周内每天何时收到的提交最多。黑色圆越大，表示提交越频繁。仓库的关键人物往往会出现在提交频率高的时间段，因此用户发送的 Pull Request 最有可能在这段时间内被处理。大致了解时间规律，将有助于各位把握好发送 Pull Request 以及等待回复的时间点。另外，该软件的开发是集中在早上还是晚上，从这张图中也可一目了然。 Network 以图表形式显示包括克隆仓库在内的所有分支的提交。从图上可以直观地看出每个人做了多少工作。将鼠标指针停留在表中提交或合并的点上，可以查看相应的参考内容。 Settings 关于仓库的设置。 GitHub Pages GitHub 有一个名为 GitHub Pages 的仓库，用户可以利用该仓库中的资料创建 Web 页，用来发布仓库中软件的相关信息。如果已经创建过GitHub Pages，则会显示相应 URL。点击 Automatic Page Generator 即可以自动创建 GitHub Pages。 Collaborators 用户主要在这里设置仓库的访问权限。如果仓库隶属于个人账户，那么可以添加 GitHub 的用户名，赋予该用户直接读写仓库的权限。不过，如果仓库隶属于 Organization 账户，则需要像所示的那样先创建 Team，然后赋予该 Team 读写仓库的权限。像这样使用 Organization 账户可以高效地设置仓库权限，在公司等多人共同进行开发的组织中，建议使用 Organization 账户。 Webhooks &amp; Services 在这个页面中，用户可以添加 Hook 让 GitHub 仓库与其他服务集成。通过 Add webhook 可以添加用户自己的 webhook。通过 Configureservices 则可以从 GitHub 事先列出的可以集成的服务中进行选择。能与GitHub 集成的服务非常多，其中还包括邮件及 IRC 等社交服务。 Deploy Keys 在这个页面中，用户可以添加用于部署的公开密钥，允许以只读方式访问仓库。设置公开密钥后，用户可以使用私有密钥通过 ssh 协议 clone 仓库。要注意的是，这里添加的公开密钥·私有密钥对无法再添加到其他仓库。使用 Deploy Keys 功能时，需要给每个仓库赋予不同的密钥对。 Notifications 每当创建 Issue、收到评论、创建 Pull Request 等情况发生时，我们就会在 Notifications 中收到通知。 其他功能 GitHub Pages GitHub Pages 主要用于在 GitHub 上托管静态 HTML，以便发布项目的 Web 页。可以绑定独立域名。常被使用为静态博客。 GitHub Enterprise GitHub Enterprise 专为那些无法将源代码放到公司之外的企业设计。这项服务可以以虚拟机的形式提供 GitHub。 GitHub API GitHub 面向开发者公开了 API。 Gist Gist 是一款简单的 Web 应用程序，常被开发者们用来共享示例代码和错误信息。它使用JavaScript 编写的 Ace 编辑器，只需打开浏览器便可编写简单代码。另外，Gist 中的文档都在版本管理系统的管理之下，用户可以放心编辑。而且由于其版本历史记录保管在 Git 仓库中，所以还可以通过clone 操作将 Gist 获取至本地。共享 Gist 的人之间能够互相添加评论，所有交流都会被记录下来。Gist 支持多种语言的语法高亮，可以大幅增强代码可读性。可以说，这一工具就是专为程序员设计的。]]></content>
      <categories>
        <category>编程与生活</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git使用]]></title>
    <url>%2Ftools%2FGit%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[初始设置本地Git 首先来设置使用 Git 时的姓名和邮箱地址。名字请用英文输入。 $ git config --global user.name &quot;Firstname Lastname&quot; $ git config --global user.email &quot;your_email@example.com&quot; 这个命令，会在“~/.gitconfig”中以如下形式输出设置文件。 [user] name = Firstname Lastname email = your_email@example.com 想更改这些信息时，可以直接编辑这个设置文件。这里设置的姓名和邮箱地址会用在 Git 的 提交日志中。由于在 GitHub 上公开仓库时，这里的姓名和邮箱地址也会随着提交日志一同被公开，所以请不要使用不便公开的隐私信息。 将 color.ui 设置为 auto 可以让命令的输出拥有更高的可读性。 $ git config --global color.ui auto “~/.gitconfig”中会增加下面一行。 [color] ui = auto 这样一来，各种命令的输出就会变得更容易分辨。 注意：下面大多数命令是在Win下 git bash 中使用，当然，linux终端也可以使用。 申请GitHub账号及相关设置 设置SSH Key GitHub 上连接已有仓库时的认证，是通过使用了 SSH 的公开密钥认证方式进行的。现在让我们来创建公开密钥认证所需的 SSH Key，并将其添加至 GitHub。 在 Git bash 运行下面的命令创建 SSH Key。 $ ssh-keygen -t rsa -C &quot;your_email@example.com&quot; Generating public/private rsa key pair. Enter file in which to save the key (/Users/your_user_directory/.ssh/id_rsa): 按回车键 Enter passphrase (empty for no passphrase): 输入密码 Enter same passphrase again: 再次输入密码 your_email@example.com的部分请改成您在创建账户时用的邮箱地址。密码需要在认证时输入，请选择复杂度高并且容易记忆的组合。输入密码后会出现提示已经创建密匙的提示，并告诉存储位置以及相关信息。其中，id_rsa 文件是私有密钥，id_rsa.pub 是公开密钥。 在 GitHub 中添加公开密钥（Add SSH Key），今后就可以用私有密钥进行认证了。 在 Title 中输入适当的密钥名称。Key 部分使用 id_rsa.pub 文件里的内容。id_rsa.pub 的内容可以用如下方法查看。 $ cat ~/.ssh/id_rsa.pub ssh-rsa 公开密钥的内容 your_email@example.com 添加后，账户邮箱会收到邮件提示。可以使用如下命令测试用手中的私人密钥与 GitHub 进行认证和 通信。 $ ssh -T git@github.com 若是出现 The authenticity of host &#39;github.com (207.97.227.239)&#39; can&#39;t be established. RSA key fingerprint is fingerprint值 . Are you sure you want to continue connecting (yes/no)? 输入yes 出现如下结果即为成功。 Hi hirocastest! You&#39;ve successfully authenticated, but GitHub does not provide shell access. 创建新仓库需要注意的细节 Initialize this repository with a README 在 Initialize this repository with a README 选项上打钩，随后GitHub 会自动初始化仓库并设置 README 文件，让用户可以立刻clone 这个仓库。如果想向 GitHub 添加手中已有的 Git 仓库，建议不要勾选，直接手动 push。 https://github.com/用户名/Hello-Word 是刚刚创建的仓库的页面。 .gitignore 正如其名，这个设定会帮我们把不需要在Git仓库中进行版本管理的文件记录在 .gitignore 文件中，省去了每次根据框架进行设置的麻烦。 GitHub Flavored Markdown 在 GitHub 上进行交流时用到的 Issue、评论、Wiki，都可以用 Markdown 语法表述，从而进行标记。准确地说应该是 GitHub Flavored Markdown（GFM）语法。该语法虽然是 GitHub 在 Markdown 语法基础上扩充而来的，但一般情况下只要按照原本的 Markdown 语法进行描述就可以。 简单试验对已有仓库的操作 clone 将代码下载到了本地以仓库名作为文件夹名的文件夹中，但是与直接下载不同。 $ git clone git@github.com:hirocastest/Hello-World.git Cloning into &#39;Hello-World&#39;... remote: Counting objects: 3, done. remote: Total 3 (delta 0), reused 0 (delta 0) Receiving objects: 100% (3/3), done. $ cd Hello-World 这里会要求输入 GitHub 上设置的公开密钥的密码。认证成功后，仓库便会被 clone 至仓库名后的目录中。将想要公开的代码提交至这个仓库再 push 到 GitHub 的仓库中，代码便会被公开。 如果之前并未设置密码，那么这里也就不用输入。 添加自己的文件 本地文件想要加入，需要先加到本地仓库。只有添加到其中，才能实现跟踪管理。 这里我们编写一个 hello_world.php 文件，用来输出“Hello World!”。 由于 hello_word.php 还没有添加至 Git 仓库，所以显示为 Untracked files。 $ git status # On branch master # Untracked files: # (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed) # # hello_world.php nothing added to commit but untracked files present (use &quot;git add&quot; to track) 添加到本地仓库，这样一来，这个文件就进入了版本管理系统的管理之下。今后的更改管理都交由 Git 进行。通过 git add命令将文件加入暂存区，再通过 git commit 命令附加信息并提交。 $ git add hello_world.php $ git commit -m &quot;Add hello world script by php&quot; [master d23b909] Add hello world script by php 1 file changed, 3 insertions(+) create mode 100644 hello_world.php 添加成功后，可以通过 git log 命令查看提交日志。 $ git log commit d23b909caad5d49a281480e6683ce3855087a5da Author: 你的信息 Date: 你的时间 Add hello world script by php 关于许可：实际使用时，只需将 LICENSE 文件加入仓库，并在README.md 文件中声明使用了何种许可协议即可。使用没有声明许可协议的软件时，以防万一最好直接联系著作者。 push 之后只要执行 push，GitHub 上的仓库就会被更新。 $ git push Counting objects: 4, done. Delta compression using up to 4 threads. Compressing objects: 100% (2/2), done. Writing objects: 100% (3/3), 328 bytes, done. Total 3 (delta 0), reused 0 (delta 0) To git@github.com:hirocastest/Hello-World.git 46ff713..d23b909 master -&gt; master 本地新仓库推送远程 init 要使用 Git 进行版本管理，必须先初始化仓库。 在包含所有要上传的文件的目录级别下： $ git init 如果初始化成功，执行了 git init 命令的目录下就会生成 .git 目录。这个 .git 目录里存储着管理当前目录内容所需的仓库数据。在 Git 中，我们将这个目录的内容称为“附属于该仓库的工作树”。文件的编辑等操作在工作树中进行，然后记录到仓库中，以此管理文件的历史快照。 status 工作树和仓库在被操作的过程中，状态会不断发生变化。 $ git status # On branch master # # Initial commit # nothing to commit (create/copy files and use &quot;git add&quot; to track) 结果显示了我们当前正处于 master 分支下。接着还显示了没有可提交的内容。所谓提交（Commit），是指“记录工作树中所有文件的当前状态”。 add 要想让文件成为 Git 仓库的管理对象，就需要用 git add 命令将其加入暂存区（Stage 或者 Index）中。暂存区是提交之前的一个临时区域。 $ git add README.md $ git status # On branch master # # Initial commit # # Changes to be committed: # (use &quot;git rm --cached &lt;file&gt;...&quot; to unstage) # # new file: README.md # 可见，新建的文件被加到了暂存区（注意关注输出内容中括号中的内容，会有一些功能性的建议） commit 可以将当前暂存区中的文件实际保存到仓库的历史记录中。通过这些记录，我们就可以在工作树中复原文件。 $ git commit -m &quot;First commit&quot; [master (root-commit) 9f129ba] First commit 1 file changed, 0 insertions(+), 0 deletions(-) create mode 100644 README.md -m 参数后的 &quot;First commit&quot;称作提交信息，是对这个提交的概述。若是不加 -m，直接执行 git commit 命令。执行后编辑器就会启动，并显示如下结果。 git commit -am &quot;...&quot; 命令一次完成 add，commit。 # Please enter the commit message for your changes. Lines starting # with &#39;#&#39; will be ignored, and an empty message aborts the commit. # On branch master # # Initial commit # # Changes to be committed: # (use &quot;git rm --cached &lt;file&gt;...&quot; to unstage) # # new file: README.md # 在编辑器中记述提交信息的格式如下。 * 第一行：用一行文字简述提交的更改内容 * 第二行：空行 * 第三行以后：记述更改的原因和详细内容 只要按照上面的格式输入，今后便可以通过确认日志的命令或工具看到这些记录。 在以 #（井号）标为注释的 Changes to be committed（要提交的更改）栏中，可以查看本次提交中包含的文件。将提交信息按格式记述完毕后，请保存并关闭编辑器，以 #（井号）标为注释的行不必删除。随后，刚才记述的提交信息就会被提交。 如果在编辑器启动后想中止提交，请将提交信息留空并直接关闭编辑器，随后提交就会被中止。 提交之后，工作树状态会提示没有更改，因为处于最新状态。 要修改上一条提交信息，可以使用 git commit --amend 命令。 log 可以查看什么人在什么时候进行了提交或合并，以及操作前后有怎样的差别。 针对刚才 $ git log commit 9f129bae19b2c82fb4e98cde5890e52a6c546922(指向这个提交的哈希值) Author: ... Date: ... First commit(该提交的提交信息。) 如果只想让程序显示第一行简述信息，可以在 git log 命令后加上 --pretty=short 。 $ git log --pretty=short commit 9f129bae19b2c82fb4e98cde5890e52a6c546922 Author: ... First commit $ git log -p README.md 在 git log 命令后加上 -p 参数，文件的前后差 别就会显示在提交信息之后。加上目录名，便会只显示该目录下的日志。如果加的是文件名，就会只显示与该文件相关的日志。 git log -- graph ——以图表形式查看分支合并提交等信息。 diff 可以查看 工作树、暂存区、最新提交之间的差别。显示的内容的内容中，“+”号标出的是新添加的行，被删除的行则用“-”号标出。 要查看与最新提交的差别，请执行以下 命令。 $ git diff HEAD 这里的 HEAD 是指向当前分支中最新一次提交 的指针。 branch 在进行多个并行作业时，我们会用到分支。在这类并行开发的过程中，往往同时存在多个最新代码状态。master 分支是 Git 默认创建的分支，因此基本上所有开发都是以这个分支为中心进行的。不同分支中，可以同时进行完全不同的作业。等该分支的作业完成之后再与 master 分支合并。 git branch 命令可以将分支名列表显示，同时可以确认当前所在分支。 分支左侧标有“*”（星号），表示这是我们当前所 在的分支。结果中没有显示其他分支名，表示本地仓库中只存在 master 一个分支。 如果想以当前的 master 分支为基础创建新的分支，我们需要用到 git checkout -b命令。 $ git checkout -b feature-A Switched to a new branch &#39;feature-A&#39; 等同于： $ git branch feature-A $ git checkout feature-A 创建 feature-A 分支，并将当前分支切换为 feature-A 分支。这时再来查看分支列表，会显示我们处于 feature-A 分支下。 在这个状态下像正常开发那样修改代码、执行 git add 命令并进行提交的话，代码就会提交至 feature-A 分支。 命令 git checkout - 可以切换回上一个分支，当然指定名字也可以。 主干分支和特性分支 特性分支顾名思义，是集中实现单一特性（主题），除此之外不进行任何作业的分支。在日常开发中，往往会创建数个特性分支，同时在此之外再保留一个随时可以发布软件的稳定分支。稳定分支的角色通常由 master 分支担当。 主干分支是刚才我们讲解的特性分支的原点，同时也是合并的终点。通常人们会用 master 分支作为主干分支。主干分支中并没有开发到一半的代码，可以随时供他人查看。有时我们需要让这个主干分支总是配置在正式环境中，有时又需要用标签 Tag 等创建版本信息，同时管理多个版本发布。拥有多个版本发布时，主干分支也有多个。 merge 接下来，我们假设 feature-A 已经实现完毕，想要将它合并到主干分支 master 中。为了在历史记录中明确记录下本次分支合并，我们需要创建合并提交。因此，在合并时加上 --no-ff 参数，在主干分支中执行 $ git merge --no-ff feature-A 随后编辑器会启动，用于录入合并提交的信息。默认信息中已经包含了是从 feature-A 分支合并过来的相关内容，所以可不必做任何更改。将编辑器中显示的内容保存，关闭编辑器会提示成功合并。 合并时可能发生冲突(Conflict)，不解决，无法合并。按提示解决就好。 reset 要让仓库的 HEAD 、暂存区、当前工作树回溯到指定状态，需要用到 git rest --hard 命令。只要提供 目标时间点的哈希值，就可以完全恢复至该时间点的状态。 git log 命令只能查看以当前状态为终点的历史日志。所以这里要使用 git reflog 命令，查看当前仓库的操作日志。在日志中找出回溯历史之前的哈希值，通过 git reset --hard 命令恢复到回溯历史前的状态。 在日志中，我们可以看到 commit、checkout、reset、merge 等 Git 命令的执行记录。只要不进行 Git 的 GC（Garbage Collection，垃圾回收），就可以通过日志随意调取近期的历史状态。 rebase 在合并特性分支之前，如果发现已提交的内容中有些许拼写错误等，不妨提交一个修改，然后将这个修改包含到前一个提交之中，压缩成一个历史记录。 git rebase -i HEAD~2 方式执行 git rebase 命令，可以选定当前分支中包含 HEAD（最新提交）在内的两个最新历史记录为对象，并在编辑器中打开。 出现类似 pick 7a34294 Add feature-C pick 6fba227 Fix typo 将 6fba227 左侧的 pick 部分删除，改写为 fixup。 pick 7a34294 Add feature-C fixup 6fba227 Fix typo 保存编辑器里的内容，关闭编辑器。提示 rebase 成功。这样一来，Fix typo 就从历史中被抹去，也就相当于 Add feature-C中从来没有出现过拼写错误。这算是一种良性的历史改写。 remote add 在 GitHub 上新建一个仓库。为防止与其他仓库混淆，仓库名请与本地仓库保持一致。创建时请不要勾选 Initialize this repository with a README 选项。因为一旦勾选该选项，GitHub 一侧的仓库就会自动生成 README 文件，从创建之初便与本地仓库失去了整合性。虽然到时也可以强制覆盖，但为防止这一情况发生还是建议不要勾选该选项。 现在我们用 git remote add 命令将github新建仓库设置成本地仓库的远程仓库。 $ git remote add origin 远程仓库路径 按照上述格式执行 git remote add 命令之后，Git 会自动将远程仓库的名称设置为 origin（标识符）。 push 当前分支下本地仓库内容推送到远程仓库。 假定在 master 分支下工作。 $ git push -u origin master 当前分支的内容就会被推送给远程仓库 origin 的 master 分支。 -u 参数可以在推送的同时，将 origin 仓库的 master 分支设置为本地仓库当前分支的 upstream（上游）。添加了这个参数，将来运行 git pull 命令从远程仓库获取内容时，本地仓库的这个分支就可以直接从 origin 的 master 分支获取内容，省去了另外添加参数的麻烦。 对于其他分支，我们在本地仓库中创建了 feature-D 分支，现在将它 push 给远程仓 库并保持分支名称不变。 $ git checkout -b feature-D $ git push -u origin feature-D 获取远程仓库其他分支开发 不要与之前操作的仓库在同一目录下。执行 git clone 命令后我们会默认处于 master 分支下，同时系统会自动将 origin 设置成该远程仓库的标识符。也就是说，当前本地仓库的 master 分支与 GitHub 端远程仓库（origin）的 master 分支在内容上是完全相同的。 用 git branch -a命令查看当前分支的相关信息。添加 -a 参数可以同时显示本地仓库和远程仓库的分支信息。 若要获取远程特性分支 feature-D，可以使用如下操作。 $ git checkout -b feature-D origin/feature-D -b 参数的后面是本地仓库中新建分支的名称。为了便于理解，我们仍将其命名为 feature-D，让它与远程仓库的对应分支保持同名。新建分支名称后面是获取来源的分支名称。 例子中指定了 origin/feature-D，就是说以远程 origin 的仓库的 feature-D 分支作为来源，在本地仓库中创建 feature-D 分支。更改添加提交推送即可。 $ git commit -am &quot;Add feature-D&quot; $ git push 此时，本地分支中并未有内容，需要使用 pull $ git pull origin feature-D 如果两人同时修改了同一部分的源代码，push 时就很容易发生冲突。所以多名开发者在同一个分支中进行作业时，为减少冲突情况的发生，建议更频繁地进行 push 和 pull 操作。]]></content>
      <categories>
        <category>编程与生活</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[代码之髓读后感——类&继承]]></title>
    <url>%2Fbooks%2F%E4%BB%A3%E7%A0%81%E4%B9%8B%E9%AB%93-%E7%B1%BB%26%E7%BB%A7%E6%89%BF%2F</url>
    <content type="text"><![CDATA[面向对象 语言中的用语并不是共通的，在不同语言中，同一个用语的含义可能会有很大差别。 C++的设计者本贾尼·斯特劳斯特卢普对类和继承给予了正面肯定，然而，“面向对象”这个词的发明者艾伦·凯（Alan kay，他同时也是 Smalltalk 语言的设计者）却持有不同的意见，他对类和继承持否定立场。 img 对于面向对象的理解 我们是怎样理解世界的呢？我们将生活中遇见的事物总结为特定的“物”的概念，它们就是诸如桌子、椅子、银行贷款、公式、人、多项式、三角形、晶体管之类的东西。我们的思考、语言以及行动就是建立在指示、说明和操作这些所谓的“物”的基础之上。我们在用计算机解决问题的时候，有必要将现实世界中的“物”的模型在计算机中建立起来。 img 类 大部分语言的程序设计中，类并不是不可或缺的，但 Java 语言是例外。Java 语言“把类定义为部件，将其组装起来即是程序设计”。因此，在用 Java 语言编写程序时类是必要的。其他诸如 C++、Python、Ruby 这样的语言，在编写程序时既可以使用类也可以不使用类。 那是使用类好呢，还是不使用也可以呢？ 这取决于要编写的程序。如果仅是小规模的程序，没必要使用类的情况居多。也有人认为，在多人分工协作编写的大型程序中，使用类来划分责任范围比较好。图形用户界面的编写中面向对象的特性似乎非常管用。比如设计一个按钮，需要有放置按钮的座标和按钮的宽、高等值，也需要有表达按钮按下时的动作的函数。将实现按钮所必需的这些要素统一到类中，编写程序就会变得简单起来。 归集变量与函数建立模型的方法 除类之外，还有几种其他的方式。 模块（module）。模块原本是一种将相关联的函数集中到一起的功能。在 Perl 语言中类似的功能被称为包（package）。Perl 语言在引入面向对象时，采用了把用来归集函数的包和用来归集变量的散列（hash）绑定在一起的方法。 把函数和变量放入散列中。这是 JavaScript 等语言采用的方法。 闭包（closure）。使用函数执行时的命名空间来归集变量的方法。这种方法主要在函数式语言中使用。 为什么把这称为闭包？一个包含了自由变量的开放表达式，它和该自由变量的约束环境组合在一起后，实现了一种封闭的状态。 类的存在只不过是因为人们觉得有了它编写程序会更方便些，而约定的一种事项。它并不是什么物理法则或宇宙真理，仅仅是人们的一种约定而已。所以，为了理解为什么会有这样一种约定，我们需要考虑语言设计者的意图。 类 C++ 语言和 Java 语言的类具有以下几个作用： 整合体的生成器 可行操作的功能说明 代码再利用的单位 继承 继承的不同实现策略。继承的实现策略大体可以分为三种。 一般化与专门化 第一种策略是在父类中实现那些一般化的功能，在子类中实现那些专门的个性化的功能。其设计方针就是子类是父类的专门化。 img 共享部分的提取 第二种策略是从多个类中提取出共享部分作为父类。它和一般化与专门化的考虑很不一样。对于子类是否为父类的一种，它的答案是否定的。这种提取出共享部分的设计方针是习惯了函数的一种考虑问题的方法。 img 差异实现 第三种策略认为继承之后仅实现有变更的那些属性会带来效率的提高。它把继承作为实现方式再利用的途径，旨在使编程实现更加轻松。的确有很多这样的情况。但这些情况下通常子类都不是父类的一种。 img 继承的弊端 方法的多样意味着控制的复杂，自由度太高往往会需要我们去限制。 比如说 goto 。 尤其是第三种使用方法——继承已有的类并实现差异部分，这种编程风格会造成多层级的继承树，很容易导致代码理解困难。 这里就提到了编程中很重要的一点，就是可读性。 里氏置换原则 这个原则可以表述为：假设对于 T 类型的对象 x，属性 q(x) 恒为真。如果 S 为 T 的派生类，那么 S 类型的对象 y 的属性 q(y) 也必须恒为真。 这句话换种表达就是，对于类 T 的对象一定成立的条件，对于类 T 的子类 S 的对象也必须成立。 为了保证类的继承关系和类型的父子关系这两种关系之间的一致性，有必要遵守这一原则。这一原则也可以表达为继承必须是 is-a 关系。把子类 S 的所有对象都看作是父类 T 的对象而不会有任何问题，必须要做到这一点。 这一约束条件是非常严格的。当要继承某种类时，需要考虑该类是否可以被继承。假设继承的时候考虑的属性可以使里氏置换原则成立。但是在随后的程序编写过程中，需要的属性可能会越来越多。随着属性的增加，置换原则就有可能被打破。是在设计阶段就把所有属性列出来，只有当置换原则绝对不被打破时才去继承呢？还是在开发阶段如果发现新的属性就放弃类的继承呢？不管哪种方式都很费劲。 多重继承 现实世界中一种事物有可能属于多种分类。为了实现对这种现实情况的模拟，作为工具的程序设计语言是不是应该支持对多个类的继承呢？这就是多重继承的初衷。 多重继承对于实现方式再利用非常便利。 多重继承的问题 多重继承看起来真的很方便。但是，使用多重继承时该如何解决名字解释的问题呢？当问到类中 x 值是什么时，该如何回答呢？ 首先，如果这个类本身知道答案，就直接给出回答。其次，如果这个类本身不知道答案，就去问它的父类再给出回答。 但是如下情况就麻烦了。 解决方法 1：禁止多重继承。Java 语言中就禁止了类的多重继承。只要不认可类的多重继承这种方式，就不会有上述问题。这样可以把问题解决得很干脆，只是会以失去多重继承的良好便利性为代价。 委托。取而代之发展起来的概念是委托。这种方法定义了具有待使用实现方式的类的对象，然后根据需要使用该对象来处理。使用继承后，从类型到命名空间都会被一起继承，从而导致问题的发生，这种方法只是停留在使用对象的层面上。 12345678910111213141516171819202122232425public class TestDelegate &#123; public static void main(String[] args)&#123; new UseInheritance().useHello(); // -&gt; hello! new UseDelegate().useHello(); // -&gt; hello! &#125;&#125;class Hello&#123; ❶ public void hello()&#123; System.out.println("hello!"); &#125;&#125;class UseInheritance extends Hello &#123; ❷ public void useHello()&#123; hello(); ❸ &#125;&#125;class UseDelegate &#123; ❹ Hello h = new Hello(); ❺ public void useHello()&#123; h.hello(); ❻ &#125;&#125; 显示“Hello ！”的方法 hello 为类 Hello 所持有（❶）。类 UseInheritance 通过继承类 Hello 自身也持有了方法 hello（❷）并加以使用（❸）。与之不同，类 UseDelegate 并没有继承类 Hello（❹），而是通过句❺持有了类 Hello 的对象。当有需要使用时通过句❻将需要的处理委托给该对象操作。 与从多个类中继承实现强耦合的方式相比，使用委托进行耦合的方式显然要更好一些。对于委托的使用，也不需要在源代码中写死，而是可以通过配置文件在合适的时候注入运行时中去。这个想法催生了依赖注入（Dependency Injection）的概念。 接口。刚刚提到 Java 语言中禁止了多重继承，但它也具备实现多重继承的功能。这就需要借助接口（interface）。Java 语言中类的继承用 extends，接口的继承用 implements 来区别表示。另外接口的继承也称为实现。接口是没有实现方式的类。它的功能仅仅在于说明继承了该接口的类必须持有某某名字的方法。多重继承中发生的问题是多种实现方式相冲突时选取哪个的问题。而在接口的多重继承中，尽管有多个持有某某方法的信息存在，但这仅仅表明持有某某方法，不会造成任何困扰。 12345678910111213public class TestMultiImpl implements Foo, Bar &#123; public void hello()&#123; System.out.println("hello!"); &#125;&#125;interface Foo &#123; public void hello();&#125;interface Bar &#123; public void hello();&#125; 类 TestMultiImpl 继承了 Foo 和 Bar 两个接口。如果这个类中不实现 public void hello ()，编译时将出现“没有实现应该实现的方法”这样的错误。也就是说，继承了接口 Foo 后，这个类就作为一种类型表现出必须持有 public void hello () 的特点，可以让编译器对它进行类型检查。 Java 语言为了仅实现功能上的多重继承引入了接口。PHP 语言和 Java 语言一样不认可多重继承，并从 2004 年发布的 PHP5 开始引入了接口的概念。 解决方法 2：按顺序进行搜索 曾经也有些语言试图通过明确定义搜索顺序来解决冲突问题。 出现过深度优先搜索法，重载和菱形继承时会很麻烦。以及广度优先。 以及后来的C3线性化。 * 父类不比子类先被检查 * 如果是从多个类中继承下来则优先检查先书写的类 解决方法 3：混入式处理 原本，问题是指从一个类到它的祖先类有多种追溯方法。定义仅包含所需功能的类并把它与需要添加这些功能的更大的类糅合在一起。把这种设计方针、混入式处理方式和用来混入的小的类统称为混入处理（Mix-in）。 通常这些小型的类最小限度地定义了一些方法，起到了作为代码再利用单位的作用。为了表明这一点，Python 语言会在该类的名字中加上 MixIn 来标识。 Ruby 语言采用的规则是：类是单一继承的而模块则可以任意数量地做混入式处理。模块无法创建实例，但可以像类一样拥有成员变量和方法。也就是说，模块实质上是从类中去除了实例创建功能。即使类的多重继承被禁止了，通过使用模块的 Mix-In 方式照样可以实现对实现方式的再利用。 解决方法 4：Trait 类具有两种截然相反的作用。一种是用于创建实例的作用，它要求类是全面的、包含所有必需的内容的、大的类。另一种是作为再利用单元的作用，它要求类是按功能分的、没有多余内容的、小的类。当类用于创建实例时，作为再利用单元来说就显得太大了。既然如此，如果把再利用单元的作用特别化，设定一些更小的结构（特性＝方法的组合）是不是可以呢？这就是 Trait 的初衷。 已有的 Trait，通过改写某些方法定义新的 Trait 实现继承。还可以通过组合多个 Trait 实现新的 Trait。这就是 Trait 的概要说明。它一方面把问题妥当地分而治之，一方面又因为功能繁多令人困惑。读者们想必都还记得 goto 语句就是因为其功能过于强大而退出历史的舞台的吧。所以说力量过于强大未必是件好事。 Trait 技术是一个很好的开端。它认为类同时具有的作为再利用单元和实例生成器的两种作用是相反的。或许类这一概念作为面向对象的根基具有不可动摇的地位。然而这一概念本身也是从一个雏形慢慢发展得越来越复杂，进一步整理之后再逐渐让渡出某些功能的。现在备受关注的 Trait 和一些其他概念也必将不断地演变下去。经过长时间琢磨沉淀，一部分将臻于成熟被推广使用，最后将变成现在的静态作用域和 while 语句那样被认为是理所当然的存在。]]></content>
      <categories>
        <category>编程与生活</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[代码之髓读后感——容器&并发]]></title>
    <url>%2Fbooks%2F%E4%BB%A3%E7%A0%81%E4%B9%8B%E9%AB%93-%E5%AE%B9%E5%99%A8%26%E5%B9%B6%E5%8F%91%2F</url>
    <content type="text"><![CDATA[容器 单个地址存放单个数据，但是如果有多个数据，而这些数据互相关联，则我们更希望的是将他们能够更好的在内存中组织在一起。于是便出现了容器的概念。 在不同的语言中，容器的名称不同，性质各异。比如，C 语言中的数组、LISP 语言中的列表、Python 语言中的元组以及 Ruby 语言中的数组。即使是名字相同，在不同语言中表达的意思也可能不一样。比如，LISP 语言和 Haskell 语言中的列表，与 Java 语言和 Python 语言中的列表在内部构造上完全不同。 又由于所针对的问题不同（还是这句话，因为变成就是用来解决现实问题的一个工具），所以出现了各种样的容器——数组，链表，字典，散列，树等等。 各种容器差别主要在于执行特定操作的优势与劣势。此时一般使用用大O表示法计量的时间复杂度栏衡量。 万能的容器是不存在的。根据容器的使用目的、使用方式和操作类型的不同，最适宜的容器类型也会相应地变化。是想要节约内存、节约计算时间，还是两样都没有必要节约。没有绝对的正确答案，而是需要根据当时的状况仔细分析，寻求最佳平衡。这是非常重要的。 魔术注释符——为了能让语言处理器正确地处理包含多字节字符的源代码，就需要告诉它源代码的编码方式。其中一个方法就是使用魔术注释符。魔术注释符最早是编辑器的一个功能。在 Emacs 和 Vim 等文本编辑器中，用特殊的记号事先写明文件的编码方式，编辑器要打开这一文件时就会以这一编码方式读取文件。语言处理器如果按这种方式去读，就能知道源代码中字符的编码了，这样一来问题就可以得到解决了。这一提案在 2001 年作为 Python 语言的扩展方案被公布出来。现在 Ruby 语言、Perl 语言和 Scheme 语言的处理器 Gauche 等都采用了这一方案。 Python 语言进一步采取了更为激进的设计方法。源代码中只要是使用了 ASCII 码以外的字符，但没有使用魔术注释符时，都将导致语法错误，就会带来以下错误。 1SyntaxError: Non-ASCII character &apos;\xe6&apos; in file tmp.py on line 1, but no encoding declared; see http://www.python.org/peps/pep-0263.html for details 直到后来出现了Unicode编码。字符集得到了统一，但为适应不同的需求，字符的编码方式还有很多种，如 UTF-8 和 UTF-16 就是其中两种。 字符串 字符串就是字符并列的结果，但在不同的语言中，字符串列的表现方式各不相同。 这里书中介绍了 C、Pascal、Java、Ruby 和 Python 这几种语言中的字符串。这五种语言中，只有 C 语言中的字符串不知道自身的长度。其他语言中的字符串都携带有表现自身长度的整数。可以说 C 语言中的字符串是最为原始的字符串。 那么 C 语言字符串是如何表现字符串本身到何处为止呢？ 用 NUL 字符表示字符串的终止。为达到这一目的使用了一种表现字符串终止的特殊字符，这就 NUL 字符 40。NUL 字符是一个与 0 对应的字符，在 C 语言代码中用 \0 表示。（40ASCII 规定将 null character 简称为 NUL，换行（line feed）简称为 LF。为了避免与 C 语言中的 NULL 指针相混淆，本书中用 NUL 字符来表述） C 语言字符串是把“从头开始读取，直到第一个 NUL 字符出现”的位置当作一个字符串处理。 12345678910111213141516 C语言#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main()&#123; int x = 9252; char str[3] = "abc"; char str2[3] = "defg"; printf("%s\n", str2); printf("%zu\n", strlen(str2)); return 0;&#125; 输出defabc$$8 (很可能因操作系统、编译器版本或选项的不同，执行结果也有所不同。) 原因是 str 和 str2 都声明为 char[3]，只分配了 3 字节的空间。abc 这一 3 个字符的字符串要表达它在字符 c 的地方结束的话，需要 3 个字符再加 NUL 字符总共 4 个字符的空间，但是代码中只为其分配了 3 个字节的空间。因此，abc 后面的 NUL 字符以及 def 后面的 g 和 NUL 字符都没能放入而被舍弃了。故而在显示 str2 时，首先显示 def，然后是显示与之相邻的空间里保存的 abc。 那么最后的 $$ 又是怎么回事呢？这其实是函数开始部分的 int x = 9252；语句在内存中写入的整数 9252. 9252 用 16 进制表示就是 2424，在 ASCII 码中 24 是 $。因此这个整数被解释为有两个 $ 并列的字符串的一部分。与之相邻的内存中是 00，被当作是 NUL 字符，显示到此终止。然而，在某些情况下可能显示出更多的内容，并且有可能会试图读取那些禁止读取的内容，从而造成程序的异常终止。 img C 语言风格的字符串处理起来还是比较困难的。实际上，大多数语言都采用了 Pascal 语言风格的字符串。 Python 3 中引入的设计变更 在 Python 2.x 版本中，源代码中有 &quot; あ &quot; 时，这是一个字节串列的字符串。如果源代码的编码方式为 UTF-8，这就变成一个有 ['0xe3', '0x81', '0x82'] 三个字节的串列。写成 u&quot; あ &quot; 时，表示这是一个 Unicode 的字符串，只有一个 Unicode 字符即 ['0x3042']. 因为同时存在两种类型的字符串，于是会有一个问题：两者混合使用的话会怎样？ Python 2.x 版本规定，在 ASCII 码环境下时字节串列被当作 ASCII 码并且可以自动转换成 Unicode。 12345678 Python 2.7&gt;&gt;&gt; u"hello, " + "Alice"u'hello, Alice'&gt;&gt;&gt; u"hello, " + "太郎"Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;UnicodeDecodeError: 'ascii' codec can't decode byte 0xe5 in position 0:ordinal not in range(128) ※ Python 2.7 中字节串列只在 ASCII 码时才能和 Unicode 字符串结合 然而，在字符串内容不同时，这一规定有时正常有时却会导致错误。在只使用了 ASCII 字符的测试案例中可以正常运行，而在使用了 ASCII 字符以外的字符却会有问题。因此，Python 3.x 版本舍弃了 Python 2.x 版本中的兼容性，围绕字符串展开了大的变革。首先，规则发生了变化。默认直接是 Unicode 字符，写成 &quot;b&quot; 时是字节串列，这样 Unicode 其次，在 Unicode 字符串和字节串列结合的时候，不管其想结合的内容如何，都将抛出类型错误。在有需要混合字符串时，规定有必要显式地使用转换代码，这避免了在不知情的情况下进行了转换而导致问题发生的被动局面。 Python 3.0 中将字节串列结合到 Unicode 字符串时常常发生错误。这时需要显示地将字节串列转换成 Unicode 字符串。 在转换成 Unicode 字符串时为什么要写 ASCII 呢？也许有人这样问。这里的 decode(&quot;ASCII&quot;) 是指将使用 ASCII 编码方式编码了（encode）的内容做还原处理（decode）。 Ruby 1.9 的挑战 Python、Java 等众多语言都采用了以 Unicode 为基础的字符串，而 Ruby 语言却走出了独树一帜的路线。从 Ruby 1.9 开始，字符串就是 8 个比特，并且采用了追加编码方式信息的设计方法。这种方法的优点是可以直接书写那些不包含在 Unicode 字符集中的字符。 并发处理 为了实现便利的并发处理，出现了进程和线程的概念。另外，由于并发处理产生了一些新的问题，为应对这些问题又发明了锁和光纤等概念。 《程序设计语言：概念和结构》一书提到：程序设计语言中的并行性和硬件中的并列性是相互独立的两个概念。并列性是硬件层面的表述，比如英特尔公司于 1999 年发布的 Pentium III 中的可以同时针对四个值进行运算的 SSE 命令，以及 NVIDIA 为了记录因为 GPU 带来的高并列性的处理于 2007 年发布的 CUDA 等。而本书该章节将要讨论的是程序设计语言领域的并行性，具体来说是进程和线程的概念。 对于单核，如何实现并行？答案就是在人们察觉不到的极短间隔内交替进行多项处理。尽管在某一瞬间实际只进行一项处理，但人们会觉得似乎有多项处理在同时进行。不过现在的计算机都实现了在CPU 上装载多个处理线路已经成为了主流，这称为多核。这是并发处理中最为重要的概念。在人们看来，程序是一刻不停地在执行，但实际上它被细分成了小段来执行。 使用一个处理线路执行多项处理，就像两兄弟一起玩一台单人游戏机一样。如果能在彼此都同意的时间间隔内轮流玩，那么也就相当于两人各自在玩一台单人游戏机。“何时交替”可以分为两种情况。 协作式多任务模式——在合适的节点交替 这种方法有一个问题，有可能某个处理一直找不到合适的节点进行任务切换从而持续地进行，导致其他处理无法等到执行的机会。归根结底，采取这种方法是基于一种信任，即所有的处理都会在适当的间隔后进行交替。 再看一下那个游戏机的比喻，如果哥哥一直玩下去不给弟弟玩的话，弟弟无论等多久都玩不上了。这时弟弟估计会向妈妈告状，哥哥会被责怪吧。 Windows 3.1 和 Mac OS 9 都是协作式多任务系统。即使不是有意为之，有时也会遇到程序缺陷进入无限循环，待并发处理的程序完全没有交替，全部程序都变得没有响应了。 抢占式多任务模式——一定时间后进行交替 这个方法中，有一个比其他程序都具有优势的程序叫任务管理器。它在一定时间后强制中断现在正在进行的处理，以便允许其他程序执行。 还是再来看一下那个游戏机的类比，这好比妈妈每隔十五分钟命令换人玩。换成计算机，它能在人们察觉不到中断发生的间隔时间（比如 20 毫秒或 0.02 秒）实现交替。 Windows 95、Mac OS 以后的版本以及 Unix、Linux 等操作系统都是使用这种方法实现的多个程序的并发处理。 对程序使用者来说，抢占式多任务模式十分方便，但对于程序设计者来讲会出现其他问题。在不知道何时被喝令终止并交替的前提下，要编写一个能稳妥执行的程序是非常困难的。 如例： 1234如果存款余额高于10 000元 &#123; 存款余额减去10 000元、 取出10 000元的钞票&#125; 12345678（假设存款余额有15 000元。首先程序A执行）A：存款余额高于10 000元吗？→Yes（这里又交替到程序B的执行上）B：存款余额高于10 000元吗？→ YesB：存款余额减去10 000元、取出10 000元的钞票（这里存款余额变为5，000元。然后再交替回程序A）A：存款余额减去10 000元、取出10 000元的钞票（存款余额仅有5000元却取出了1万元！） 这种局面被称为竞态条件（race condition），或者说这个程序是非线程安全的。 竞态条件（race condition），从多进程间通信的角度来讲，是指两个或多个进程对共享的数据进行读或写的操作时，最终的结果取决于这些进程的执行顺序。 竞态条件成立的三个条件 并行执行的两个处理之间出现竞态条件必须同时满足以下三个条件。 两个处理共享变量 至少一个处理会对变量进行修改 一个处理未完成之前另一个处理有可能介入进来 反之，只要三个条件中有一个不具备，就可以编写适于并发处理的安全的程序。 针对以上的几个方面，有了以下处理。 没有共享——进程和 actor 模型 如果最初就没有共享任何数据，条件a就不可能发生，也就没有必要在意竞态条件了。 在进程中没有内存共享。相信很多人都知道 UNIX 将执行的程序叫做进程（process）。不同的进程不会共享内存，所以在多个程序之间不会在内存上出现竞态条件。只需要注意与数据库连接或文件读写时共享数据的情形就够了。 在 UNIX 发布大约 10 年后，人们设计出了“轻量级进程”。它是一种共享内存、具有 UNIX 出现以前风格的进程。后来，这个被称为线程。 在不共享内存的设计方针下，还有一个流派——actor 模型。 我们以行政文员、资料和公文格为例来说明。甲打开桌上的资料进行处理时，如果乙走过来希望甲处理其他资料，这就影响了甲正在进行中的工作，这就是共享内存的问题所在。一方面，在甲的工作告一段落之前，即使乙在旁边一直等候也是浪费时间。这就是后面要讲到的死锁的问题。如果不这样，乙在往甲的公文格中放入新的资料后马上回去处理自己的工作，这就变成 actor 模型。 这种模型中处理是非同步的。乙不知道甲何时会处理完公文格中的资料。不管何时处理完，如果在资料中写明“处理完毕请送回乙处”等信息，一旦乙在自己的公文格中看到了甲的回复，也就知道了这些资料已经处理完毕。 不修改——const、val、Immutable 即使共享内存，只要不作修改也不会有任何问题。 但是更多的语言采用了更加现实的折衷策略——使一部分变更无法作修改。 在 C++ 语言中，使用 const 声明变量时，这个变量就是无法修改的。 在 Scala 语言中，有 var 和 val 两种声明变量的方法，val 声明的变量就无法作修改。 Java 语言经常使用到 Mark Grand 提出的设计模式之一的 Immutable 模式。这种模式下，类中定义了 private 字段，同时定义了读取这些字段的 getter 方法，但不定义对这些字段作修改的 setter 方法。因为没有准备用于修改的方法，所以实现了只能读取但不能改写的效果。 不介入 在处理期间如何杜绝别的作业介入进来？ 线程的协调——fibre、coroutine、green thread 毫无疑问，由于是协作式多任务模式，如果有某个线程独占 CPU，其他处理就只能停止。说到底，这种方法的前提是各个线程能保证合理的执行时间在合适的时候做出让步。 表示不便介入的标志——锁、mutex、semaphore 这和试衣间中的门帘或单人浴室包间的状态牌类似。门帘关闭时表示这时试衣间正被占用，现在进去的话不方便。想使用试衣间的人只能在外面一直等到门帘打开为止。 锁这个名字很容易让人误解为只要上了锁其他人就进不来了，然而实际上它只是一个表示“使用中”的状态牌。如果有线程不去检查状态牌的状态，那它也就变得没有意义了。 这一机制是艾兹格·迪科斯彻（Edsger Wybe Dijkstra）于 1965 年发明的。1974 年霍尔（Hoare）发明了更加方便的改良版本，即 Concurrent Pascal 中采用的 monitor 的概念。1974 年时 C 语言已经问世 3 年了，直到 20 年后问世的 Java 语言采用了 monitor 的概念，它才得以广泛使用。 在进入之前先检查是否挂有“使用中”的状态牌，如果有则等待，如果没有挂则挂上“使用中”的状态牌再进入。要实现这一系列约定的动作是件比较麻烦的事情。比如使用 if 语句时，在“做值的检查”和“判断为 0 则改为 1”时，有可能有其他处理介入进来。这样一来检查就毫无意义了。为了不让其他处理在中间介入进来，就有必要使用一种能将值的检查和修改同时执行的命令。 Java 直接使用 synchronized lock 就可以轻松地使用实现如此功能的锁。 锁的问题及对策 锁的问题 陷入死锁——多个锁互相限制了对方，陷入了等待对方的解锁而形成的死结。为了避免这一问题，程序员就需要在程序的整体上注意上锁的顺序，不仅要把握应该对什么上锁，还要把握好按什么顺序去上锁。 无法组合——对于多步骤的总体进行上锁，杜绝干扰的实现。要防止中间介入，程序员必须用新的锁将这两个处理步骤包括起来，用 synchronized lock 把所有这些相关的代码包括起来。但是，这样就没能达到让程序员无需担心锁的控制方式的目的。 借助事务内存来解决 有一种叫做事务内存的方法可以解决这一问题 13。这种方法把数据库中事务的理念运用到内存上，做法是先试着执行，如果失败则回退到最初状态重新执行，如果成功则共享这一变更。它不是直接修改 X 或 Y，而是临时性地创建了一个版本对其进行修改，将一个完整不可分的过程执行完毕后才反映出最终的成果。 img 假设有写入操作在中间介入进来，那么临时创建的版本就会被丢弃，重新回退到最初状态开始执行。这样一来，即使不上锁也可以顺利地进行并发处理。要注意的是，当写入的频率太高时，回退重 新执行的操作就会多次执行到，这样会导致性能下降。 img 事务内存成功吗 未来会怎样没人知道。 微软公司于 2010 年中止了面向 .NET Framework 平台搭载软件事务内存的实验。 据说后续的 Intel 处理器将搭载事物内存的部分功能。如若实现，届时对于硬件事务内存就可以轻松一试了。]]></content>
      <categories>
        <category>编程与生活</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[代码之髓读后感——名字&作用域&类型]]></title>
    <url>%2Fbooks%2F%E4%BB%A3%E7%A0%81%E4%B9%8B%E9%AB%93-%E5%90%8D%E5%AD%97%26%E4%BD%9C%E7%94%A8%E5%9F%9F%26%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[名字和作用域 为什么要取名 看着代码中遍地都是的变量，函数，或多或少的我们都应该想过，为什么会有这些名字呢？ 我们知道，计算机将数据存储到对应的物理内存中去。我们的操作就是基于数据的。我们需要使用这些数据，所以一个问题就是如何寻找到这些数据。一个较为直接的方式就是为它起个名字。 联系现实生活中的，最典型的就是图书馆。一本本书，一块块数据。为了查找，我们使用的是对各个数据地址进行编码。一一映射到一组唯一的数据上，以此便于查找的唯一替代彼不便于查找的唯一。 仔细想来，这种替代的方法似乎和哈希函数的思想有思想倒是有些接近。或许其中就是使用了呢？ 实际上，每个名字对应的都是实际内存中的地址。因此也必须要有一个表来存储映射关系。 所以在语言的发展过程中，对照表的设计也是一个关键之处。 作用域的演变 在早期的程序设计语言中对照表是整个程序共有的。这样的设计，虽然一定程度上解决了映射的管理的问题，但是，这就相当于现在全局的作用域的概念，一处变，处处变，一次变，次次变。为了防止变量名的重复使用，防止名字的冲突，一种方法就是使用更长的变量名。在这种过程中，各种命名法就出现了。当然，对于现在来说，合理的命名对于程序的可读性，易扩展性也是有极大的帮助的。再有就是使用作用域的限定。 随着程序规模的扩大，为了更方便管理变量，将不同层级的变量各自划分范围，将各个变量的有效范围进行约束，于是出现了作用域的概念。 正是由于原先的类似于全局作用域的设定，导致当前出现了作用范围太大，出现冲突的可能性太大，进而由此想出了解决办法——缩小作用域。 作用域随着后来的发展，出现了两种类型——动态与静态。 所谓的作用域就是指某段程序文本代码。一个声明起作用的那一段程序文本区域，则称为这个声明的作用域。静态作用域是指声明的作用域是根据程序正文在编译时就确定的，有时也称为词法作用域。而在采用动态作用域的语言中，程序中某个变量所引用的对象是在程序运行时刻根据程序的控制流信息来确定的。 从对照表的角度来分析一下静态作用域和动态作用域。 动态 动态作用域中的对照表能被全部代码读取 最初全局对照表中记录了x与global的映射。 进入函数a，准备新的全局可见的对照表。 函数a写入变量x的值记录在新的对照表中。 进入函数b，由于还未退出a，故其对照表仍有效。所以读取其中的x的值。（参照变量的时候，按照由近及远的顺序读取。若是访问该对照表中没有记录的变量时，就翻转到外层的对照表查找，这里是全局对照表） 退出b。 退出a时，作废新的对照表。 如下例子： 12345678910111213$x = "global";sub a &#123; local $x = "local"; &amp;b();&#125;sub b &#123; print "$x\n"; # 输出“local”&#125;&amp;a(); 把变量原来的值实现保存在函数入口处，在出口处写回变量中。这样一来，在程序中间的改写在退出函数的时候不会继续影响。但是这样就要要求，凡当函数退出时，所有地方就要毫无遗漏的加上返回值的代码。于是处于懒惰的心理，我们总希望让计算机去完成这样的工作。 1991年发布的Perl4开始，Perl语言就增加了这样的功能。它通过把变量声明为local，就可以长程序处理器去承担“把原来的值另存起来随后返回”的任务。 这样的作用域称为动态作用域。动态作用域中被改写的值会影响到被调用函数，因此在引用变量时是什么样的值，不看函数调用方是无从得知的。这就使得在代码规模庞大时，不便于把握。 静态（又叫字面作用域，词法域等等） 静态作用域按照函数区分对照表 最初全局对照表中记录了x与global的映射。 进入函数a，准备函数a专用的对照表。 函数a写入变量x的值记录在专用的的对照表中。 进入函数b，准备函数b专用的对照表。 读取变量值，会先读取b专用表，没有结果则去读取全局变量的表。 退出b，作废该张对照表。 退出a，作废该张对照表。 如下例子： 12345678910111213$x = "global";sub a &#123; my $x = "my"; &amp;b();&#125;sub b &#123; print "$x\n"; # 输出“global”&#125;&amp;a(); 现在说全局变量不好或者全局污染原因便是在此。实际操作中尽量减小作用范围，是一种明智的选择。 静态作用域的不足 以一开始就采用了静态作用域的python语言为例： 2000年发布的python2.0中，对照表有三个层次（作用域）。从大到小分别是内置的，全局的，局部的。简单而言，每个程序都有一张整体对照表（内置），一张文件级别的对照表（全局），一张函数级别的对照表（局部）。 内置对照表，可以在程序的任何地方使用参照，全局对照表是针对每个文件的，因为有的语言也称之为文件作用域，局部作用域则是针对每个函数的对照表。 在实际使用中，主要出现以下问题： 嵌套函数的问题 python支持函数嵌套定义。 1234567x = "global"def a(): x = "a" def b(): print x b()a() 在python2.0最初的设计中，如上函数嵌套时，当b中的局部作用域中找不到x，接下来去找的是全局作用域。 这样的设计引来很多误解，人们常常会以为，从表面看，因为a中包含b，所以a的作用域也包含b的作用域，当b中找不到x时，参照相邻的外部a的作用域。 后来在2011年发布的python2.1中设计修改为了逐层往外寻找的策略。 外部作用域的再绑定问题 指的是采用静态作用域时，无法变更嵌套作用域外部的变量。当嵌套的内层函数变量赋值时，若是当前作用域没有该值时，就会在当前的作用域定义一个新的局部变量。对这个名字进行了一次再次绑定，为他关联了另外的值。但是，这并不会影响外部的作用域。即无法变更外部的变量。 为了解决这个小问题，2006年的python3.0提供了关键字nolocal，在函数开始时，声明变量为nolocal性质。即主动地声明是非本地的。 这个关键字的选取，主要考虑了对于过往代码的兼容性，他在过去的代码中，出现的频度是最低的。 这样的nolocal和global关键字有区别么？ 对于和python很类似的ruby而言，则是使用了方法与代码段的区分。 函数发生嵌套，形式上有两种类型。方法套方法，方法套代码段。 如下两例： 1234567891011121314151617# 方法在进行嵌套时作用于不嵌套def foo() x = "outside" def bar() # 方法嵌套 p x # 会出错，因为无法访问外部的x end# 方法中有代码段时，方法的局部作用域中有的名字，在代码段中视为方法的局部变量，除此以外被视为代码段的局部变量。# 相同名字则为方法的，不同的，则是自己的。def foo() x = "old" lambda &#123;x = "new"; y = "new"&#125;.call # x -&gt; foo(), y -&gt; lambda的本地变量 p x # new p y # lambda的本地变量，外部无法访问end 作用域总结 虽然现在很少会使用动态作用域，但这一概念并不是完全没有用处。与静态作用域中作用域是源代码级别上的一块完整独立的范围不同，在动态作用域中，作用域则是进入该作用域开始直至离开这一时间轴上的完整独立的范围。与此相同的特征也体现在其他好多地方。比如，在某处理进行期间，一时改变某变量的值随后将原值返回的代码编写方式就相当于创建了自己专属的动态作用域。又如，异常处理与动态作用域也很相似，函数抛出异常时的处理方式受到调用函数的 try/catch 语句的影响。 面向对象中像 private 声明这样的访问修饰符，在限制可访问范围的作用上和作用域是非常相似的。private 将可访问范围限制在类之内，而 protected 将此范围扩大到其继承类。这和函数调用处的变更会影响到调用里面的操作这一动态作用域表现是相似的，两者都具有这么一个缺点，这就是影响范围没有能限制在代码的某一个地方。 比如 Java 语言，它是静态作用域语言，它的类可以在源代码的任意处被访问。这意味着类是具有全局作用域的。但是类的名字具有层次并且只有导入后才能被使用，这避免了全局变量带来的无意的名字冲突。但是不管是全局变量还是类的静态成员都可以在源代码的任意地方被变更。这提醒我们，在享受使用上的便利的同时，要谨防滥用导致的代码难以理解的情况发生。 作用域是编写易于理解的代码的有力工具，很多地方都应用了这一概念。 类型 C，java，C++等语言中的int，void，double，float等等，这些是怎么出现的？现在又有了怎样的变化与发展？ 类型是什么 类型是人们给数据附加的一种追加数据。计算机中保存的数据是由 on 和 off 或 0 和 1 的组合来表达的。至于 on 和 off 的组合（比特列）是如何表达各种数值的，哪种比特列表示哪种值，这些只不过是人们简单的约定事项而已。同样的比特列，当其被解释为的数据的类型不同时，得到的数值是不同的。为了避免这一情况的发生，人们追加了关于数据的类型信息，这就是类型的起源。 计算机中的数值是整数、浮点数还是其他类型的数，为了在计算机中管理这一信息，于是催生了类型。起初，类型中只加入了数值的种类信息，最后又有多种多样的信息加入进来。比如，能在这个数值上施加的操作、此函数可能抛出的异常等信息都被加入到类型中来了。现在，像静态类型和动态类型那样连内存地址和使用时间都不一样的事物也被称为类型，这使得类型这种东西变得越来越难以捉摸。什么样的信息放在什么地方，在什么样的时间被使用，从这个视角来看反而更容易理解。 表达数字的思考 如何在电子计算机中表达数值呢？如前所述，在计算机中所有的数值都用 on 和 off 或 0 和 1 的组合来表达。为了更形象地说明，我们换个角度来思考，该如何用灯泡的点亮与熄灭来表达数值呢？为了充分利用资源，只能是用最少的技术标量来表示最多的数。 完全按个数(n个计数标量) -&gt; 数位(阿拉伯数字)(10个计数标量) -&gt; 七段数码管(7个计数标量) -&gt; 算盘(最少的5个，上一下四) -&gt; 从十进制到二进制(9也只需要4个，1001) 把二进制中某几个字符组合在一起用一个字符来表示，使之变得更容易读，这种表达方式就是八进制或十六进制。 如何表达实数 实数的复杂之处在于在正整数的基础上添加了小数和负数。所以针对这两种情况进行设计。 定点数——小数点位置确定 一种方法是确定小数点的的位置。比如，约定好把整数的小数点向左移动四位，最低四位就是小数部分。这样一来，1 变成 0.0001，100 变成 0.0100 即 0.01.这种方法有个问题，它无法表达比 0.0001 小的数，比如无法表达 0.00001。当然只要把约定改为把整数的小数点向左移动五位得到小数部分就可以，但这样针对每一个新的小数都要记一句新的约定很困难，而且还容易出错。那该怎么办呢？ 浮点数(floating point number)——数值本身包含小数部分何处开始的信息 以前关于浮点数有各种不同的约定，现在都标准化为 IEEE 75415。15官方名称为“IEEE Standard for Floating-Point Arithmetic (ANSI/IEEE Std 754-2008)&quot;。IEEE 754 最早制定于 1985 年，后于 2008 年进行了修订。另外，在此标准规定有 5 种标准类型，这里仅仅说明了其中的单精度二进制浮点数。 img 左边那盏灯（最高比特位）,也可以称之为 MSB（most significant bit），最高有效位 代表了数的符号。该位为 0 时表示正数，为 1 时表示负数,在标准中，零区分为正的零和负的零。 接下来的 8 盏灯是表示位数的指数部分。指数部分作为整数理解的话可以表达 0~255 之间的数，减去 127 得到范围－127~128。－127 和 128 分别代表了零和无限大，剩下的－126~127 代表了小数点的位置。－126 是指小数点向左移动 126 位，127 是指小数点向右移动 127 位。 其余的 23 盏灯是尾数部分，表示了小数点以下的部分。尾数部最左边的灯泡表示 1/2（二进制中的 0.1），接下来是 1/4（二进制中的 0.01）。请看图中的 1.75 这个数，它等于 1+1/2+1/4，用二进制来表示就是 1.11。所以，1/2 位的灯泡和 1/4 位的灯泡都点亮。指数部分为 127（要减去 127 就是范围中的 0），这表示小数点的位置移动 0 位。这两点组合起来就是 1.75。 准确来讲，尾数是在二进制表达中为使得整数部分变成 1 而移动小数点得到的小数部分。 接下来的数 3.5，用二进制来表示是 11.1。小数点向左移动一位就得到 1.11。所以它的尾数部分和 1.75 一样，1/2 位和 1/4 位点亮。指数部分变成 128（减去 127 就是范围中的 1）。3.5（二进制中的 11.1）其实就是 1.75（二进制中的 1.11）的小数点向右移动一位得到的数 19。而 7.0 则是由指数部分继续加 1 得到。 19在二进制中，小数点移动一位进位不是 10 倍而是 2 倍。指数部分加 1，变成 2 倍，减 1 变成 1/2。 浮点数的问题 现今大家接触到的语言中，实数大多用浮点数 IEEE 754 表达。从实用角度来看，大部分情况下这没有任何问题。但是，这种方法要表达 3 除以 10 的答案时，十进制中可以确切表达出来的 0.3 在二进制中却变成了 0.0100110011001100110011……这样的无限循环小数，无论怎么写都有误差存在。正因为如此，会出现对0.3做十次加法并舍去某些位数后得到2这样的现象。银行和外汇交易等涉及资金操作的场合尤其不欢迎这种系统行为，所以这些场合使用的是定点数或者加三码（excess-3）这样的十进制计算方式。 为什么出现类型 在内存中记录的数值是整数还是浮点数，单靠人的记忆很难避免错误。有没有更为简易的方法呢？ 一种方法是用确定的规则来表示变量名所表达的内容。比如，早期的 FORTRAN 语言使用了一系列规则，指定以 I~N 开头的变量名表示整数，除此以外的表示浮点数。 另一种更好的方法是告诉处理器某某变量是整数，让计算机而不是人去记忆这一信息。这就是变量的类型的声明产生的原因。比如 C 语言中，声明 int x; 表示名字为 x 的变量指向的内存被解释为整数，声明 float y; 表示名字为 y 的变量指向的内存被解释为浮点数。这样通过提供关于类型的信息，处理器在进行运算时，就能自动判断该做整数相加运算还是浮点数相加运算，而不需要人们逐个去指定。 整数之间、浮点数之间的运算计算机参照数据的类型来决定怎样执行。如果 x 和 y 同为整数，就做整数之间的加法运算。如果 x 和 y 同为浮点数，就做浮点数之间的加法运算。 整数与浮点数之间的计算，则依据语言不同采用了不同的方法。有显示使用转换函数(如早期的 FORTRAN 语言)，也有隐式自动转换的(如C)。 C 语言中采用的设计方法是由计算对象的类型来决定是否舍去小数部分。这一方法在很长时间内被很多语言使用，以至于很多程序员都非常习惯，认为理所当然。然而，这个不是恒久不变的物理法则，只不过是人们确立的设计方法而已。因此并不是所有的语言都采用这种设计。 一些语言使用特定的运算符来处理是否保留小数的情况。 1973 年问世的 ML 语言中，整数的除法运算就表达为 x div y， 而浮点数的除法运算表达为 x / y。 OCaml 中也用 x / y 和 x /. y 来区分整数的除法运算和浮点数的除法运算。 1991 年问世的 Python 语言起初使用的是混杂着 C 语言风格的除法运算方式。 2008 年发布的 Python 3.0 中，把 x / y 作为与 x 和 y 类型无关不做舍去的除法运算，带舍去的除法运算用 x // y 来表示。 类型的发展 使用语言中自带的基本数据类型通过组合定义新的类型的这一功能被发明出来。这被称为用户定义型。 如 C 语言中的结构体。 在 C 语言之前的 COBOL 语言中，可以用基本的类型组合起来定义一种带有层次结构的记录类型。 PL/I 语言也有能组合基本类型并创建新的类型的语句 DEFINE STRUCTURE。(结构体（structure）这个术语应该就是从那时候开始使用)的。 其实，不仅限于整数这样的数据，函数这样决定数据如何被处理的对象也被糅合到类型中来了。C++ 语言的设计者本贾尼·斯特劳斯特卢普把用户能自定义的类型当作构造程序的基本要素，把这种类型冠名为类。 后来出现了类型既是功能的观念。这种观念认为，构成结构体和类的类型不应该是全部公开而是最小限度地公开，类型是否一致这个交由编译器来检查，用类型来表达功能，与功能是否一致也是由编译器来检查。因此，只需要将与外部有交互的部分作为类型公开，而实现的细节则隐藏起来。这样类型就被区分为公开部分和非公开部分了。 出现了不包含有具体的实现细节的类型（Java 语言中的接口等）。 另外把函数是否抛出异常这一信息也当作类型。 类型即是功能的方法得到了越来越广泛地应用，但遗憾的是，用类型来实现所有功能的想法却还没有成功。如果它能成功，就很理想了：只要类型一致就不用关心内部的实现细节，功能与类型的不一致交由编译器来检查，编译通过意味着没有 bug。然而，仍有不少类型无法表达的信息，如输入这个数据需要多少处理时间，这个处理过程需要多少内存，线程中是否可以进行这种操作等。至今，这些问题也只能通过人为地读取文档和源代码来判断。 总称型、泛型和模板 通过将不同类型进行组合得到复杂的类型后，使用中会出现想更改其中一部分却又不想全部重新定义的再利用需求。 因此出现了构成要素部分可变的类型，即总称型。想要表现不同的情况时，出现了以类型为参数创建类型的函数(C++ 语言中的模板、Java 语言中的泛型以及 Haskell 语言中的类型构造器可以说就是这种创建类型的机制)。 动态静态类型 到目前为止，我们介绍的类型的机制中，处理器把变量名、保存数值的内存地址、内存里的内容的类型三者作为一个整体来看待。把类型的信息和数值看作整体的方式叫动态类型。作为其反义词，到目前为止介绍的类型机制都叫静态类型。现在大多数的脚本语言都采用了动态类型。 动态类型如何实现的呢？ 是因为在内存上使用了同等类型对待的设计方法。比如 Python 语言中，不管是整数还是浮点数还是字符串，全部都作为 PyObject 对待，开始部分都是一样的。另外在 PyObject 类型的结构中还预留了保存值的类型信息的地方。这一点在其它的脚本语言中也是同样的情况，比如在 Ruby 语言中，任何数值都是 VALUE 类型的。 img ※ 使用次数是指在内存管理中记录这个数值有几处被参照引用的数值（引用计数）。 ※ 字符串的散列值是散列函数的计算结果（详见第 9 章），状态是表示该字符串是否记录在 Internpool 里（处理器是否把该字符串进行唯一处理的标志）。 动态类型的优势与不足 使用这种数值类型处理方法，能实现历来静态类型语言不能实现的灵活处理。运行时确定类型和改变类型成为可能。然而，它也有一些不足。静态类型语言在编译时确定类型，同时编译时也检查了类型的一致性。有了这种类型检查，在实际执行前，便能发现一部分bug。这一点动态类型语言是无法做到的。 类型推断 既不放弃编译时的类型检查，也想尽量减少麻烦的类型声明，要实现这一要求就要用到计算机自动推论确定类型的方法。 同样是使用类型推断这一术语，在不同的语言中，如何做类型推断以及类型推断的能力如何，情况是不一样的。我们来比较一下 Haskell 语言和 Scala 语言。 12345 GHCi&gt; :type identity identityidentity identity :: t -&gt; t&gt; identity identity 11 Scala 语言中类型推断的行为和 Haskell 语言是不一样的。它会首先来定义 identify 函数。 1234567891011121314151617 Scala的对话终端scala&gt; def identity = x =&gt; x&lt;console&gt;:7: error: missing parameter type def identity = x =&gt; x ^scala&gt; def identity[T] = (x : T) =&gt; xidentity: [T]=&gt; T =&gt; Tscala&gt; identity(identity)res0: Nothing =&gt; Nothing = &lt;function1&gt;scala&gt; identity(identity)(1)&lt;console&gt;:9: error: type mismatch; found : Int(1) required: Nothing identity(identity)(1) ^ 由此可见，同样是使用类型推断的表达方法，不同语言指示的具体内容是不一样的。刚刚展示了 Scala 语言推论失败的一个例子，即使推论成功了，在实用价值上有没有优势这个问题上，大家也是有意见分歧的。即使承认它的优势而对类型推断的机制进行修改，在由此带来的作业代价与推论失败的代价之间做权衡之后，再决定否应该做改进和变更将是一个更加困难的问题。 强类型下是否可以做到程序没有bug 类型推断与理论推论之间有对应关系。于是有些语言发出挑战，试图通过使用比 C 语言和 Java 语言更强力的类型系统来证明程序中没有任何 bug。今后在改善类型系统的表现力和类型推断规则方面应该会开展各种研究。 比如，在一个接受 X 型参数返回 Y 型返回值的函数中传递一个 X 型的数值，会得到 Y 型的返回值。这一关于类型的描述与“X 为真在如果 X 则 Y 的情况下，Y 就为真”这一逻辑的描述是相对应的，被称为 Curry-Howard 对应。]]></content>
      <categories>
        <category>编程与生活</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[代码之髓读后感——关于学习]]></title>
    <url>%2Fbooks%2F%E4%BB%A3%E7%A0%81%E4%B9%8B%E9%AB%93-%E5%85%B3%E4%BA%8E%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[一些学习的方法： 具体的知识与抽象的知识 学习之路必经从具体到抽象的这样一个过程。 具体的知识只能应对特定的具体环境，而面对瞬息万变的世界，唯有抽象出来的 元知识才能真正起到作用。具体的知识在特定的环境下可以快速提升你的工作效率，但是环境一变，这种知识就无法使用。而抽象的 元知识， 也需要与具体的实践相结合，才能在实际应用中发挥价值。实践是检验真理的唯一标准。这是毋庸置疑的。 这样也引出来一种判别我们所学有没有成为真正的知识的方式。那就是，可以考察能否具体的举例或者实现来确认。真正的知识是可以使得我们 触类旁通的。只是一味的鹦鹉学舌，重复讲讲，也无法利用知识创造价值。 学习的策略 学习，终究想吃肉一样，一口吃不成个大胖子。到底讲求的还是 细嚼慢咽。这个词中，一个“细”字点出了真意。“分而治之”，小块消化。 这样的思想，在面对少量的信息时，效果很好，效率也可以。 但是，现在这样一个信息爆炸的年代，这样是远远不够的。 所以现在我们就面临着一个问题——如何对信息作取舍？什么样的信息重要，什么样的信息需要，什么样的信息可以被扔掉... 但是，若要得出一个明确的答案，那我们实际上应该对于该领域十分熟悉，水平并不低，那这样不就和我们的现况正好冲突了么？先有鸡还是先有蛋？ 书中提到了一些方法： 向身边的熟悉这些信息的人请教——可能身边没有，而网上的又不一定可信 查阅作者本人的资料——及直接阅读第一手信息——可能会难懂，内容太多，或者语言阻碍等等 阅读其他人的理解总结——二手资料——可信度，准确度等等难以保障 这里面其实暗含着一种对于大量信息进行阅读的一个必要过程（因为我们实际上多数是偏向于后两种），这个过程一般等价于一种煎熬。而且费时费力，有时还不得好。书中提到了三种策略： 从需要的地方开始阅读 从概要开始阅读再细读 从头到尾通篇阅读手抄 各有各的实用价值。 按需获取简单直接迅速便捷 从需要的地方开始阅读，则现需要 明确自己的需求，对于整体内筒有了大致的把握，并且对于该领域已经有些了解。若是一无所知，你也很难知道，哪里对于自己的需求是有实际帮助的。这样的方式对于解决实际问题很有帮助，因为它忽略了一些不相关的，对于自己的当前问题没有目前没有价值的内容。可以节省我们的精力，以用到更需要的地方去。 若是不知道如何把握整体内容，可见下段。 掌握概要把握整体内容再渐进式追求细节 从概要开始阅读，从目录可以了解大体构造，然后就可以开始正文的跳跃式阅读。不要逐字逐句的阅读，首先看副标题和粗体字强调的内容、图表、及其标题。阅读源代码时，首先要看一眼文件架结构和文件名，然后开始粗略读取文件内容，对于定义了的函数和类，以及出现频次较高的名称（函数，变量等等）要扫一眼。阅读代码的时候，切入口不同，其中一种就是使用调试器中的逐步执行功能。依照执行的顺序及调用的层次作为切入口去阅读。这实际上也是先大致掌握整个处理流，然后再深入到具体模块具体函数具体类中。 此法可能会有信息感觉很快就变淡的感觉，可参考下段。 逐章手抄减少漫无目的难以专注的终极方法 这也是最后的方法。当没有明确的目的，简单浏览内容过目即忘，这种学习状态下，只能“抄写”书籍，其他的不要想，直接做知识的搬运工吧——逐章手抄。 对于学习，适当的激励是极为有助的。关键是选择 可以获得成就感的合适的学习间隔。 学习的态度 其实学习最关键的还是实际的应用。 学习即为了解决问题，有明确问题驱动下的学习是极其有效率的。 但是，问题的深度，难度，都将或多或少的影响着学习的进度和考验着人的意志。通常，事实是，大多数人无疾而终，因为所研究的问题，已经超出了自己的理解范围，太过于偏离自己的知识领域。 所以说，真正的学习，还应当是 循序渐进的，即使是有需求的学习，那也是需要起码的了解，是建立在已有知识基础之上的。 让一个毫无编程经验的人去研究游戏制作，虽然他的兴趣不小，激励不少，但是他还是必要经过一系列编程的学习。而且还需要学到一定的层次。不然，即使照着一本专业书籍从头做到尾，轮到自己真正去做自己的想法时，却还是什么也做不出来。 因为这些事并不是想要做就能做的，这中间还是要经过一个漫长的过度期。 有些知识，有些常识，看似和自己的想法相去甚远，但是还是得去学习吸收。因为这就是我们的知识领域扩张的一个必要过程。这样的结果，往往就是我们距离那个美好的梦想越来越近。这就像平地上的一滩水，随着一滴一滴的外来水滴的融入，我们不断扩张，也只有不断的融入，我们才有机会有一刻，实现抵达远方的那份期望。 我们实际上需要的还是脚踏实地。上面的三种思路，在我看来实际上是倒着来的。 逐章手抄-&gt;由概要到细节-&gt;按需索取 这就是一个不断细化的过程。]]></content>
      <categories>
        <category>编程与生活</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[代码之髓读后感——语法&流程&函数&错误处理]]></title>
    <url>%2Fbooks%2F%E4%BB%A3%E7%A0%81%E4%B9%8B%E9%AB%93-%E8%AF%AD%E6%B3%95%26%E6%B5%81%E7%A8%8B%26%E5%87%BD%E6%95%B0%26%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[Perl的设计者：Larry Wall在《Programming Perl》中提出，优秀的程序员有三大美德：懒惰，急躁和傲慢。 懒惰是因为为减少总的能量支出而不遗余力的努力。 急躁是因为无法忍受程序执行的低效。 傲慢是因为容不下错误。 语言的诞生 程序设计语言的出现就是为了解决各种各样的问题，而这些问题以现在的语言是无法更合适的处理。 于是乎，语言之于语言，就是目标问题的差异。 语法的诞生 语法是程序设计者制定的规则。因语言而异。 比如运算符的优先顺序，计算流程的规定等等。 对于式子(2+1)*3 书中提到了比较有特点的FORTH语言，书写成：12+3* 即后缀表达式的形式。利用的是栈来实现。 而LISP语言则是前缀表达式：*+123 从语法树的角度来看，连着实际上就是对于相同的树结构进行了不同的遍历方式。 LISP语言语法简单，代码与语法树容易理解并且对应比较直观，此外它还具有宏这样的语法树替换机制，这两个特点催生了结构化编程等一系列现象。 而语言FORTRAN则是引入了运算符优先级和结合性等复杂语法，使得程序员们编写数学表达式更为习惯。编译程序时，它的语法分析器（把原代码作为字符串，读入解析并建立语法树的程序）会将源代码的字符串转换为语法树。 现代语言大多崇尚FORTRAN的语言风格，追求简单便利的编写规则。 但是因为不存在任何解析矛盾的语法体系的设计是十分困难的，又要不断地融入新语法时又要避免与现有的发生冲突，这样更难，正是因此，现代程序设计语言中仍然保留着不少别扭复杂的编写规则。 流程控制 源自结构化程序设计的诞生。 他们的功能原本都可以借助goto来实现。 if... &amp; if...else... 很早以前存在满足条件后跳的命令。 1949年发明的EDSAC就有“特定内存值大于零时跳转”和“特定内存值为负时跳转”这两条命令。 这使得本来要表达 如果满足条件就执行某事的逻辑，不得不变成了 若是满足条件则跳转到某处执行某事。 而导入if语句则使得逻辑更为清楚，理解更为直观。 while... &amp; break 主要是用来做那些只要有goto语句就能做的事。带来的附加值是程序的易读性和易写性。 for... 让数值渐增的while更加简洁。for主要通过循环次数来控制循环操作。 升级版的foreach，则根据处理的对象来控制循环操作。 但是并非所有的for语句都可以写成foreach。 这些流程控制语句主要是为了实现程序的 简洁易懂 函数 随着程序的庞大，把握全局愈发困难，同时有可能多次要用到相同的操作。函数因此诞生。把一整块代码切分出来而命名。同时伴随着函数的出现，也产生了递归调用这一编程技巧，非常适合处理嵌套形式的数据。 函数的使用使得程序便于理解和重复使用。 从冗长的程序中切分出反复使用的代码将其封装成一个整体。 遇到问题：一个程序中有几处执行相同的代码若是封装，那怎么返回到原来的地方？ 我们希望的是，执行跳转时，记住该位置，之后返回时，又能跳转到该位置后面。 EDSAC的方法是通过修改程序中跳转命令的跳转目的地而实现调用后返回原来的位置。 遇到问题：函数调用者必须知道跳转目的地和返回命令所在地。 创建用来事先记录返回目的地的内存空间，并设计能跳转到该内存空间所记录的地址的命令。 遇到问题：当调用函数X时又调用了Y，返回目的地的内存被覆写，X执行后的返回目的地发生错误。 人们开始使用栈。 这一切都是因为栈这种结构的特性决定的。 由于函数的实际上是代码段的封闭环境，有起始就得有结束，而对于嵌套函数调用而言，必然是越深的，越晚调用的越要及早结束，及早返回，正好符合后入先出的特点。使用栈来实现函数的调用，是极为合适的。 将数据存储的地址依次压入栈中，而栈顶元素内容就是最后被存入数据的地址。 关于递归调用 关键在于如何退出。 错误处理 主要有两种方法： 使用返回值 使用异常 使用返回值 通过判断错误的返回值来判断错误并进行相应的处理。 传递错误信息既可以使用返回值，也可以使用事先定义好的全局变量，还可以传递引用形参等方法。 这种方法可以在C语言中见到。 遇到问题： 遗漏错误——忘记做返回值检查；出错条件难以确保完全... 错误处理导致代码可读性下降——为了避免错误导致出现大量错误处理代码，影响可读性... 对于第二个问题，可以在错误处理相同时，使用goto进行集中处理。从代码形式来看，实现了代码和错误处理的分离。 Linus在《Linux内核编码风格》中推荐使用goto语句把函数的结尾处理集中起来。 小栗子： 12345678int main() &#123; if(!fun(A)) goto ERROR; if(!fun(B)) goto ERROR; if(!fun(C)) goto ERROR; return 0;ERROR: /* 失败处理 */&#125; 使用异常（异常处理），出错后跳转 调用函数前设定好错误处理的代码，错误发生时能跳转至相应的错误处理代码。 C之前出现过事先定义好错误发生时跳转的位置，后来演变为了现在的异常处理。 计算机UNIVACI：在计算中出现溢出时，它会执行000处编写的命令。（即 中断(interrupt)，键盘按键按下，CPU可以接收信号，传达信息的就是中断） 语言COBOL：只有两种针对性的错误处理。见下例： 12READ &lt;文件名&gt; AT END &lt;错误处理语句&gt;ADD &lt;函数名&gt; ON SIZE ERROR &lt;错误处理语句&gt; 语言PL/I: 引入ON语句。可以自定义增加新的错误类型，也可以主动触发新定义的错误类型。 相较于PL/I的错误处理，现代的JAVA，C++，PYTHON语言的方式有所不同，前者先定义好出错的处理操作，在编写可能出错的代码，而后者则是先用try{...}编写可能出错的代码，在编写出错时的处理。 一些历史 这样的设计的改变源自当初John Goodenough的论文中所提出的方法。 命令有可能会抛出异常，而程序员有可能忘记这种可能性，也可能在不正确的地方编写异常处理或者编写不正确类型的异常处理。为使编译器能够对程序员的错误发出警告，减少这种可能性，需要做到两点。一是明确声明命令可能抛出何种异常，二是需要有将可能出错的操作括起来的语句结构。 这里提议的括起来的语句为基础，现代大部分语言采用了先括起来可能出错的操作，再编写错误处理的语句结构。明确声明命令可能抛出何种异常，这个设计方针在 Java语言的异常检查中得以继承。 1977年语言CLU11引入了异常处理的机制，追加了置于命令后面的错误处理语句结构except。CLU语言从最初就具有用begin…end将代码括成块状的功能，这一功能和except相结合，就实现了将可能出错的操作括起来再补充错误处理的代码编写方式。 1983年C++诞生。针对异常处理的语句结构问题从1984年到1989年间经历了多次讨论，C++语言最终确认追加一种语句结构，把关键字try放在那些被括起来的可能出错代码的前面，把关键字catch放在捕捉并处理错误的代码块前面。按照C++语言设计者斯特劳斯特卢普（Bjarne Stroustrup）的说法，try只是一个为了方便理解的修饰符。 另外还使用throw这一关键字作为触发异常的命令，是因为更易理解的raise和singal两个关键字已经在标准库作为函数名字占用了。 1993年发布的Windows NT 3.1在操作系统和C语言编译器导入了结构化异常处理（Structured Exception Handling，SEH）的概念。结构化异常处理中，除了将可能出错的代码括起来的__try和将错误处理的代码括起来的__except之外，还有将即使出错也要执行的代码括起来的__finally。 为什么要引入finally 程序在意料之外结束时，也可以正常的释放锁定的内存和文件等资源，无遗漏的执行成对操作。对于错误处理，要能够不使用返回值检查和goto语句，简洁的实现。 后来Java，Python，Ruby等语言都使用了finally。 C++语言中没有finally。C++语言中使用了一种名叫RAII（Resource Acquisition Is Initialization，资源获取即初始化）的技术。比如，在操作打开了就要关闭的文件对象时，定义来操作该对象的类，用构造函数打开，用析构函数关闭。函数结束时，针对函数局部变量，程序可以自动调用析构函数。 2001年出现的D语言以改良C++语言为目标，反对 RAII是优雅的这一意见。打开了就要关闭这样紧密关联的操作，反映在代码上时，如果能放在相近的位置就容易理解多了。基于这一考虑，D语言中引入了作用域守护（scope guard）的概念。通过使用作用域守护，可以事先定义从某一 作用域（如函数）跳出时执行的操作。 何时抛出异常 发生错误应该停止操作立刻报告，这一设计思想被称为错误优先（fail first）。 异常传递 包括Java在内的很多现代语言的异常处理机制中，异常可以传递到调用方。这一设计有一个很大的问题。那就是，即使看到了函数f的代码也不知道函数f可能会抛出什么异常。有可能是函数f调用的另外的函数g中抛出的异常传递过来的，也有可能是函数g调用的函数h抛出的异常。也就是说，如果不看见函数f调用的所有的函数代码，就无从得知函数f抛出何种异常。万一没有察觉到抛出某种异常的可能性，程序就有可能异常终止。 Goodenough主张为了避免这一问题，需要明确地声明可能抛出的异常。Java语言就采用了这一方针。 其他语言中所谓的异常，Java语言中的throw语句也能抛出，并进一步分为三类： 不应该做异常处理的重大问题 可做异常处理的运行时异常 可做异常处理的其他异常 这里的其他异常叫做 检查型异常，如果在方法之外抛出，就需要在定义方法时声明，throws就是为这个目的准备的。 实现异常处理的小栗子： 1234567891011121314151617181920class Foo &#123; // shippai跑出MyException异常 void shippai() throws MyException &#123; throw new MyException(); &#125; // 1. 使用shippai方法声明`throws MyException` void foo() throws MyException &#123; shippai(); &#125; // 2. 使用catch捕获MyException异常，进行错误处理 void bar() &#123; try &#123; shippai(); &#125;catch(MyException e) &#123; ... &#125; &#125;&#125;class MyException extends Exception(); 异常处理的问题 一个是当函数有不只一个出口时，必须成对处理的操作很难正确地成对处理。另一个是即便看了代码也不知道函数将抛出何种异常。Java语言的开发者为了解决第二个问题导入了检查型异常，但是这种方法并不太被接受。C#语言的开发者一方面承认检查型异常的优势，另一方面希望有更好的方法出现。 检查型异常的问题：可以说检查型异常是一种非常好的机制。但是这种机制并没有很好地普及到其他语言中。因为它太麻烦。一旦throws或try/catch中异常的数目增多，或者某一方法需要追加一种异常，就不得不修改调用了该方法的所有方法，特别麻烦。]]></content>
      <categories>
        <category>编程与生活</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[代码之髓读后感——如何高效的学习语言]]></title>
    <url>%2Fbooks%2F%E4%BB%A3%E7%A0%81%E4%B9%8B%E9%AB%93-%E5%A6%82%E4%BD%95%E9%AB%98%E6%95%88%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%AF%AD%E8%A8%80%2F</url>
    <content type="text"><![CDATA[王垠：如何掌握程序语言 《代码之髓》这本书里提出了三种学习语言的方法—— 如何高效的学习语言？ 在比较中学习 在历史中学习 在实践中学习 在比较中学习 通过比较多种语言，总结出某种语言的独有特点，以及多种语言的共有特点。 借用王垠的一些话—— 重视语言特性，而不是语言。 何一种“语言”，都是各种“语言特性”的组合。 每一种语言里面必然有一套“通用”的特性。比如变量，函数，整数和浮点数运算，等等。这些是每个通用程序语言里面都必须有的，一个都不能少。你只要通过“某种语言”学会了这些特性，掌握这些特性的根本概念，就能随时把这些知识应用到任何其它语言。 掌握了通用的语言特性，剩下的就只剩某些语言“特有”的特性了。研究语言的人都知道，要设计出新的，好的，无害的特性，是非常困难的。所以一般说来，一种好的语言，它所特有的新特性，终究不会超过一两种。如果有个语言号称自己有超过 5 种新特性，那你就得小心了，因为它们带来的和可能不是优势，而是灾难！ 各种语言之中，都有着共性，这是基本，而个性只是部分点。 在比较中学习，可以帮助我们更清楚地意识到： 哪些点是共性——就是上面王垠所谓的“语言特性”，因为这才是语言的基本。掌握了这些共性，对于我们的语言学习有着极大的帮助。这通常确定着一门语言的基本架构方式，大致的代码雏形，以及基本流程。这会告诉我们如何去站立，如何去行走。 哪些点是个性——这个是需要我们深入使用时需要考虑的点。因为一般这些东西，都是一些在当前特定的条件下的，“如此做更为方便”的方法。有时候这些东西可能不是必要的考量，但是掌握他们，对于此门语言使用往往会起到提升整体质量的作用。甚至促使我们对于解决适当的问题有着更为灵活多选的方式。这会告诉我们如何在现在的路上奔跑，跳跃。因为这时候更加关注了这条路上的细节，哪里有坑，哪里有捷径... 因为掌握了语言特性的人都知道，自己需要的特性，在任何语言里面一定有对应的表达方式。 借用在当下的语境中，重视在对比中学习，体会到更多的语言特性，会帮助我们对于语言的学习变得更加有一种直观的感受。我们的思维中，解决问题变得自然而然。编程就是把思维映射到机器中的途径而已。我们已经知道什么样的想法可以用怎样的工具来实现，那实现想法也不就是一段段思路的拼接的过程么？ 我们有时会发现，编程其实并不难，似乎就是需要了解下这门语言中有着哪些工具可供我们利用，我们需要做的就是熟悉这样一套系统，一台大型设备的各种功能。但是我们最后会发现，也只有那些其他工具也具有的功能，才是我们最起码要知道的。那些高精尖的技巧，也不过是在特殊环境下的应对方式。 感觉学起来好像很容易，但是实际上我们在学习中总是会迷失在各种细节中，最典型的就是类似于C中关于输出的格式的翻炒—— 举个夸张点的例子。我发现很多编程培训班和野鸡大学的编程入门课，往往一来就教学生如何使用 printf 打印“Hello World！”，进而要他们记忆 printf 的各种“格式字符”的意义，要他们实现各种复杂格式的打印输出，甚至要求打印到文本文件里，然后再读出来…… 对于掌握编程的核心概念来说，这些其实都是次要的。 总而言之，通过对比学习，你会更容易发现真正的语言特性究竟是什么。学习编程到底要学习什么。 在历史中学习 通过追溯语言的发展历史，了解语言是如何产生，变化，消失的，探寻语言发展演变的轨迹。 有时候，我们在学习中，对于一些功能的学习，往往会不明所以，这其实是因为，对于这种功能，你自己从内在其实并没有觉得理所当然，就像是为什么要有类这一类的问题其实潜在的就在你的心头萦绕着，这使得你的学习，会变得茫然，就像我们最初学习线性代数，上来就整一堆定义，先把你整晕，再来一堆定理，往往不明所以，直接就迷失了，到头来脑袋空空，真正的实际应用中，什么也变不出来。所以我到现在对于线性代数还是充满了敬畏。 在历史中学习，能帮助我们更加清晰地了解那些被掩埋的细节。回看语言设计者为了解决何种问题而创造出这样一种语言，阅读其发展变迁的历史，那些功能的缘由就会变得清晰，你也就会更加认同其中所蕴含的现实意义。 而从历史中学习，也是有助于我们更容易了解到语言的特性，那些非特性的部分为什么被创造出来，是为了解决一种什么样的具体问题。这些都有助于加深我们对于语言的理解。 在实践中学习 亲自进行程序设计，边实践边思考如何编程，才能深入了解设计者的意图，同时也能发现自己原先理解的不到位之处。 这是这行的至上真理。 三种学习的方式，实际上是为了满足我们学习语言的三种情绪：希望快速掌握的迫切，对于未知事物的求真以及对于自我认知的测验]]></content>
      <categories>
        <category>编程与生活</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java学习笔记——基础1]]></title>
    <url>%2Flangs%2Fjava%2FJava%E5%88%9D%E5%85%A5%2F</url>
    <content type="text"><![CDATA[(因为我粗略学过C,C++,Python，了解过他们的一些语法，所以为了使得java的入门更为顺畅，便会忽略一些和C语法相类似的地方，着重点明一些java自己的特色之处。也减轻一下自己写文字的负担。) JAVA是一门静态的强类型的面向对象的重量级的编程语言。 一般写JAVA程序需要的组件是JDK，到甲骨文的网站上下载即可。 初级阶段使用文本编辑器即可，当然，我正处在这个阶段。 此时用来编译运行JAVA文件常用的两条命令是 12javac -encoding utf-8 filename.javajava filename 以上命令就是先使用javac在java文件当前目录下，编译生成字节码文件filename.class，之后再用java解释执行成特定平台的机器码，输出。 这里指定了编码格式，因为java默认文件为unicode编码，但是文件中有中文，会有错误提示。 1错误：编码GBK的不可映射字符 若是你没有这个问题，则可以忽略那个-encoding utf-8 java源文件的命名 和c，c++，python不同，java要求，源文件后缀名为.java，文件名字一般要求和文件中的 public class 同名，若是没有定义，那就没有限制了。这也可以看出，一个java源文件中只能最多有一个 public class。通常建议一个java源文件只定义一个类，让java的源文件主文件名与该源文件中定义的 public class同名。 java程序的结构 java程序必须以类的形式存在，类是java程序的最小单位，java不允许除类外的可执行语句，方法等成分独立存在。他们必须放在类定义里。 例子： 1234567public class HelloWorld&#123; public static void main(String[] args) &#123; System.out.println("Hello World"); &#125;&#125; 观察上例，与文件同名的 public class HelloWorld，内部包含一个main()方法，使用System.out.println(&quot;Hello World&quot;);实现对于文本的输出，类似的有个System.out.print(&quot;Hello World&quot;);，差别就在于前者会换行。 目前用到的main()函数都是这样写的，关于详细内容之后的文章会介绍。 若是存在多个类怎么办？ 可见下例： 12345678910111213141516class Dog&#123; public void jump()&#123; System.out.println("正在执行jump方法"); &#125; public void run()&#123; this.jump(); System.out.println("正在执行run方法"); &#125;&#125;public class DogTest&#123; public static void main(String[] args)&#123; Dog dog = new Dog(); dog.run(); &#125;&#125; 因为只允许有一个public class，故而其他的就是普通的类的形式。 java中的流程控制语句 if (...){ ... } else if{ ... } else{ ... } switch (...){ case ...:{ ... break; } ... default:{ ... } } while (...){ ... } do{ ... }while (...); for (...; ...; ...){ ... } Java中出现了一种迭代式的for的用法。python和C++都有类似的语法结构。 for ( type variableName : array | collection){ // variableName 自动迭代访问每个元素 } 例如： 1234567891011121314public class ForEachTest&#123; public static void main(String[] args) &#123; String[] books = &#123;"轻量级", "fengkuang", "jiangyi"&#125;; // 使用foreach迭代遍历。 for(String book : books) &#123; System.out.println(book); &#125; &#125;&#125;]]></content>
      <categories>
        <category>编程与生活</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构之链表相关算法]]></title>
    <url>%2Flangs%2Fcpp%2F%E9%93%BE%E8%A1%A8%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[问题： 请编写算法实现： (1) InsertAtHead()：从键盘读入正整数n,再读入n个升序整数，用头插法建立带表头结点的降序单链表La； (2) InsertAtTail()：从键盘读入正整数m,再读入m个升序整数，用尾插法建立带表头结点的升序单链表Lb； (3) PrintList()：分别输出显示有序单链表La和Lb; (4) ReverseList()：将降序单链表La就地逆置成升序； (5) MergeList()：将两个升序单链表La和Lb合并成升序单链表Lc并输出显示； (6) DelOdd()：将有序单链表Lc中数据域值为奇数的所有元素删除，然后输出显示。 遇到的比较严重的问题： for条件部分使用变量 123456789101112131415161718192021222324252627282930Status InsertAtHead(LinkList &amp;La)&#123;// 从键盘读入正整数n, 再读入n个升序整数，用头插法建立带表头结点的降序单链表La； int n, j; printf("请输入正整数n:"); scanf("%d", &amp;n); printf("请输入n个升序整数:\n"); LinkList s;//*********************************************************************////这里的n会在后面被变化。所以说，在条件部分使用变量，后面再次使用时要小心//*********************************************************************// for (j = 0; j &lt; n; j++) &#123; scanf("%d", &amp;n); if (n &lt;= 0) return ERROR; s = (LinkList)malloc(sizeof(LinkNode)); s-&gt;number = n; s-&gt;next = La-&gt;next; La-&gt;next = s;//s插到了La的后面 &#125; for (int i = 0; i &lt; 3; i++) &#123; La = La-&gt;next; printf("%d", La-&gt;number); &#125; return OK;&#125; 在链表使用引用传递到子函数指针后，误对同名量进行一些操作，而导致头指针变化，是的后面的继续使用出现不可预知的麻烦。 1234567891011121314printf("\n删减后的链表:\n");p = Lc;//**********************************************////这里使用了新的指针来代替运算，避免了引用量的改变//**********************************************//int j = 1;while (j++)&#123; p = p-&gt;next; printf("%d ", p-&gt;number); if (!p-&gt;next) break;&#125;printf("\n"); 正确版本（待优化）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define TRUE 1#define FALSE 0#define OK 1#define ERROR 0#define INFEASIBLE -1#define OVERFLOW -2typedef int Status;typedef struct LinkNode&#123; int number;// 序号 struct LinkNode* next;// 指向下一个节点的指针&#125;LinkNode, *LinkList;// 指向结构体的指针Status InsertAtHead(LinkList &amp;La)&#123;// 从键盘读入正整数n, 再读入n个升序整数，用头插法建立带表头结点的降序单链表La； La = (LinkList)malloc(sizeof(struct LinkNode)); La-&gt;next = NULL; printf("请输入正整数n:"); int n, j; scanf("%d", &amp;n); printf("请输入%d个升序整数:\n", n); LinkList s; for (j = n; j &gt; 0; j--) &#123; s = (LinkList)malloc(sizeof(LinkNode)); scanf("%d", &amp;s-&gt;number); if (s-&gt;number &lt;= 0) return ERROR; s-&gt;next = La-&gt;next; La-&gt;next = s;//s插到了La的后面 &#125; return OK;&#125;Status InsertAtTail(LinkList &amp;Lb)&#123;// 从键盘读入正整数m,再读入m个升序整数，用尾插法建立带表头结点的升序单链表Lb； Lb = (LinkList)malloc(sizeof(struct LinkNode)); Lb-&gt;next = NULL; printf("请输入正整数m:"); int m, j; scanf("%d", &amp;m); printf("请输入%d个升序整数:\n", m); LinkList s, tail; tail = Lb; for (j = m; j &gt; 0; j--) &#123; s = (LinkList)malloc(sizeof(LinkNode)); scanf("%d", &amp;s-&gt;number); if (s-&gt;number &lt;= 0) return ERROR; s-&gt;next = NULL; tail-&gt;next = s; tail = s;// tail就相当于是帮助s移动的一个游标 &#125; return OK;&#125;Status PrintList(LinkList La, LinkList Lb)&#123;// 分别输出显示有序单链表La和Lb; int i_a, i_b; printf("\nLa:\n"); for (i_a = 0;; i_a++) &#123; La = La-&gt;next; printf("%d ", La-&gt;number); if (!La-&gt;next) break; &#125; printf("\nLb:\n"); for (i_b = 0;; i_b++) &#123; Lb = Lb-&gt;next; printf("%d ", Lb-&gt;number); if (!Lb-&gt;next) break; &#125; return OK;&#125;Status ReverseList(LinkList &amp;La)&#123;// 将降序单链表La就地逆置成升序； LinkList o = La-&gt;next, p, q;// 用于交换的一个中介指针。 p = o-&gt;next; q = p-&gt;next; int index = 1; while (index++) &#123; p-&gt;next = o; if (q == NULL) &#123; La-&gt;next-&gt;next = NULL; La-&gt;next = p; break; &#125; o = p; p = q; q = q-&gt;next; &#125; printf("\n调整后的La:\n"); q = La; int i_a = 1; while (i_a++) &#123; q = q-&gt;next; printf("%d ", q-&gt;number); if (!q-&gt;next) break; &#125; return OK;&#125;Status MergeList(LinkList La, LinkList Lb, LinkList &amp;Lc)&#123;// 将两个升序单链表La和Lb合并成升序单链表Lc并输出显示； LinkList p, q; Lc = Lb; p = La-&gt;next; q = Lb-&gt;next; int index = 1; while (index++) &#123; if (p-&gt;number &lt;= q-&gt;number) &#123;// La中的数据小于Lb的，则插到Lb的q的前面 Lb-&gt;next = p;// 关联上要插入的节点 p = p-&gt;next; Lb = Lb-&gt;next;// Lb移动到插入的节点上 Lb-&gt;next = q; &#125; else &#123;// La中的数据更大，则向后移动Lb和q， Lb = Lb-&gt;next; q = q-&gt;next; &#125; if (!p)// La中的游标先到最后节点 &#123; break; &#125; else if (!q)// Lb中的游标先到最后节点 &#123; Lb-&gt;next = p; break; &#125; &#125; printf("\n合并后的链表:\n"); p = Lc; int j = 1; while (j++) &#123; p = p-&gt;next; printf("%d ", p-&gt;number); if (!p-&gt;next) break; &#125; return OK;&#125;Status DelOdd(LinkList &amp;Lc)&#123;// 将有序单链表Lc中数据域值为奇数的所有元素删除，然后输出显示。 LinkList q = Lc; LinkList p = Lc-&gt;next; int index = 1; while (index++) &#123; if (p-&gt;number % 2)// p是要被删除的 &#123; p = p-&gt;next; if (!p) break; continue; &#125; q-&gt;next = p; q = q-&gt;next; p = p-&gt;next; if (!p) break; &#125; printf("\n删减后的链表:\n"); p = Lc; int j = 1; while (j++) &#123; p = p-&gt;next; printf("%d ", p-&gt;number); if (!p-&gt;next) break; &#125; printf("\n"); return OK;&#125;int main()&#123; LinkList La, Lb, Lc; InsertAtHead(La); InsertAtTail(Lb); PrintList(La, Lb); ReverseList(La); MergeList(La, Lb, Lc); DelOdd(Lc); return OK;&#125;]]></content>
      <categories>
        <category>编程与生活</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[约瑟夫环问题]]></title>
    <url>%2Flangs%2Fcpp%2F%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[问题： 约瑟夫环问题： 问题描述：设有编号为1，2，3……n的n个人顺时针方向围坐一圈，每人有一密码（正整数）。开始时给出一报数上限m，从编号为1的人开始报数，报m的人出列；以后将出列者的密码作为新的m，从顺时针方向紧挨着他的下一个人开始报数……直至所有人出列。试编算法，求出出列顺序。 要求： 用不带头结点的单向循环链表实现 从键盘输入n，m 各人的密码由计算机随机产生(1~10的正整数，也可以自己指定) 测试数据： 假设m的初值为6；n=7。7个人的密码依次是：3,1,7,2,4,8,4 则出列的顺序为: 6,1,4,7,2,3,5 1.0 版本 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465# include &lt;stdio.h&gt;# define NUM 7 //人的总个数int main()&#123; int members[1 + NUM] = &#123; 0, 3, 8, 1, 22, 4, 9, 15 &#125;;//间隔多少个人 //将各个成员的存在状态用一个仅有0和1的int数组表述 //1存在；0退出 int bool[1 + NUM];//存在状态数组 int *p = bool;//循环指针 int i_1;//循环指数 for (i_1 = 1; i_1 &lt;= NUM; i_1++)//初始化 *(p + i_1) = 1; //给定第一步进数 int init_step = 5; //先将特殊的第一个处理掉，后面的有规律 int i_2;//循环指数 if (init_step % NUM != 0)//有余数 &#123; *(p + init_step % NUM) = 0; i_2 = init_step % NUM; &#125; else//无余数 &#123; *(p + NUM) = 0; i_2 = NUM; &#125; printf("退出：%d \n", i_2); //处理后面的数据 int j = 0; //j统计经过的未退出的人数，至上一个退出人的数据后，归零 int count = 1; //统计退出的人数 int death; //退出者的序号 death = i_2; for (;; ++i_2) &#123; if (*(p + i_2) == 1)//此人还活着 &#123; j++; if (j == members[death]) &#123; *(p + i_2) = 0; death = i_2; j = 0; count++; printf("退出：%d \n", i_2); &#125; if (count == NUM) &#123; printf("最后退出：%d \n", i_2); break; &#125; &#125; if (i_2 == NUM) i_2 = 0; &#125; return 0;&#125; 2.0 版本 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100//使用循环链表来解决约瑟夫环问题//需要对链表实现的功能：//1. 初始化链表节点值//2. 删掉对应元素//3. 返回对应值和序号#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define NUM 7#define TRUE 1#define FALSE 0#define OK 1#define ERROR 0#define INFEASIBLE -1#define OVERFLOW -2typedef int Status;typedef struct LinkNode&#123; int number;// 序号 int data;// 对应的步进 struct LinkNode* next;// 指向下一个节点的指针&#125;LinkNode, *LinkList;// 指向结构体的指针int members[NUM] = &#123; 3, 8, 1, 22, 4, 9, 15 &#125;;// 设立尾指针的单循环链表Status ListInit_CL(LinkList &amp;L)&#123; LinkList l = (LinkList)malloc(sizeof(struct LinkNode)); if (!l) exit(OVERFLOW); L = l;// L就当作首，方便最后传出时，L没有变化 int index; for (index = 0; index &lt; NUM-1; index++)// 循环赋值 &#123; l-&gt;data = members[index]; l-&gt;number = index + 1; LinkList q = (LinkList)malloc(sizeof(struct LinkNode));// 临时存储 if (!q) // 分配失败 return OVERFLOW; l-&gt;next = q; l = q;// 移位，当在最后一次的循环中，l所在是空的 q = NULL; free(q); &#125; l-&gt;data = members[index]; l-&gt;number = index + 1; l-&gt;next = L; return OK;&#125;// 删除第i个元素,并由number,data返回其序号和值Status ListDelete_CL(LinkList &amp;L, int i, int &amp;number, int &amp;data)&#123; LinkList q; int j; for (j = 0; j &lt; i - 1; j++)// 移动i-1次，寻找后面第i-1个结点 L = L-&gt;next; q = L-&gt;next;// q指向待删除结点 L-&gt;next = q-&gt;next;// L-&gt;next指向被删除节点的下一个，后面的计数就是从L现在往后第i个了 //返回被删除节点序号与值 data = q-&gt;data; number = q-&gt;number; free(q);// 释放待删除结点 return OK;&#125;int main()&#123; LinkList L = NULL;// 头指针，指向类似的结构体的指针 if (!ListInit_CL(L)) return ERROR; int i, get_data, get_number, given_num; printf("请输入你想要的数字:\n"); scanf("%d", &amp;given_num); ListDelete_CL(L, given_num-1, get_number, get_data);// 删除第一个人对应的下一个人 printf("第%d位被剔除,他的信息是%d\n", get_number, get_data); int index; for (index = 0; index &lt; NUM - 2; index++)// 只删除n-2个，除了前面删除的一个，最后剩下的就是没有删除的。 &#123; ListDelete_CL(L, get_data, get_number, get_data); printf("第%d位被剔除,他的信息是%d\n", get_number, get_data); &#125; printf("第%d位被剩下\n", L-&gt;number); return OK;&#125; 3.0 版本 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100//使用循环链表来解决约瑟夫环问题//需要对链表实现的功能：//1. 初始化链表节点值//2. 删掉对应元素//3. 返回对应值和序号#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;#define TRUE 1#define FALSE 0#define OK 1#define ERROR 0#define INFEASIBLE -1#define OVERFLOW -2typedef int Status;typedef struct LinkNode&#123; int number;// 序号 struct LinkNode* next;// 指向下一个节点的指针&#125;LinkNode, *LinkList;// 指向结构体的指针// 设立尾指针的单循环链表Status ListInit_CL(LinkList &amp;L, int given_people)&#123; LinkList l = (LinkList)malloc(sizeof(struct LinkNode)); if (!l) exit(OVERFLOW); L = l;// L就当作首，方便最后传出时，L没有变化 int index; for (index = 0; index &lt; given_people-1; index++)// 循环赋值 &#123; l-&gt;number = index + 1; LinkList q = (LinkList)malloc(sizeof(struct LinkNode));// 临时存储 if (!q) // 分配失败 return OVERFLOW; l-&gt;next = q; l = q;// 移位，当在最后一次的循环中，l所在是空的 q = NULL; free(q); &#125; l-&gt;number = index + 1; l-&gt;next = L; return OK;&#125;// 删除第i个元素,并由number返回其序号Status ListDelete_CL(LinkList &amp;L, int i, int &amp;number)&#123; LinkList q; int j; for (j = 0; j &lt; i - 1; j++)// 移动i-1次，寻找后面第i-1个结点 L = L-&gt;next; q = L-&gt;next;// q指向待删除结点 L-&gt;next = q-&gt;next;// L-&gt;next指向被删除节点的下一个，后面的计数就是从L现在往后第i个了 //返回被删除节点序号 number = q-&gt;number; free(q);// 释放待删除结点 return OK;&#125;int main()&#123; int i, get_number, given_people, given_maxnum; printf("请输入人数n,报数上限m\n"); scanf("%d %d", &amp;given_people, &amp;given_maxnum); if (given_people &lt;= 0 || given_maxnum &lt;= 0) return ERROR; LinkList L = NULL; if (!ListInit_CL(L, given_people)) return ERROR; srand((unsigned)time(NULL)); int rand_number; ListDelete_CL(L, rand_number = rand() % given_maxnum + 1 - 1, get_number); printf("第%d位被剔除,对应的随机数是%d\n", get_number, rand_number + 1); int index; for (index = 0; index &lt; given_people - 2; index++)// 只删除n-2个，除了前面删除的一个，最后剩下的就是没有删除的。 &#123; ListDelete_CL(L, rand_number = rand() % given_maxnum + 1, get_number); printf("第%d位被剔除,对应的随机数是%d\n", get_number, rand_number); &#125; printf("第%d位被剩下\n", L-&gt;number); return OK;&#125;]]></content>
      <categories>
        <category>编程与生活</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
</search>

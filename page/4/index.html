<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>失乐园</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="失乐园">
<meta property="og:url" content="https://plart.pw/page/4/index.html">
<meta property="og:site_name" content="失乐园">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="失乐园">
  
    <link rel="alternate" href="/atom.xml" title="失乐园" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">失乐园</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">代码与机器</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://plart.pw"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-langs/chuck/chuck12" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/15/langs/chuck/chuck12/" class="article-date">
  <time datetime="2018-02-15T13:40:10.000Z" itemprop="datePublished">2018-02-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/编程与生活/">编程与生活</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/15/langs/chuck/chuck12/">chuck12</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>unit analyzers </p>
<blockquote>
<p>new!!!</p>
</blockquote>
<pre><code>declaring
connecting
controlling over time
representing metadata: the UAnaBlob
representing complex data
performing analysis in UAna networks
using events
built-in unit analyzers
creating (coming soon) 
</code></pre><p>#Unit Analyzers<br>单元分析器</p>
<blockquote>
<p>Unit Analyzers (<strong>UAnae</strong>) are analyis building blocks, similar in concept to unit generators.They perform analysis functions on audio signals and/or metadata input, and produce metadata analysis results as output.<br>(对音频信号或者元数据输入进行分析，把元数据分析结果作为输出)<br>Unit analyzers can be linked together and with unit generators to form analysis/synthesis networks. Like unit generators, several unit analyzers may run concurrently, each dynamically(动态地) controlled at different rates. Because data passed between UAnae is not necessarily audio samples, and the relationship of UAna computation to time is fundamentally (根本地)different than that of UGens (e.g., UAnae might compute on blocks of samples, or on metadata), <em>the connections between UAnae have a different meaning from the connections between UGens formed with the ChucK operator, <code>=&gt;</code></em>. This difference is reflected in the choice of a new connection operator, the upChucK operator: <code>=^</code>. Another key difference between UGens and UAnae is that <strong>UAnae perform analysis (only) on demand, via the <code>upchuck()</code> function (see below).</strong></p>
</blockquote>
<p>Some more quick facts about ChucK unit analyzers:</p>
<ul>
<li>All ChucK unit analyzers are objects (not primitive(原始的) types). </li>
<li>All ChucK unit analyzers inherit(继承) from the <code>UAna</code> class.</li>
<li>The operation <code>foo =^ yah</code>, where foo and yah are UAnae, connects foo to yah.</li>
<li>Unit analyzer parameters(参数) and behaviors(行为) are controlled by calling / chucking to member functions over time, just like unit generators.</li>
<li>Analysis results are always stored in an object called a <code>UAnaBlob</code>. The <code>UAnaBlob</code> contains a time-stamp(时间标记) indicating(表明) when it was computed, and it may store an array(数组) of floats and/or complex(复杂的) values. <em>Each UAna specifies(指定) what information is present in the <code>UAnaBlob</code> it produces.</em>每个UAna指定它产生的UAnaBlob中的信息</li>
<li>All unit analyzers have the function <code>upchuck()</code>, which when called issues <em>a cascade of(一系列的) analysis computations for the unit analyzer and any “upstream(上游的)” unit analyzers on which its analysis depends.</em> (In the example of <code>foo =^ yah</code>,  <code>yah.upchuck()</code> will result in <code>foo</code> first performing its analysis (possibly requesting analysis results from unit analyzers <em>further upstream</em>), then <code>yah</code>, <em>using <code>foo</code>‘s analysis results in its computation</em>. <em><code>upchuck()</code> returns the analysis results in the form of a <code>UAnaBlob</code>.</em>)</li>
<li><p>Unit analyzers are specially integrated into the virtual(虚拟的) machine such that <em>each unit analyzer performs its analysis on its input whenever it or a downstream (下游的)<code>UAna</code> is <code>upchuck()</code>-ed.</em> Therefore, we have the ability to <em>assert(维护) control over the analysis process at any point in time and at any desired control rate</em>.</p>
<p>  <a href="http://chuck.cs.princeton.edu/doc/program/uana.html" target="_blank" rel="noopener">View a list</a> of ChucK’s built-in(嵌入的) unit analyzer(分解) classes </p>
</li>
</ul>
<p>#declaring</p>
<p><em>Unit analyzers (UAnae) are objects, and they need to be instantiated before they can be used.</em></p>
<p>单元分析器是对象，使用前需要实例化</p>
<p>We declare unit analyzers the same way we declare UGens and other objects.</p>
<pre><code>// instantiate an FFT, assign reference to variable f
FFT f;
</code></pre><p>#connecting</p>
<p>The upChucK operator (<code>=^</code>) is <em>only meaningful(有意义的) for unit analyzers</em>. Similar to the behavior(行为) of the ChucK operator between UGens, <strong>using <code>=^</code> to connect one UAna to another</strong> connects <strong>the analysis results of the first to the analysis input of the second</strong>. </p>
<pre><code>// instantiate FFT and flux objects, 
// connect to allow computation of spectrum(频谱) and spectral flux on adc input
adc =&gt; FFT fft =^ Flux flux =&gt; blackhole;
</code></pre><p><strong>Note</strong> that the last UAna in any chain must be chucked to the <code>blackhole</code> or <code>dac</code> <em>to “pull” audio samples from the <code>adc</code> or other unit generators upstream.</em></p>
<p>It is also possible to linearly(线性的) chain many UAnae together in a single statement(声明).<br>In the example below, the analysis of <code>flux_capacitor</code> depends on the results of <code>flux</code>, so the <code>flux</code> object will always perform its analysis computation before the computation of <code>flux_capacitor</code>.分析计算是先后执行的</p>
<pre><code>// Set up analysis on adc, via an FFT object, a spectral flux object, and a
// made-up object called a FluxCapacitor that operates on the flux value.
adc =&gt; FFT f =^ Flux flux =^ FluxCapacitor flux_capacitor =&gt; blackhole;
</code></pre><p><strong>Very importantly</strong>, it is possible to create connection networks containing both <code>UAane</code> and <code>UGens</code>.<br>In the example below, an <code>FFT</code> transforms(改变) two (added) sinusoidal(正弦曲线的) inputs, one of which has reverb(混响) added. An <code>IFFT</code> transforms the spectrum(频谱) back into the time domain(频域转换为时域), and the result is processed(处理) with a third sinusoid(正弦曲线) by a gain object before being played through the <code>dac</code>(被通过dac播放).<br>(No, this example is not supposed to do anything musically interesting, only help you get a feel for the syntax(语法).)<br><strong>Notice</strong> that any connection through which <em>audio samples are passed</em> is denoted(表示) with the <code>=&gt;</code> operator, and the connection through which <em>spectral data is passed (from the FFT to the IFFT)</em> is denoted with the <code>=^</code> operator.</p>
<pre><code>//Chain a sine into a reverb, then perform FFT, then IFFT, then apply gain, then output
SinOsc s =&gt; JCRev r =&gt; FFT f =^ IFFT i =&gt; Gain g =&gt; dac;
// Chuck a second sine into the FFT
SinOsc s2 =&gt; f;
// Chuck a third sine into the final gain
SinOsc s3 =&gt; g;
</code></pre><p><code>FFT</code>, <code>IFFT</code>, and other UAnae that perform transforms between the audio domain and another domain play a special role, as illustrated above(正如上文所述).</p>
<ul>
<li><code>FFT</code> takes audio samples(样品) as input, so unit generators connect to it with the ChucK operator <code>=&gt;</code>. </li>
<li>However, it outputs(输出) analysis results in the spectral domain, so it connects to other <em>UAnae</em> with the upChucK operator <code>=^</code>. </li>
<li>Conversely(相反的), UAnae producing spectral domain output connect to the <code>IFFT</code> using <code>=^</code>, and <code>IFFT</code> can connect to the <code>dac</code> or other <em>UGens</em> using <code>=&gt;</code>. </li>
</ul>
<p>This syntax(语法) allows the programmer to clearly reason about the expected behavior(行为) of <em>an analysis/synthesis(分析综合，分解重构) network</em>, while <strong>it hides the internal mechanics(内部机制) of ChucK timing and sample buffering from the programmer</strong>.</p>
<p>Finally, just as with unit generators, it is possible to dynamically (动态地)<strong>disconnect</strong> (拆开)unit analyzers, using the UnChucK operator (<code>=&lt;</code> or <code>!=&gt;</code>).</p>
<p>#controlling (over time)</p>
<p><strong>In any ChucK program, it is necessary to advance time in order to pull audio samples(样品) through the UGen network and create sound</strong>. Additionally(此外), <em>it is necessary to trigger(引发) analysis computations(计算) explicitly(显式地) in order for any analysis to be performed</em>, and for sound synthesis(合成) that depends on analysis results (e.g., <code>IFFT</code>) to be performed.<br>To explicitly trigger computation at a point in time, the UAna’s <code>upchuck()</code> member function is called. </p>
<p><code>upchuck()</code>：显式引发计算</p>
<p>In the example below, an FFT computation is triggered(引发) <em>every 1024 samples</em>.</p>
<pre><code>adc =&gt; FFT fft =&gt; dac;
// set the FFT to be of of size 2048 samples
2048 =&gt; fft.size;

while (true) {
// let 1024 samples pass
1024::samp =&gt; now;
// trigger the FFT computation on the last 2048 samples (the FFT size)
fft.upchuck();
}
</code></pre><p>In the example above, because the <code>FFT</code> size is 2048 samples, the while-loop causes a standard “sliding-window(滑动窗)” <code>FFT</code> to be computed, where the hop size(步进值) is equal to half a window.<br>However, ChucK allows you to perform analysis using nonstandard, dynamically(动态地) set, or even multiple hop sizes with the same object. 非标准的动态设定或者甚至多倍的步进大小<br>For example, in the code below, the <code>FFT</code> object <code>fft</code> performs computation every 5 seconds as triggered by <code>shred1</code>, and it additionally performs computation at a variable(可变的) rate as triggered by <code>shred2</code>.</p>
<pre><code>adc =&gt; FFT fft =&gt; dac;
2048 =&gt; fft.size;

// spork two shreds: shred1 and shred2
spork ~shred1();
spork ~shred2(); 

// shred1 computes FFT every 5 seconds
fun void shred1() {
    while (true) {
    5::second =&gt; now;
    fft.upchuck();
    }
}

// shred2 computes FFT every n seconds, where n is a random number between 1 and 10
fun void shred2() {
    while (true) {
    Std.rand2f(1, 10)::second =&gt; now;
    fft.upchuck();
    }
}
</code></pre><p>Parameters(参数) of unit analyzers may be controlled and altered at any point in time and at any control rate. We only have to assert(维护) control at the appropriate(适当的) points as we move through time, by setting various parameters of the unit analyzer.<br><em>To set the a value for a parameter of a <code>UAna</code>, a value of the proper type should be ChucKed to the corresponding control function.</em></p>
<pre><code>// connect the input to an FFT
adc =&gt; FFT fft =&gt; blackhole;

//start with a size of 1024 and a Blackman-Harris window
1024 =&gt; fft.size;
Windowing.blackmanHarris(512) =&gt; fft.window;

//advance time and compute FFT
1::minute =&gt; now;
fft.upchuck();

// change window to Hamming
Windowing.hamming(512) =&gt; fft.window;

// let time pass... and carry on.
</code></pre><p><em>Since the control functions are member functions of the unit analyzer, the above syntax(语法) is equilavent to calling functions.</em> For example, the line below could <strong>alternatively(作为选择)</strong> be used to change the FFT window to a Hamming window, as above.</p>
<pre><code>fft.window(Windowing.hamming(512));
</code></pre><p>For a list of unit analyzers and their control methods, consult(查阅) <a href="http://chuck.cs.princeton.edu/doc/program/uana.html" target="_blank" rel="noopener">UAna reference</a>.</p>
<p>Just like unit generators, to read the current value of certain parameters of a <code>Uana</code>, we may call an overloaded function of the same name.就像单元发生器，读取当前Uana的某个参数的值，可以调用重载的同名函数<br>Additionally, assignments(分配) can be chained together when assigning(分配) one value to multiple targets.给多的目标分配一个值时，可以串联起来</p>
<pre><code>// connect adc to FFT
adc =&gt; FFT fft =&gt; blackhole;

// store the current value of the FFT size
fft.size() =&gt; int fft_size;
</code></pre><p>What if a <code>UAna</code> that performs analysis on a group of audio samples(样品) is <code>upchuck()</code>-ed before its internal(内部的) buffer(缓冲区) is filled? This is possible if an FFT of size 1024 is instantiated(实例化), then <code>upchuck()</code>-ed after only 1000 samples, for example. In this case, the empty buffer slots(位置) are treated as 0’s (that is, zero-padding(补零) is applied空的缓存区会被置零). This same behavior(行为) will occur if the FFT object’s size is increased from 1024 to 2048, and then only 1023 samples pass after this change is applied; the last sample in the new (larger) buffer will be 0. <em>Keep in mind</em>, then, that certain analysis computations near the beginning of time and analysis computations after certain parameters(参数) have changed will logically(逻辑上) involve(包含) a short “transient(短暂的)” period.</p>
<pre><code>// connect adc to FFT to blackhole
adc =&gt; FFT fft =&gt; blackhole;
// set the FFT size to 1024 samples
1024 =&gt; fft.size;

// allow 1000 samples to pass
1000::samp =&gt; now;

// compute the FFT: the last 24 spots in the FFT buffer haven&apos;t been filled, so they are zero-ed out归零，置零
// the computation is nevertheless valid and proceeds.计算仍然是有效又有收益的。
fft.upchuck(); 

1::minute =&gt; now; // let time pass for a while

// increase the size of the FFT, and therefore the size of the sample buffer it uses
2048 =&gt; fft.size;

// let 1023 samples pass 
// 会填满1023个缓存点
1023::samp =&gt; now;

// at this point, only 2047 of the 2048 buffer spots have been filled
// 这处，2048中只有2047个缓存位置被填满——怎么算的？1000+24+1023
// the following computation therefore zeros out the last audio buffer spot
// 此句置零了最后一个音频缓存点
fft.upchuck();

1::minute =&gt; now; //let time pass for a while

// now the buffer is happy and full
fft.upchuck(); // proceeds normally on a full buffer
</code></pre><p>#representing metadata: the <code>UAnaBlob</code></p>
<p>It is great to be able to trigger(引发) analysis computations like we’ve been doing above, but what if you want to actually <em>use</em> the analysis results? Luckily, calling the <code>upchuck()</code> function on a <code>UAna</code> returns a reference to <em>an object that stores the results of any <code>UAna</code> analysis</em>, called a <code>UanaBlob</code>. <code>UanaBlob</code>s can contain <strong>an array of floats</strong>, and/or <strong>an array of complex numbers</strong> (see the next section). The meaning and formatting(格式化) of the <code>UanaBlob</code> fields(字段) is different for each <code>UAna</code> subtype(子类型). <code>FFT</code>, for example (see <a href="chuck.cs.princeton.edu/doc/program/uana_full.html#FFT">specification</a>), fills in the complex array with the spectrum(频谱的复数数组) and the floating point array with the magnitude spectrum(振幅谱的浮点数组). Additionally, all <code>UanaBlob</code>s store the time when the <code>blob</code> was last computed.</p>
<p>The example below demonstrates(证明) how one might access(访问) the results of an FFT:</p>
<pre><code>adc =&gt; FFT fft =&gt; blackhole;
// ... set FFT parameters here ...

UAnaBlob blob;

while (true) {
    500::ms =&gt; now; // use hop size of 50 ms
    fft.upchuck() @=&gt; blob; // `store` the result in blob.
    blob.fvals() @=&gt; float mag_spec[]; // get the magnitude spectrum as float array
    blob.cvals() @=&gt; complex spec[]; // get the whole spectrum as complex array
    // get `the first bin`(这个指什么？？？) of the magnitude spectrum
    mag_spec[0] =&gt; float first_mag; 
    blob.fval(0) =&gt; float first_mag2; // equivalent way to get first bin of mag spectrum
    fft.upchuck().fval(0) =&gt; float first_mag3; // yet another equivalent way

    fft.upchuck().cval(0) =&gt; complex first_spec; // similarly, get 1st spectrum bin

    blob.when() =&gt; time when_computed; // get the time it was computed
} 
</code></pre><p><strong>Beware</strong>: whenever a <code>UAna</code> is <code>upchuck()</code>-ed, the contents of its previous <code>UAnaBlob</code> are overwritten.<br>In the following code, <code>blob1</code> and <code>blob2</code> refer to <em>the same <code>UAnaBlob</code></em>. When <code>fft.upchuck()</code> is called the second time, the contents of the <code>UAnaBlob</code> referred to by <code>blob1</code> are overwritten.</p>
<pre><code>adc =&gt; FFT fft =&gt; blackhole;

UAnaBlob blob1, blob2;
1::minute =&gt; now; //let time pass for a while
fft.upchuck() @=&gt; blob1; // blob1 points to `the analysis results`
1::minute =&gt; now; // let time pass again
fft.upchuck() @=&gt; blob2; 
// now both blob1 and blob2 refer to the same object: **the new results!**
</code></pre><p>Also <strong>beware</strong>: if time is not advanced between subsequent(后来的) <code>upchuck()</code>s of a <code>UAna</code>, any <code>upchuck()</code> after the first <em>will not re-compute the analysis</em>, even if <code>UAna</code> parameters have been changed.<br>After the code below, <code>blob</code> refers to a <code>UAnaBlob</code> that is the result of computing the first (size 1024) FFT.指向第一次计算的结果的UAnaBlob</p>
<pre><code>adc =&gt; FFT fft =&gt; blackhole;
1024 =&gt; fft.size;

UAnaBlob blob;
1::minute =&gt; now; //let time pass for a while
fft.upchuck() @=&gt; blob; // blob holds the result of the FFT

512 =&gt; fft.size;
fft.upchuck() @=&gt; blob; 
// time hasn&apos;t advanced since the last computation, so no re-computation is done
</code></pre><p>#representing complex data: the complex and polar types</p>
<p>In order to represent complex data, such as the output of an <code>FFT</code>, two new datatypes have been added to ChucK: complex and polar.</p>
<p>#performing analysis in UAna networks</p>
<p>Often, the computation of one <code>UAna</code> will depend on the computation results of “upstream” <code>UAnae</code>. For example, in the UAna network below, the spectral flux(频谱流量) is computed using the results of an <code>FFT</code>.</p>
<pre><code>adc =&gt; FFT fft =^ Flux flux =&gt; blackhole;
</code></pre><p>The flow of computation in <code>UAna</code> networks is set up(设置) so that every time a <code>UAna</code> <code>a</code> is <code>upchuck()</code>-ed, each <code>UAna</code> whose output is connected to <code>a</code>‘s input via <code>=^</code> is <code>upchuck()</code>-ed first, passing the results to <code>a</code> for it to use.<br>For example, a call to <code>flux.upchuck()</code> will first force <code>fft</code> to compute an FFT on the audio samples in its buffer,<br>then <code>flux</code> will use the <code>UanaBlob</code> from <code>fft</code> to compute the spectral flux.<br>This flow of computation is handled <em>internally by ChucK</em>; you should understand the flow of control, but you don’t need to do <code>fft.upchuck()</code> explicitly. Just writing code like that below will do the trick:</p>
<pre><code>adc =&gt; FFT fft =^ Flux flux =&gt; blackhole;
UAnaBlob blob;
while (true) {
    100::ms =&gt; now;
    flux.upchuck() @=&gt; blob; // causes fft to compute, then computes flux and stores result in blob
}
</code></pre><p>Additionally, each time a <code>UAna</code> <code>upchuck()</code>s, its results are cached(缓存) until time passes. <em>This means that a <code>UAna</code> will only perform its computation once for a particular point in time.</em></p>
<pre><code>adc =&gt; FFT fft =^ Flux flux =&gt; blackhole;
fft =^ Centroid c =&gt; blackhole;

UAnaBlob blob, blob2;
while (true) {
    100::ms =&gt; now;
    flux.upchuck() @=&gt; blob; // causes fft to compute, then computes flux and stores result in blob
    c.upchuck() @=&gt; blob2; // uses cached fft results from previous line to compute centroid
}
</code></pre><p><em>When no <code>upchuck()</code> is performed on a <code>UAna</code>, or on <code>UAnae</code> that depend on it</em>, it will not do computation. For example, in the network below, the flux is never computed.</p>
<pre><code>adc =&gt; FFT fft =^ Flux flux =&gt; blackhole;
UAnaBlob blob;
while (true) {
    100::ms =&gt; now;
    fft.upchuck() @=&gt; blob; // compute fft only
}
</code></pre><p>The combination of  this “compute-on-demand” behavior(这种按需计算行为的组合) and <code>UAna</code> caching means that different <code>UAnae</code> in a network can be <code>upchuck()</code>-ed at various/varying control rates, with maximum efficiency. In the example below, the <code>FFT</code>, <code>centroid</code>, and <code>flux</code> are all <em>computed at different rates</em>. When the analysis times for <code>flux</code> and <code>fft</code> or <code>centroid</code> and <code>fft</code> overlap(同时发生), <code>fft</code> is computed <em>just once</em> due to its <em>internal caching</em>.<br>When it is an analysis time point for <code>fft</code> but not for <code>flux</code>, <code>flux</code> will not be computed.</p>
<pre><code>adc =&gt; FFT fft =^ Flux flux =&gt; blackhole;
fft =^ Centroid c =&gt; blackhole;
UAnaBlob blob1, blob2, blob3;

spork ~do_fft();
spork ~do_flux();
spork ~do_centroid();

while (true) {
    //Keep parent shred going
    1::minute =&gt; now;
    //感觉是多进程必要的一段代码
}

fun void do_fft() {
    while (true) {
        50::ms =&gt; now;
        fft.upchuck() @=&gt; blob1;
    }
}

fun void do_flux() {
    while (true) {
        110::ms =&gt; now;
        flux.upchuck() @=&gt; blob2;
    }
}

fun void do_centroid() {
    while (true) {
        250::ms =&gt; now;
        c.upchuck() @=&gt; blob3;
    }
}
</code></pre><p>An easy way to synchronize analysis of many <code>UAnae</code> is to <code>upchuck()</code> an “agglomerator(凝聚剂)” <code>UAna</code>.<br>In the example below, <code>agglom.upchuck()</code> triggers analysis of <em>all upstream UAnae</em> in the network.<br>Because <code>agglom</code> is only a member of the <code>UAna</code> base class, it does no computation of its own.<br>However, after <code>agglom.upchuck()</code>, all other <code>UAnae</code> will have up-to-date <em>results that are synchronized, computed, and cached</em> so that they are available to be accessed via <code>upchuck()</code> on each <code>UAna</code> (possibly by <em>a different shred</em> waiting for an event– see below).</p>
<pre><code>adc =&gt; FFT fft =^ Flux flux =^ UAna agglom =&gt; blackhole;
fft =^ Centroid centroid =^ agglom;
// could add arbitrarily(反复地) many more UAnae that connect to agglom via =^

while (true) {
100::ms =&gt; now;
    agglom.upchuck(); // forces computation of both centroid and flux (and therefore fft, too)
}
</code></pre><p><em>Because of the dependency and caching behavior of <code>upchuck()</code>-ing in <code>UAna</code> networks, <code>UAna</code> feedback loops should be used with caution</em>. In the network below, each time <code>c</code> is <code>upchuck()</code>-ed, it forces <code>b</code> to compute, which forces <code>a</code> to compute, which then recognizes that <code>b</code> has been traversed(遍历) in this upChucK path but has not been able to complete its computation– thereby(因此) recognizing <code>a</code> loop in the network.<br><code>a</code> then uses <code>b</code>‘s <em>last computed</em> <code>UAnaBlob</code> to perform its computation.<br>This may or may not be desirable, so be careful.可能不理想</p>
<pre><code>adc =&gt; UAna a =^ UAna b =^ Uana c =&gt; blackhole;
b =^ a; // creates a feedback loop

while (true) {
    100::ms =&gt; now;
    c.upchuck(); // involves a using b&apos;s analysis results from 100 ms ago
}
</code></pre><p>Another handy(方便的) UAna for synchronizing feature extraction(同步特征提取) is the <code>FeatureCollector</code>. Calling <code>upchuck()</code> on a <code>FeatureCollector</code> triggers computation of all upstream UAnae, and it concatenates(连接) their output blob data(BLOB二进制大数据) into a feature vector that can be used as input to a classifier(分类器), for example using <a href="http://smirk.cs.princeton.edu/" target="_blank" rel="noopener">smirk</a>.</p>
<pre><code>adc =&gt; FFT fft =^ Flux flux =^ FeatureCollector fc =&gt; blackhole;
fft =^ Centroid centroid =^ fc;
// could add abitrarily many more UAnae that connect to fc via =^

while (true) {
    100::ms =&gt; now;
    // forces computation of both centroid and flux (and therefore fft, too)
    // an vectorBlob&apos;s fvals and cvals will be a concatenation(连接) of the feature values
    fc.upchuck() @=&gt; UAnaBlob vectorBlob; 
}
</code></pre><p>#built-in unit analyzers</p>
<p>ChucK has a number of built-in UAna classes. These classes perform many basic transform(变换) functions (FFT, IFFT) and feature extraction(特征提取) methods (both spectral and time-domain features(频域时域特征)). A list of built-in ChucK <em>unit analyzers</em> can be found <a href="http://chuck.cs.princeton.edu/doc/program/uana.html" target="_blank" rel="noopener">here</a>.</p>
<p>#creating</p>
<p>( someday soon you will be able to implement your own unit analyzers! )<br>单元分析器的个人实现</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://plart.pw/2018/02/15/langs/chuck/chuck12/" data-id="cjognmzs1003ezchsgpul9pbg" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ChucK/">ChucK</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-langs/chuck/chuck13" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/15/langs/chuck/chuck13/" class="article-date">
  <time datetime="2018-02-15T13:40:10.000Z" itemprop="datePublished">2018-02-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/编程与生活/">编程与生活</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/15/langs/chuck/chuck13/">chuck13</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Events"><a href="#Events" class="headerlink" title="Events"></a>Events</h1><p>In addition to the built-in(嵌入的) timing mechanisms(机制) for internal(内部的) control, ChucK has an <strong>event</strong> class to allow exact synchronization(精确同步) across an arbitrary(任意的) number of shreds.<br>事件类允许在任意的进程间实现精确同步</p>
<p><a href="http://chuck.cs.princeton.edu/doc/examples/index.html# event" target="_blank" rel="noopener">View sample code for events</a></p>
<h1 id="what-they-are"><a href="#what-they-are" class="headerlink" title="what they are"></a>what they are</h1><p>ChucK events are a native class(原始类) within the ChucK language. We can create an event objects, and then chuck (<code>=&gt;</code>) that event to <strong>now</strong>.<br>The event places the current shred on the event’s waiting list, suspends(暂停) the current shred (letting time advance from that shred’s point of view).<br>时间放置在当前进程的事件的等待列表里，暂停当前进程(从时间的观测点推进时间)<br>When the event is triggered(引发), one or more of the shreds on its waiting list is shreduled to run immediately.<br>时间被引发时，在进程的等待列表里调用运行<br>This trigger(触发器) may originate(引起) <strong>from another ChucK shred, or from activities taking place outside the Virtual Machine</strong> ( MIDI, OSC, or IPC ).</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// declare event</span></span><br><span class="line">Event e;</span><br><span class="line"></span><br><span class="line"><span class="comment">// function for shred</span></span><br><span class="line"><span class="function">fun <span class="keyword">void</span> <span class="title">eventshred</span><span class="params">( Event event, <span class="built_in">string</span> msg )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// infinite loop</span></span><br><span class="line">    <span class="keyword">while</span> ( <span class="literal">true</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// wait on event</span></span><br><span class="line">        event =&gt; now;</span><br><span class="line">        <span class="comment">// print</span></span><br><span class="line">        &lt;&lt;&lt;msg&gt;&gt;&gt;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// create shreds</span></span><br><span class="line">spork ~ eventshred ( e, <span class="string">"fee"</span> );</span><br><span class="line">spork ~ eventshred ( e, <span class="string">"fi"</span> );</span><br><span class="line">spork ~ eventshred ( e, <span class="string">"fo"</span> );</span><br><span class="line">spork ~ eventshred ( e, <span class="string">"fum"</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">// infinite time loop</span></span><br><span class="line"><span class="keyword">while</span> ( <span class="literal">true</span> )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// either signal or broadcast(信号或广播)</span></span><br><span class="line">    <span class="keyword">if</span>( maybe )</span><br><span class="line">    &#123; </span><br><span class="line">        &lt;&lt;&lt;<span class="string">"signaling..."</span>&gt;&gt;&gt;;</span><br><span class="line">        e.signal();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123; </span><br><span class="line">        &lt;&lt;&lt;<span class="string">"broadcasting..."</span>&gt;&gt;&gt;;</span><br><span class="line">        e.broadcast();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// advance time</span></span><br><span class="line">    <span class="number">0.5</span>::second =&gt; now;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="use"><a href="#use" class="headerlink" title="use"></a>use</h1><p>Chucking an event to <strong>now</strong> <em>suspends the current shred</em>, letting time advance:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// declare Event</span></span><br><span class="line">Event e;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// wait on the event</span></span><br><span class="line">e =&gt; now;</span><br><span class="line"></span><br><span class="line"><span class="comment">// after the event is trigger</span></span><br><span class="line">&lt;&lt;&lt; <span class="string">"I just woke up"</span> &gt;&gt;&gt;;</span><br></pre></td></tr></table></figure>
<p>as shown above, events can be triggered in two ways, <em>depending on the desired behavior(行为).</em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// signal one shred waiting on the event e</span></span><br><span class="line">e.signal();</span><br></pre></td></tr></table></figure>
<p><code>signal()</code> releases the <em>first</em> shred in that event’s queue, and shredule it to run at the current time, respecting(考虑) the order in which shreds were added to the queue.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// wake up all shreds waiting on the event e</span></span><br><span class="line">e.broadcast();</span><br></pre></td></tr></table></figure>
<p><code>broadcast()</code> releases <em>all</em> shreds queued by that event, in the order they were added, and at the same instant in time(在同一瞬间).</p>
<p>The released shreds are shreduled to run immediately. But of course they will respect(涉及) other shreds also shreduled to run at the same time. Furthermore(此外), the shred that called <code>signal()</code> or <code>broadcast()</code> will continue to run until it advances time itself, or yield the virtual(虚拟的) machine without advancing time. (see <code>me.yield()</code> under <a href="http://chuck.cs.princeton.edu/doc/language/spork.html# me" target="_blank" rel="noopener">concurrency</a>)</p>
<h1 id="MIDI-events"><a href="#MIDI-events" class="headerlink" title="MIDI events"></a>MIDI events</h1><p>ChucK contains built-in(嵌入的) MIDI classes to allow for interaction(相互作用) with MIDI based software or devices(装置).</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">MidiIn min;</span><br><span class="line">MidiMsg msg;</span><br><span class="line"></span><br><span class="line"><span class="comment">// open midi receiver, exit on fail</span></span><br><span class="line"><span class="keyword">if</span> ( !min.open(<span class="number">0</span>) ) me.<span class="built_in">exit</span>(); </span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>( <span class="literal">true</span> )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// wait on midi event</span></span><br><span class="line">    min =&gt; now;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// receive midimsg(s)</span></span><br><span class="line">    <span class="keyword">while</span>( min.recv( msg ) )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// print content</span></span><br><span class="line">        &lt;&lt;&lt; msg.data1, msg.data2, msg.data3 &gt;&gt;&gt;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p><strong>MidiIn</strong> is a subclass(子类) of <strong>Event</strong>, and as such can be ChucKed to <strong>now</strong>. MidiIn then takes a MidiMsg object to its <strong>.recv()</strong> method to access the MIDI data.<br><em>As a default, MidiIn events trigger(引发) the <strong>broadcast()</strong> event behavior.</em></p>
<h1 id="OSC-events"><a href="#OSC-events" class="headerlink" title="OSC events"></a>OSC events</h1><p>In addition to MIDI, ChucK has OSC communication classes as well:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// create our OSC receiver</span></span><br><span class="line">OscRecv orec;</span><br><span class="line"><span class="comment">// port 6449</span></span><br><span class="line"><span class="number">6449</span> =&gt; orec.port;</span><br><span class="line"><span class="comment">// start listening (launch thread)</span></span><br><span class="line">orec.listen();</span><br><span class="line"></span><br><span class="line"><span class="function">function <span class="keyword">void</span> <span class="title">rate_control_shred</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="comment">// create an address in the receiver </span></span><br><span class="line">    <span class="comment">// and store it in a new variable.</span></span><br><span class="line">    orec.event(<span class="string">"/sndbuf/buf/rate,f"</span>) @=&gt; OscEvent rate_event; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ( <span class="literal">true</span> )</span><br><span class="line">    &#123; </span><br><span class="line">        rate_event =&gt; now; <span class="comment">// wait for events to arrive.</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// grab the next message from the queue. </span></span><br><span class="line">        <span class="keyword">while</span>( rate_event.nextMsg() != <span class="number">0</span> )</span><br><span class="line">        &#123; </span><br><span class="line">            <span class="comment">// getFloat fetches the expected float</span></span><br><span class="line">            <span class="comment">// as indicated in the type string ",f"</span></span><br><span class="line">            buf.play( rate_event.getFloat() );</span><br><span class="line">            <span class="number">0</span> =&gt; buf.pos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;       </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>The <strong>OscRecv</strong> class listens for incoming OSC packets on the specified(特定的) port. Each instance(实例) of <strong>OscRecv</strong> can create OscEvent objects using its <code>event()</code> method to listen for packets at any valid OSC Address pattern.(在任何合法的OSC地址模式，使用事件方法来监听数据包)</p>
<p>An OscEvent object can then be ChucKed to <strong>now</strong><br><em>to wait for messages to arrive</em>,<br>after which the <strong>nextMsg()</strong> and <strong>get{Float|String|Int}()</strong> methods can be used<br><em>to fetch message data</em>.</p>
<h1 id="creating-custom-events"><a href="#creating-custom-events" class="headerlink" title="creating custom events"></a>creating custom events</h1><p>Events, like any other class, can be subclassed to add functionality(功能) and transmit(传输) data:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// extended event扩充事件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TheEvent</span> <span class="title">extends</span> <span class="title">Event</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// the event</span></span><br><span class="line">TheEvent e;</span><br><span class="line"></span><br><span class="line"><span class="comment">// handler</span></span><br><span class="line"><span class="function">fun <span class="keyword">int</span> <span class="title">hi</span><span class="params">( TheEvent event )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>( <span class="literal">true</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// wait on event</span></span><br><span class="line">        event =&gt; now;</span><br><span class="line">        <span class="comment">// get the data</span></span><br><span class="line">        &lt;&lt;&lt;e.value&gt;&gt;&gt;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// spork</span></span><br><span class="line">spork ~ hi( e );</span><br><span class="line">spork ~ hi( e );</span><br><span class="line">spork ~ hi( e );</span><br><span class="line">spork ~ hi( e );</span><br><span class="line"></span><br><span class="line"><span class="comment">// infinite time loop</span></span><br><span class="line"><span class="keyword">while</span>( <span class="literal">true</span> )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// advance time</span></span><br><span class="line">    <span class="number">1</span>::second =&gt; now;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set data</span></span><br><span class="line">    Math.rand2( <span class="number">0</span>, <span class="number">5</span> ) =&gt; e.value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// signal one waiting shred</span></span><br><span class="line">    e.signal();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://plart.pw/2018/02/15/langs/chuck/chuck13/" data-id="cjognmzs5003gzchspphkm1u3" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ChucK/">ChucK</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-langs/chuck/chuck2" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/15/langs/chuck/chuck2/" class="article-date">
  <time datetime="2018-02-15T13:40:10.000Z" itemprop="datePublished">2018-02-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/编程与生活/">编程与生活</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/15/langs/chuck/chuck2/">chuck2</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>#Overview</p>
<p>ChucK is a strongly-typed, strongly-timed, concurrent(并发的) audio and multimedia(多媒体的) programming language. It is compiled(编译) into virtual(虚拟的) instructions, which is immediately run in the ChucK Virtual Machine. This guide documents the features(特色) of the Language, Compiler, and Virtual Machine for a ChucK programmer. </p>
<p>#running ChucK</p>
<p>…this is a quick overview(综述), see <a href="http://chuck.cs.princeton.edu/doc/program/vm.html" target="_blank" rel="noopener">VM options</a> for a more complete guide to command line options. </p>
<p>To run ChucK with a program/patch called foo.ck simply run chuck and then the name of the file:</p>
<pre><code>chuck foo.ck 
</code></pre><p>To run ChucK with multiple patches concurrently(同时发生) (or the same one multiple times):</p>
<pre><code>chuck foo.ck bar.ck bar.ck boo.ck 
</code></pre><p>…the following probes(探查) the audio system and prints out all available audio devices and MIDI devices. You may then refer to them (by number usually) from the command line or from your program. (again, see VM Options for a complete list)</p>
<pre><code>chuck --probe 
</code></pre><p>ChucK can be run in a different terminal as a host/listener that patches may be sent to. The server should invoke(调用) the –loop flag to specify that the virtual machine should not halt(停止) automatically(自动地) (when the current programs exit).</p>
<pre><code>chuck --loop     
</code></pre><p>(See the guide to <a href="http://chuck.cs.princeton.edu/doc/program/otfp.html" target="_blank" rel="noopener">On-the-fly Programming</a> for more information)</p>
<p>If a ChucK listener is running, we can (from a second terminal) send a program/patch to the listener by using the <code>+</code> command line option:</p>
<pre><code>chuck + foo.ck 
</code></pre><p>Similarly, you can use <code>-</code> and <code>=</code> to <em>remove/replace</em> a patch in the listener, and use <code>^</code> to find out the status. Again, see <a href="http://chuck.cs.princeton.edu/doc/program/otfp.html" target="_blank" rel="noopener">On-the-fly Programming</a> for more information.</p>
<p>To run most of the code or examples in this language specification, you only need to use the basic chuck program.</p>
<p>#comments(注释)</p>
<p>(Note: block comments cannot be nested(嵌入的))</p>
<pre><code>// this is a comment
int foo; // another comment

/* 
   this is a block comment
   still going...
*/
</code></pre><p>#debug print(调试输出)</p>
<p>…we have provided a debug print syntax(语法):</p>
<pre><code>// prints out value of expression
&lt;&lt;&lt; expression &gt;&gt;&gt;;
</code></pre><p>This will print the values and types of any expressions placed within them. This debug print construction may be placed around any non-declaration expression ( non l-value ) and will not affect the execution(执行) of the code. Expressions which represent an object will print the value of that object’s reference(引用) address:</p>
<pre><code>// assign 5 to a newly declared variable
5 =&gt; int i;
// prints &quot;5 : (int)&quot;
&lt;&lt;&lt;i&gt;&gt;&gt;;

// prints &quot;hello! : (string)&quot;
&lt;&lt;&lt;&quot;hello!&quot;&gt;&gt;&gt;; //prints &quot;hello! : (string)&quot;

// prints &quot;3.5 : (float)&quot;
&lt;&lt;&lt;1.0 + 2.5 &gt;&gt;&gt; =&gt; float x;
</code></pre><p>(ChucK中似乎是没有了print这一类)<br>(Chuck中有<code>;</code>，还是类似C的)</p>
<p>For more formatted(格式化) data output(输出), a comma-separated list of expressions will print only their respective(分别的) values (with one space between):</p>
<pre><code>//接上段
// prints &quot;the value of x is 3.5&quot; (x from above)
&lt;&lt;&lt;&quot;the value of x is&quot; , x &gt;&gt;&gt;;

// prints &quot;4 + 5 is 9&quot;
&lt;&lt;&lt;&quot;4 + 5 is&quot;, 4 + 5&gt;&gt;&gt;;

// prints &quot;here are 3 random numbers ? ? ?&quot;
&lt;&lt;&lt;&quot;here are 3 random numbers&quot;, 
    Std.rand2(0,9), 
    Std.rand2(0,9),
    Std.rand2(0,9) &gt;&gt;&gt;; 
</code></pre><blockquote>
<p>输出：<br>C:\Users\abc1\Desktop&gt;chuck “debug print.ck”<br>5 :(int)<br>“hello!” : (string)<br>3.500000 :(float)<br>the value of x is 3.500000<br>4 + 5 is 9<br>here are 3 random numbers 1 8 8</p>
</blockquote>
<p>#reserved words(关键字)</p>
<pre><code>(primitive types原始类型)
    int
    float
    time
    dur
    void
    same (unimplemented未实现的) 

(control structures)
    if
    else
    while
    until
    for
    repeat
    break
    continue
    return
    switch (unimplemented) 

(class keywords)
    class
    extends
    public
    static
    pure
    this
    super (unimplemented)
    interface (unimplemented)
    implements (unimplemented)
    protected (unimplemented)
    private (unimplemented) 

(other chuck keywords)
    function
    fun
    spork
    const
    new 

(special values)
    now
    true
    false
    maybe
    null
    NULL
    me
    pi 

(special : default durations(默认持续时间))
    samp
    ms
    second
    minute
    hour
    day
    week 

(special : global ugens(不理解))
    dac
    adc
    blackhole 
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://plart.pw/2018/02/15/langs/chuck/chuck2/" data-id="cjognmzs9003jzchs6ma3wqp3" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ChucK/">ChucK</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-langs/cpp/Cpp基础_5" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/15/langs/cpp/Cpp基础_5/" class="article-date">
  <time datetime="2018-02-15T13:39:17.000Z" itemprop="datePublished">2018-02-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/编程与生活/">编程与生活</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/15/langs/cpp/Cpp基础_5/">C++基础5</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong><em>程序文件拆分</em></strong><br>函数总是申明在前，调用在后，拆分的程序文件中也要遵循这样的规则，所以，在拆分文件中才需要在多处申明函数。</p>
<ol>
<li>头文件<br>包含头文件，就是将那些函数声明做成一个.h文件，用指令#include来将他们加在程序文件的开始处</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//===========================================</span></span><br><span class="line"><span class="comment">//abc.h</span></span><br><span class="line"><span class="comment">//===========================================</span></span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">()</span></span>;</span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span></span>;</span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">f3</span><span class="params">()</span></span>;</span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">g1</span><span class="params">()</span></span>;</span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">g2</span><span class="params">()</span></span>;</span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">p</span><span class="params">()</span></span>;</span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">h</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//===========================================</span></span><br></pre></td></tr></table></figure>
<p> 然后在每个程序文件的开端包含它，这对于所要使用的函，就无需再次声明了</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//===========================================</span></span><br><span class="line"><span class="comment">//a1.cpp</span></span><br><span class="line"><span class="comment">//===========================================</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"abc.h"</span></span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(...)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(...)</span><br><span class="line">        &#123;</span><br><span class="line">            p();</span><br><span class="line">            g1();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            g2();</span><br><span class="line">            h();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//============================================</span></span><br><span class="line">  <span class="comment">//a2.cpp</span></span><br><span class="line">  <span class="comment">//============================================</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"abc.h"</span></span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        f1();</span><br><span class="line">        f2();</span><br><span class="line">        f3();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f3</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        f1();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">p</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        f3();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//=============================================</span></span><br><span class="line">  <span class="comment">//a3.cpp</span></span><br><span class="line">  <span class="comment">//=============================================</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"abc.h"</span></span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">h</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">viod <span class="title">f2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        g1();</span><br><span class="line">        g2();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">g1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">g2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>界面头文件<br>头文件更重要的作用是在设计阶段（相较于编程阶段）规定界面，也就是通过头文件可以明白的看出，某个程序文件提供了什么服务，这种文件称为用户界面，</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//a1.h</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//a2.h</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">p</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//a3.h</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">g1</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">g2</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">h</span><span class="params">()</span></span>;</span><br><span class="line">通过使用用户界面的形式，上面呢三个文件就可以这样表达：</span><br><span class="line"><span class="comment">//==============================================</span></span><br><span class="line"><span class="comment">//a1.cpp</span></span><br><span class="line"><span class="comment">//==============================================</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"a2.h"</span></span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"a3.h"</span></span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>()</span><br><span class="line">		&#123;&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line"><span class="comment">//==============================================</span></span><br><span class="line"><span class="comment">//a2.cpp</span></span><br><span class="line"><span class="comment">//==============================================	</span></span><br><span class="line">	#include <span class="string">"a1.h"</span></span><br><span class="line">	#include <span class="string">"a3.h"</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">void</span> f3();</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		f1();</span><br><span class="line">		f2();</span><br><span class="line">		f3();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">f3</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">  		f1();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">p</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">  		f3();</span><br><span class="line">  	&#125;</span><br><span class="line">  	</span><br><span class="line"><span class="comment">//===============================================</span></span><br><span class="line"><span class="comment">//a3.h</span></span><br><span class="line"><span class="comment">//===============================================</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"a3.h"</span></span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">h</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">f3</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">  		g1();</span><br><span class="line">  		g2();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">g1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">g2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;&#125;</span><br><span class="line"><span class="comment">//===============================================</span></span><br><span class="line"><span class="number">3.</span> 头文件内容</span><br><span class="line"><span class="comment">//===============================================</span></span><br><span class="line"><span class="comment">//header.h</span></span><br><span class="line"><span class="comment">//===============================================</span></span><br><span class="line">	<span class="keyword">extern</span> <span class="keyword">int</span> n;</span><br><span class="line">	<span class="keyword">extern</span> <span class="keyword">int</span> a[];</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">fn</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">A</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">float</span> pi = <span class="number">3.14</span>;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">fn</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">	<span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">class</span> <span class="title">A</span>&#123;</span>&#125;;</span><br><span class="line">	<span class="keyword">namespace</span> N&#123;&#125;</span><br><span class="line">	<span class="keyword">enum</span> COLOR&#123;&#125;;</span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span>&#125;;</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line">	<span class="comment">// 2016年7月23日22:33:54</span></span><br><span class="line"><span class="comment">//===============================================</span></span><br></pre></td></tr></table></figure>
<p><strong>由于头文件可能出现在一个程序的若干个源程序文件中，所以将一些实体定义放在文件中是不明智的，因为一种定义体在一个程序中只能出现一次</strong></p>
<ol start="4">
<li>全局数据区的整个区域在程序启动时，初始化为零。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://plart.pw/2018/02/15/langs/cpp/Cpp基础_5/" data-id="cjognmztk004lzchsodc0x0r9" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C-C/">C++&C</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-langs/cpp/Cpp基础_4" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/15/langs/cpp/Cpp基础_4/" class="article-date">
  <time datetime="2018-02-15T13:38:58.000Z" itemprop="datePublished">2018-02-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/编程与生活/">编程与生活</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/15/langs/cpp/Cpp基础_4/">C++基础4</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>//程序文件拆分<br>函数总是申明在前，调用在后，拆分的程序文件中也要遵循这样的规则，所以，在拆分文件中才需要在多处申明函数。</p>
<ol start="0">
<li>头文件<br>包含头文件，就是将那些函数声明做成一个.h文件，用指令#include来将他们加在程序文件的开始处<br>//===========================================<br>//abc.h<br>//===========================================<br>void f1();<br>void f2();<br>void f3();<br>void g1();<br>void g2();<br>void p();<br>void h();<br>//===========================================<br>然后在每个程序文件的开端包含它，这对于所要使用的函，就无需再次声明了<br>//===========================================<br>//a1.cpp<br>//===========================================<br>#include “abc.h”<br>void f1(…)<br>{<br> if(…)<br> {<pre><code>p();
g1();
</code></pre> }<br> else<br> {<pre><code>g2();
h();
</code></pre> }<br>}</li>
</ol>
<p>//============================================<br>//a2.cpp<br>//============================================</p>
<p>#include “abc.h”<br>int main()<br>{<br>    f1();<br>    f2();<br>    f3();<br>}<br>void f3()<br>{<br>    f1();<br>}<br>void p()<br>{<br>    f3();<br>}</p>
<p>//=============================================<br>//a3.cpp<br>//=============================================</p>
<p>#include “abc.h”<br>void h()<br>{<br>    …<br>}<br>viod f2()<br>{<br>    g1();<br>    g2();<br>}<br>void g1()<br>{<br>    …<br>}<br>void g2()<br>{<br>    …<br>}</p>
<p>界面头文件</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://plart.pw/2018/02/15/langs/cpp/Cpp基础_4/" data-id="cjognmztg004izchsjyts4ryk" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C-C/">C++&C</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-langs/cpp/Cpp基础_3" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/15/langs/cpp/Cpp基础_3/" class="article-date">
  <time datetime="2018-02-15T13:38:47.000Z" itemprop="datePublished">2018-02-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/编程与生活/">编程与生活</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/15/langs/cpp/Cpp基础_3/">C++基础3</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ol>
<li>未初始化的数组的内容是未定义的，且其末尾的空字符是不确定的，有可能在限定字节外。</li>
<li>未初始化的 string 对象长度自动设定为0。</li>
<li><p>wchar_t, char16_t, char32_t 三种字符串<br>wchar_t title[] = L”Chief Astrogator”;<br>char16_t name[] = u”Felonia Ripova”;<br>char32_t car[] = U”Humber Super Snipe”;</p>
</li>
<li><p>原始(raw)字符串<br>cout &lt;&lt; R”(l”s” / \sajfl; “ “” lafjlj.)” &lt;&lt; endl;<br>原样输出；<br>上面的方式有不足，会把第一个 ‘ )” ‘ 认为是字符串到此结尾；<br>cout &lt;&lt; R”+<em>(“(dkshfk)”), jsfjldsjf.)+</em>“ &lt;&lt; endl;<br>输入时会忽视特殊字符的特殊用途，回车会被添加到原始字符串中；<br>可以使用 Ru UR 等配合wchar_t 等类型的原始字符串；</p>
</li>
<li><p>结构<br>C: struct inflatable goose;<br>C++: inflatable vincent;<br>*访问类成员函数的点号方式即使从访问结构成员变量的方式衍生而来；</p>
</li>
</ol>
<hr>
<p><string><br>struct test<br>{<br>    std::string name;<br>    flaot volume;<br>    double price;<br>};<br>struct inflatable<br>{<br>    char name[20];<br>    float colume;<br>    double prince;<br>};<br>int main()<br>{<br>    inflatable guest =<br>    {<br>        “lasfj”,<br>        1.88,<br>        29.99<br>    };</string></p>
<pre><code>inflatable pal1 = {&quot;sakdfh&quot;, 2.5, 3.0};

inflatable pal2 {&quot;sakdfh&quot;, 2.5, 3.0};

inflatable pal3 {};//全部字节置零**不允许格式上的缩窄转换；
...
return 0;
</code></pre><h2 id=""><a href="#" class="headerlink" title="}"></a>}</h2><p>(the same struct) </p>
<h2 id="choice-bouquet"><a href="#choice-bouquet" class="headerlink" title="choice = bouquet;"></a>choice = bouquet;</h2><p>struct perks<br>{<br>    int sdlkfj;<br>    double skdf;<br>    char a[20];<br>} mr_dlasjfl =<br>{<br>    7,<br>    23.0,<br>    “dsafhk”</p>
<h2 id="分开写的话可能更便于阅读；"><a href="#分开写的话可能更便于阅读；" class="headerlink" title="};//分开写的话可能更便于阅读；"></a>};//分开写的话可能更便于阅读；</h2><p>struct<br>{<br>    int x;<br>    int y;<br>} position;</p>
<h2 id="只有position这一个这种类型的结构，后面也将无法创建；"><a href="#只有position这一个这种类型的结构，后面也将无法创建；" class="headerlink" title="//只有position这一个这种类型的结构，后面也将无法创建；"></a>//只有position这一个这种类型的结构，后面也将无法创建；</h2><p>struct widget<br>{<br>    char brand[20];<br>    int type;<br>    union id<br>    {<br>        long id_num;<br>        char id_char[20];<br>    } id_val;<br>};<br>widget prize;</p>
<h2 id="cin-gt-gt-prize-id-val-id-char"><a href="#cin-gt-gt-prize-id-val-id-char" class="headerlink" title="cin &gt;&gt; prize.id_val.id_char;"></a>cin &gt;&gt; prize.id_val.id_char;</h2><p>struct widget<br>{<br>    char brand[20];<br>    int type;<br>    union//匿名共用体(anonymous union)<br>    {<br>        long id_num;<br>        char id_char[20];<br>    } id_val;<br>};<br>widget prize;<br>cin &gt;&gt; prize.id_char;</p>
<ol start="6">
<li><p>enum 枚举类型<br>可用于设置符号常量，枚举量(enumerator)；<br>enum {a, b, c, d}//0,1,2,3<br>枚举只定义了赋值运算符，没有定义算术运算；</p>
</li>
<li><p>指针使用是一定要先确定地址；<br>int<em> pt;<br>pt = (int</em>) 0xB8000000//地址；</p>
</li>
<li><p>new 运算符<br>指针的真正用武之地在于在运行阶段分配未命名的内存以存储值；<br>C中可以使用库函数malloc()来分配；<br>C++中可以使用new运算符；<br>传统通过内存名称来访问该 int：<br>int higgens;<br>int<em> pt = &higgens;<br>新方式：<br>int</em> pn = new int;<br>//此处pn指向的是内存是没有名称的，可以说指向一个数据对象，指的是为数据项分配的内存块；</p>
</li>
<li><p>delete 运算符<br>使得用完的内存归还内存池；<br>与 new 搭配使用。<br>int<em> ps = new int;<br>delete ps;<br>//仅仅释放ps所指向的内存；
</em>一定要配对使用 new 与 delete,否则会发生内存泄漏(memory leak)，也就是说，被分配的内存再也无法使用。<br>如果泄露严重，则程序会不断寻找更多内存而中止。<br>int<em> ps = new int;<br>delete ps;<br>delete ps;//已释放的内存块再进行释放操作，这样的出的结果是不确定的，意味着什么都会发生，但是对于空指针而言则是安全的<br>int jugs = 5;<br>int</em> pi = %jugs;<br>delete pi;//delete只能用来释放由new分配的内存。</p>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://plart.pw/2018/02/15/langs/cpp/Cpp基础_3/" data-id="cjognmzta004fzchsps1qbmjf" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C-C/">C++&C</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-langs/cpp/Cpp基础_2" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/15/langs/cpp/Cpp基础_2/" class="article-date">
  <time datetime="2018-02-15T13:38:32.000Z" itemprop="datePublished">2018-02-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/编程与生活/">编程与生活</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/15/langs/cpp/Cpp基础_2/">C++基础2</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ol>
<li><p>有效的下标值<br>int a[10];<br>a[10] = 10;</p>
</li>
<li><p>数组初始化<br>只有定义数组时才可以初始化；<br>int a[2] = {1,2};<br>可以用下标分别给数字元素初始化；<br>int a[2];<br>a[0] = 1;<br>a[1] = 2;<br>部分初始化时，未言明部分自动初始化为零；<br>//将数组整体初始化为零，可以显示的将数组第一个元素初始化为零即可<br>//int a[5] = {0};<br>可以不明确指定数组元素数目；<br>int a[] = {1,2,3};<br>int num_elements = sizeof things / sizeof ( int);<br>初始化时可以省略”=”;<br>int a[2] {1,2};<br>//大括号内可以空白，全部元素置零；<br>//int a[2] {};<br>//列表示初始化是不允许缩窄的，要保证数据无误；<br>//int a[] = {1,3.4};</p>
</li>
<li><p>C-风格字符串<br>以空白符结尾，’\0’，ascii = 0；<br>int a[2] = {‘a’, ‘b’}; //不是字符串<br>int a[2] = {‘a’, ‘\0’}; //是字符串<br>//字符串常量(string constant)或字符串字面值(string literal);<br>char a[10] = “god is girl”;<br>char a[] = “god is girl”;<br>//C++对字符串长度无限制；</p>
</li>
<li><p>带引号的字符串<br>cout &lt;&lt; “sdlfjl” “sldfjlj” &lt;&lt; endl;//可以在中间处隔行；<br>cout &lt;&lt; “sdlfjlsldfjlj” &lt;&lt; endl;</p>
</li>
<li><p>strlen()与sizeof();<br><cstring>（老式实现为string.h）<br>提供了很多关于字符串相关的其他函数的声明；<br>strlen();//只计算可见的字符数<br>sizeof();//算出整个数组的长度<br>==&gt;&gt;int a[strlen(strings) + 1];</cstring></p>
</li>
<li><p>cin小缺陷<br>cout &lt;&lt; “Your name” &lt;&lt; endl;<br>char name[10];<br>cin &gt;&gt; name;<br>//输入”Lart Pang”;<br>cout &lt;&lt; “Your university” &lt;&lt; endl;<br>char u_name[10];<br>//想要输DUT；<br>cin &gt;&gt; u_name;<br>…<br>//结果，name[10] == “Lart”;<br>//u_name[10] == “Pang”;<br>==&gt;&gt;<br>//cin 使用空白（空格，制表，换行符）来确定字符串结尾<br>//此处，name中被放入Lart，之后的Pang仍在输入队列中，被存到了u_name中；</p>
</li>
<li><p>读取行输入<br><iostream><br>getline();//到 ‘\n’, 然后停止读取并删掉 ‘\n’；<br>get();// 不删；</iostream></p>
</li>
<li><p>cin.getline(name, 20);<br>//name为要存储输入行的数组名；<br>//20为要读取的字符数；<br>//一行最多读取19个字符；<br>//在存储字符串时用空字符替换换行符；<br>cin.getline(name, 20).getline(u_name. 20);<br>//连续读入两行；</p>
</li>
<li><p>cin.get(name, 20);<br>由于在第一次cin.get();读完后，输入队列中还存在换行符，所以紧跟在其后的另一个cin.get();可能会直接吃掉换行符；<br>所以可以使用下面的两种方法来解决：<br>cin.get(name, 20);<br>cin.get();<br>cin.get(u_name, 20);</p>
</li>
</ol>
<hr>
<p>cin.get(name, 20).get();//cin会返回一个cin对象；</p>
<h2 id="cin-get-u-name-20"><a href="#cin-get-u-name-20" class="headerlink" title="cin.get(u_name, 20);"></a>cin.get(u_name, 20);</h2><p>(cin &gt;&gt; name).get();//cin后也会残留’\n’；<br>==&gt;&gt;</p>
<h2 id="get-getline-的性质上的差异，使得两者有了一些奇特的作用，getline-使用起来明显方便，但是get-的特性使得操作者，可以明确读取停止的原因，是因为数组填满还是读完了一整行；"><a href="#get-getline-的性质上的差异，使得两者有了一些奇特的作用，getline-使用起来明显方便，但是get-的特性使得操作者，可以明确读取停止的原因，是因为数组填满还是读完了一整行；" class="headerlink" title="get(),getline()的性质上的差异，使得两者有了一些奇特的作用，getline()使用起来明显方便，但是get()的特性使得操作者，可以明确读取停止的原因，是因为数组填满还是读完了一整行；"></a>get(),getline()的性质上的差异，使得两者有了一些奇特的作用，getline()使用起来明显方便，但是get()的特性使得操作者，可以明确读取停止的原因，是因为数组填满还是读完了一整行；</h2><p>稍微特别用法：<br>getline(cin ,str);<br>将数据读入到string对象中；<br>这里的getline不是类方法；</p>
<ol start="10">
<li><p>string类<br><string><br>using namesapce std;<br>string str1;<br>string str2 = “asd”;<br>//string str2 = {“asd”};<br>//string str2 {“asd”};<br>cin &gt;&gt; str1;<br>cout &lt;&lt; str1 &lt;&lt; str2[2] &lt;&lt; str2 &lt;&lt; str1[2] &lt;&lt; endl;<br>//string对象和字符数组之间主要区别，可以讲string对象声明为简单变量而不是数组；<br>//string对象能在初始化时自动调节大小；</string></p>
</li>
<li><p>string简单操作<br>string str3;<br>str3 = str1 + str2;<br>str3 = str1;<br>str1 += str2;//字符串拼接；<br>int len1 = str1.size();<br>//str1是string类中的一个对象，而size()是string类的一个方法。<br>//方法是一个函数，只能通过其所属的类的对象进行调用；<br>//C++中的类，对象，方法<br>//C函数使用参数来确定要使用那个字符串，而C++string类对象，是使用对象名和句点运算符来指出要使用那个字符串；<br>int len2 = strlen(str1);</p>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://plart.pw/2018/02/15/langs/cpp/Cpp基础_2/" data-id="cjognmzt6004czchst24qd4mk" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C-C/">C++&C</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-langs/cpp/Cpp基础_1" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/15/langs/cpp/Cpp基础_1/" class="article-date">
  <time datetime="2018-02-15T13:38:12.000Z" itemprop="datePublished">2018-02-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/编程与生活/">编程与生活</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/15/langs/cpp/Cpp基础_1/">C++基础1</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>OOP的本质就是设计并扩展自己的数据类型。</p>
<ol>
<li><p>变量名命名时，以两个下划线或下划线和大写字母打头的名称被保留给实现（编译器及其使用的资源）使用，以一个下划线开头的名称被保留给，实现，用作全局标识符。</p>
</li>
<li><p>C++中对于名称长度没有限制，但是有些平台有长度限制。</p>
</li>
<li><p>C++赋值方式：<br>（大括号初始化器，适用于任何类型，等号可有可无）</p>
<ol>
<li>int x = 1;</li>
<li>int x = {1};//将大括号初始化器用于单变量</li>
<li>int x{1}；</li>
<li>int x{};//置零</li>
<li>int x = {1}；//置零</li>
</ol>
</li>
<li><p>int类型被设定为对于目标计算机而言效率最高的长度。</p>
</li>
<li><p>cout 关于进制转换<br>std::cout;<br>std::endl;<br>std::hex;<br>std::oct;<br>code:<br> using namespace std;<br> int main()<br> {</p>
<pre><code>int chest = 42;
int waist = 42;
int inseam = 42;

cout &lt;&lt; &quot;chest = &quot; &lt;&lt; chest &lt;&lt; &quot; (decimal for 42)&quot; &lt;&lt; endl;
cout &lt;&lt; hex;
cout &lt;&lt; &quot;waist = &quot; &lt;&lt; waist &lt;&lt; &quot; (hexadecimal for 42)&quot; &lt;&lt; endl;
cout &lt;&lt; oct;
cout &lt;&lt; &quot;inseam = &quot; &lt;&lt; inseam &lt;&lt; &quot; (octal for 42)&quot; &lt;&lt; endl;
return 0;
</code></pre><p> }<br>(cout &lt;&lt; hex;不会显示任何内容，只是会改变cout显示整数的方式。）</p>
</li>
<li><p>数值类型<br>220L;<br>220LU == 220UL;<br>220ll == 220LL;<br>220ull == 220ULL == 220uLL == 220Ull;<br>(十六进制常用来表示内存地址，而内存地址是没有符号的，所以多用 “usigned int” 类型来表示十六位地址）</p>
</li>
<li><p>‘字符’ “字符串”</p>
</li>
<li><p>cout.put();//cout的成员函数<br>显示一个字符；<br> int main()<br> {</p>
<pre><code>char ch = &apos;M&apos;;
int i = ch;
cout &lt;&lt; &quot;The ASCII code for &quot; &lt;&lt; ch &lt;&lt; &quot; is &quot; &lt;&lt; i &lt;&lt; endl;

cout &lt;&lt; &quot;Add one to the character code:&quot; &lt;&lt; endl;
ch = ch + 1;
i = ch;
cout &lt;&lt; &quot;The ASCII code for &quot; &lt;&lt; ch &lt;&lt; &quot; is &quot; &lt;&lt; i &lt;&lt; endl;

cout &lt;&lt; &quot;Displaying char ch using cout.put(ch): &quot;;
cout.put(ch) //&lt;&lt; &apos;!&apos;;
//cout.put(&apos;!&apos;);//两个二选一即可；
cout &lt;&lt; endl &lt;&lt; &quot;Done&quot; &lt;&lt; endl;
return 0;
</code></pre><p> }</p>
</li>
<li><p>bool<br>bool is_ready = true; //“is_ready” assigned true or 1;</p>
</li>
<li><p>创建符号常量<br>尽量使用const来创建，而非”#define”;<br>const type name = value;<br>声明时没有提供值，则该常量的值将是不确定的，且无法修改。<br>好处：<br>1, 限定类型<br>2, 限定范围</p>
</li>
<li><p>+d.dddE+n<br>指的是将小数点向右移动n位，<br>+换成~时，表示将小数点向左移动n位。</p>
</li>
<li><p>setf成员函数可以把强行把浮点数输出时用定点表示法<br>int main()<br>{</p>
<pre><code>cout.setf(ios_base::fixed, ios_base::floatfield);
cout &lt;&lt; &quot;Integer division: 9/5 = &quot; &lt;&lt; 9 / 5 &lt;&lt; endl;
cout &lt;&lt; &quot;Floating-point division: 9.0 / 5.0 = &quot;;
cout &lt;&lt; 9.0 / 5.0 &lt;&lt; endl;
cout &lt;&lt; &quot;Mixed division: 9.0 / 5 = &quot; &lt;&lt; 9.0 / 5 &lt;&lt; endl;
cout &lt;&lt; &quot;double constants: 1e7 / 9.0 = &quot;;
cout &lt;&lt; 1.e7 / 9.0 &lt;&lt; endl;
cout &lt;&lt; &quot;float constants: 1e7f / 9.0f = &quot;;
cout &lt;&lt; 1.e7f / 9.0f &lt;&lt; endl;
return 0;
</code></pre><p>}</p>
</li>
<li><p>浮点类型默认为double类型</p>
</li>
<li><p>以{}方式初始化时进行的转换<br>使用大括号的初始化，陈作列表初始化，因为这种初始化，常用于给复杂的数据类型提供值列表，对类型转换更为严格，<br>此类初始化不允许对数据进行缩窄（narrowing），即使得变量类型有可能无法表示赋给它的值。</p>
</li>
<li><p>整型提升（integral promotion）<br>例如将 bool,char,unsigned char,…值转换为 int </p>
</li>
<li><p>强制转换<br>(typeName) value<br>typeName (value)<br>static_cast<typename> (value)//转换要求很严格</typename></p>
</li>
<li><p>运算符重载<br>使用相同符号，进行多种操作，叫做运算符重载(operator overloading)</p>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://plart.pw/2018/02/15/langs/cpp/Cpp基础_1/" data-id="cjognmzt4004azchsjbswizr6" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C-C/">C++&C</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-ee/认证无线电网络的多目标资源优化-论文阅读" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/15/ee/认证无线电网络的多目标资源优化-论文阅读/" class="article-date">
  <time datetime="2018-02-15T10:44:22.000Z" itemprop="datePublished">2018-02-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/技术与进步/">技术与进步</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/15/ee/认证无线电网络的多目标资源优化-论文阅读/">认证无线电网络的多目标资源优化-论文阅读</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>Multi-Objective Resource Allocation in a NOMA<br>Cognitive Radio Network With a Practical<br>Non-Linear Energy Harvesting Model</p>
<p>Yuhao Wang, Senior Member, IEEE, Yuhang Wu, Fuhui Zhou, Member, IEEE,<br>Zheng Chu, Member, IEEE, Yongpeng Wu, Senior Member, IEEE, Fei Yuan</p>
</blockquote>
<p>主要内容：</p>
<p>文章提出了一种基于同时传输信息与功率的无线传输技术的非正交多址的认证无线电网络的多目标资源优化（每个收集能量的次级用户收集的能量都为最大时）问题。</p>
<p>主要提出了一种偏重于实际的非线性能量收集模型，相应的提出了一种连续凸逼近的解决方法来解决这种情况下的最优分配策略。</p>
<p>文章背景：</p>
<ol>
<li>目前固定的频谱分配策略不再适应频谱使用的需求的增长。</li>
<li>下一代通信技术的提出，有6大新能指标和3大效率指标。<ul>
<li>6大性能指标：用户体验速率，流量密度，连接数密度，端到端时延，峰值速率，移动性</li>
<li>3大效率指标：频谱效率(SE)，能效(EE)，成本效率。</li>
</ul>
</li>
<li>新的多址接入技术的采用（非正交多址接入，文中主要指基于功率域复用的非正交多址接入技术，多天线PD-NOMA）。<br> 主要思想是恨据用户信道条件差异分配功率,为了保证用户的公平性,给差用户分配更多的功率;从而在保证差的用户的性能条件下,提高系统的整体性能。接收端利用串行干扰消除(SIC)技术来移除不同用户间的干扰。</li>
<li>新的能量供应手段（使用能量获取技术供能）。<br> 通过从周围环境中获取能量，提供几乎无限的能量，从而极大地延长网络的运行时间；同时使用能量获取设备，可以免去布线等约束，从而极大地提高部暑节点的便利性。与传统能量供电网络不同的是，传统供能网络由于能量不是约束条件，其优化的目标是提高网络服务质量，如提高系统的吞吐量或降低用户的阻塞率，而在基于能量获取计数的无线系统中，由于能量获取技术的限制，必须要在优化能量使用的基础上考虑网络中的服务质量优化问题。<br> 本文中，关于能量获取的无线通信研究主要是SWIPT，信息与能量流同时传输系统。SWIPT是一种新的传输模式,可提高5G网络的能量效率。</li>
<li>对于能量获取设备的组网技术采用认知无线电网络。<br> 在认知无线电网络中，认知节点具备学习能力，通过与周围环境交互信息来感知和利用该空间中的可用频谱。<br> 因此，认知无线电及数的出现将极大的提高无线通信系统的频谱利用率。通常假设次级用户使用能量获取技术。<br> 其中发送端的能量有电网或其他稳定的能量来源供应，而接收端通信使用的能量则从发送端的电磁波中获取之后再用于信息的发送，类似于无线充电技术，一般称为无线能量传输，即SWIPT。</li>
</ol>
<p>更为详细的记录：</p>
<ol>
<li><p>频谱使用现状</p>
<p> 目前世界上大多数国家的频谱管理都采用固定的频谱分配策略，频谱资源由政府部门管理并分配给固定的授权用户，这样能确保各个用户之间避免过多的相互干扰，同时使得用户能够在一个稳定的环境中更好的利用频谱，然而，随着频谱使用的需求的不断增长，这种固定频谱分配策略的缺点也越来越明显，已经不能满足日益发展的通信需要了。</p>
<p> 频谱资源一般可以分为两类，一类是受到严格限制和保护的频谱，另一类是开放的频谱资源，满足某一规范和标准的设备都可以接入和使用该频谱，但必须要保证不对其他用户造成干扰，称之为未授权频谱。现实的情况可以知道，仅有一小部分授权频谱被充分利用，而大部分未授权频谱的使用却非常拥挤。</p>
</li>
<li><p>多址接入技术</p>
<p> 多址接入技术是每一代通信技术的关键，其目的是让多个用户能同时接入基站，享受基站提供的通信服务，保证各个用户之间的信号不会互相干扰。</p>
<p> 在传统的正交多址接入(OrthogonalMultipleAccess,OMA)方式中,不同用户被分配到相互独立或彼此正交的资源上进行传输,比如:时域、频域、码域等正交资源,以避免不同资源块之间的干扰。</p>
<p> 为了进一步提高频谱利用率,第四代移动通信系统引入了正交频分多址(OFDMA)接入技术,即通过将一系列在频域互不重叠的子载波分配给不同用户来完成多址接入。由于正交多址接入方式中一个正交资源只允许分配一个用户,这严重限制了区域的吞吐量和设备连接数。为了满足5G网络海量接入和超高容量需求,非正交多址接入技术(NOMA)被认为是下一代移动通信中最为关键的技术。从根本上来说,非正交多址允许可控的多用户干扰在接收机检测复杂度可容忍条件下来增加非正交的资源分配,从而提高系统的频谱效率。</p>
<p> 这里就得提到5G技术的6大性能指标：</p>
<ul>
<li>6大性能指标：用户体验速率，流量密度，连接数密度，端到端时延，峰值速率，移动性</li>
<li><p>3大效率指标：频谱效率(SE)，能效(EE)，成本效率。</p>
<p>主流的非正交多址接入主要包括:</p>
</li>
<li><p>基于功率域复用的非正交多址接入技术-PD-NOMA;</p>
</li>
<li><p>引基于码域复用的稀疏码多址接入技术-SCMA</p>
<p>PD-NOMA引入了新的维度-功率域,通过叠加编码的思想来发送信号,使得信道条件不同的用户可共享相同的频谱资源,比如时域、频域、码域等正交资源。功率复用的主要思想是恨据用户信道条件差异分配功率,为了保证用户的公平性,给差用户分配更多的功率;从而在保证差的用户的性能条件下,提高系统的整体性能。接收端利用串行干扰消除(SIC)技术来移除不同用户间的干扰。</p>
<p>SIC的主要思想是接收信号根据用户信道条件的差异性逐级消除用户间干扰。比如下行PD-NOMA,某个用户对接收的信号从信道条件最差的用户开始检测其信号,并把该信号从多址干扰中移除；接若检测信道条件次差的用户的信号并移除,以此类推,消除所有信道条件比该用户差的信号。</p>
<p>目前对PD-NOMA技术的研究主要包巧:</p>
</li>
<li><p>单天线PD-NOMA;</p>
</li>
<li>协作PD-NOMA；</li>
<li>多天线PD-NOMA。</li>
</ul>
</li>
<li><p>能量获取技术</p>
<p> 在传统的能量受限的无线网络(如无线感知网络)中，感知节点通常使用电池供电, 乏稳定可靠的能量来源，运行时长受限。尽管可以适过替换电池或给电池重靳充电来廷长网络的运行时间，但通常存在替换不便、成本本过高或非常危险(如安装在腐蚀性环境中的传感器)等问题, 有时甚至不可能进行替换(如植入人体的传感器器)。在这些网络中，使用能量获取技术供能的设备优势明显：通过从周围环境中获取能量，提供几乎无限的能量，从而极大地延长网络的运行时间；同时使用能量获取设备，可以免去布线等约束，从而极大地提高部暑节点的便利性。</p>
<p> 对能量获取拉术的研究最初集中在以太阳能、风能等可再生能源为能量来源的设备，而能量获取技术的含义井不仅仅包括可再生能源。通信节点从周围环境中获取的能量并不一定指太阳能、风能等清洁能源，也可能指其它设备特定发送的能量，类似于无线充电技术。</p>
<p> 在无线通信系统中应用能量获取技术的时候，由于能量来源的变化，传统稳定的电网能量或有限的电池能量供能的网络问题即约束条件不再适用，需要基于能量获取技术的他特点对无线通信的算法、网络协议甚至传输节点的硬件进行重新设计。与传统能量供电网络不同的是，传统供能网络由于能量不是约束条件，其优化的目标是提高网络服务质量，如提高系统的吞吐量或降低用户的阻塞率，而在基于能量获取计数的无线系统中，由于能量获取技术的限制，必须要在优化能量使用的基础上考虑网络中的服务质量优化问题。</p>
<p> 本文中，关于能量获取的无线通信研究主要是SWIPT，信息与能量流同时传输系统。主要研究的是能量来源稳定的发送节点向对个接收终端同时进行信息与能量流的传输问题。</p>
<p> 对于能量获取设备的组网研究，本文主要研究了认知无线电网络。在认知无线电网络中，认知节点具备学习能力，通过与周围环境交互信息来感知和利用该空间中的可用频谱。通常假设次级用户使用能量获取技术。</p>
<p> 对于能量获取设备组网，其能量获取的节点为发送节点，即发送端从周围环境中获取能量，并将收集的能量用于信息的发送。目前已有研究者将目关投向通信过程中信息的接收方获取能量的研究。其中发送端的能量有电网或其他稳定的能量来源供应，而接收端通信使用的能量则从发送端的电磁波中获取之后再用于信息的发送，类似于无线充电技术，一般称为无线能量传输，即SWIPT。</p>
<p> SWIPT技术研究的可行性是基于以下事实：传输信息的无线电波在电磁能量可以被获取的情况下，也是一种能量的来源，也可以被获取。在这个研究方向中，接收端可以接受信息，也可以接收能量，或者两者同时进行。受实际电路限制，接收端不可能同时对同一个信息进行解调与能量收集。因此，SWIPT中接收端同时对信息解调和能量接收的无线电磁流的接受模式通常有两种，一种是时域切换，另一种为能量分割（PS）。本文介绍的是能量分割的工作模式。接受的信号被一个能量分割器分割为两路，一路传输给能量获取单元，一路传输给信息处理单元。</p>
<p> 对于SWIPT系统方向地研究，多与物理层多输入多输出天线技术相关，即发送节点与接受节点都装备了多天线，而研究的场景相对较为简单。</p>
<p> 本文为了提高能量效率和频谱效率，在实际的非线性能量获取模型下，研究了一种同时具有无线信息和功率传输的非正交多址认知无线网络。提出了一种多目标资源优化问题，以最大限度地提高每个能量采集接收机的收集力。这个问题是非凸的，而且很难解决。本文采用加权Tchebycheff方法求解该问题<br> 结果表明，非线性能量收集模型的性能优于线性能量收集模型。</p>
<p> SWIPT是一种新的传输模式,可提高5G网络的能量效率。其主要思想是节点可从自然界获取能量,如风能、太阳能、机械振动等。</p>
</li>
<li><p>认知无线电</p>
<p> 软件无线电视近几年来提出的一种实现无线通信的新概念和新体制，是作为多频带多模式的个人通信系统平台而出现的。其以硬件作为无线通信的基本平台，无线通信功能尽可能用软件实现。这样设计的无线通信系统具有很好的通用性、灵活性，使系统互联合升级备案的非常方便。</p>
<p> 软件无线电为扩展平台的认知无线电是一种新的智能无线通信技术，它可以感知到周围环境得环境特征，采用构建理解的方法进行学习，通过无线电知识描述语言（RKRL）与通信网络进行智能交流，实时调整传输参数，是系统的无线规则与输入的无线电激励的变化相适应，已达到无论和是何地通信系统的高可靠性和频谱利用的高效性，认知无线电的一个最大优势是无线用户可以通过该技术实现“频谱共享”，认知无线电在特定频段上进行探索，如果发现该频段当前未被使用，可以在不影响受邀用户的前提下使用该频段。</p>
<p> 这种被分配给某出示授权用户但在特定时间和具体位置该用户没有使用的频带被称为“频带空穴”。如果该频段的首要用户恢复无线传输，那么认知无线电设备就跳转到其他频段或者改变传输功率、调制方式等手段来避免对首要用户产生干扰。因此，认知无线电及数的出现将极大的提高无线通信系统的频谱利用率。</p>
<p> 认知无线电技术具备认知能力与重构能力，认知能力指的是感知的能力，并且可以从周围环境中收集信息，例如传输频率、带宽、功率等。重构能力指的是为了达到最佳的性能，根据感知信息自适应地调整操作参数。</p>
<p> 认知无线电的关键技术是频谱感知与频谱接入。频谱感知、频谱接入、频谱管理、频谱切换。</p>
</li>
<li><p>文章概述</p>
<p> 认为，将NOMA与SWIPT相结合，可以同时改善SE和EE。</p>
<p> 第I部分主要介绍了一些相关领域的研究成果。其中在B部分中，提到了，本文研究的特别之处。将SWIPT技术应用于NOMA认知无线电网络中，在多目标资源分配问题中研究了一个实际的非线性EH模型。</p>
<p> 在实际的非线性能量收集模型下，研究了非正交多址接入技术下的认知无线电系统的多目标资源优化问题，使得在最小传输速率和最大干扰功率的约束下，每个单元的收获能量最大。</p>
<p> 由于该问题具有非凸性不好解决，这里利用了加权切比雪夫方法，转化为单目标优化问题，并提出了一种基于逐次凸逼近的求解算法来解决这个问题。</p>
</li>
<li><p>通信网络中相关设定</p>
<p> PBS表示主基站(PrimaryBaseStation)，通过光缆可以将各类监测数据、感知数据、计量数据等业务数据传输到变电站内的各种应用系统子站，也可以根据需要将数据通过电力骨干网络(SDH等)传输到省电力公司内的系统主站。</p>
<p> CBS表示认知基站(CognitiveBaseStation)，通过光缆与主基站连接进行信息交互，通过无线方式与次用户通信。</p>
<p> PU表示主用户即授权用户(PrimaryUser)，SU表示次用户即认知用户(SecondaryUser)，这里的用户在实际应用场景中泛指各种无线通信终端，各类业务数据通过授权用户或次用户将数据传输到基站，SB表示频谱经纪人(SpectrumBroker)，通过光缆或者网线形式与认知基站进行信息交互。</p>
<p> 认知基站负责认知用户的控制和管理，主要包括对认知用户的感知结果进行融合、空闲信道资源分配、接入及切换管理。</p>
<p> 频谱使用区域分授权频段区域和非授权频段区域，在授权频段区域，认知基站与主基站进行信息交互，降低感知目标频段的盲目性，认知用户根据认知基站的交互信息，感知授权用户的授权频段的空闲情况并利用。</p>
<p> 在非授权频段区域，认知用户感知非授权频段的使用情况并进行竞争利用，能够及时规避干扰频段，使用动态分配的频谱资源，在该区域中频谱经纪人充当协调者角色，负责不同认知网络之间的频谱资源协调管理。</p>
<p> 接受的信号被一个能量分割器分割为两路，一路传输给能量获取单元，一路传输给信息处理单元。其中由两个SU（SUi，SUj）来解码，处理信息，而剩余的N-2个SU来执行能量获取。所有设备都配备了单天线。PBS向所有M个PU传输信息，而CBS则使用一个功率域NOMA方案为SUi，SUj提供SWIPT服务，并将能量传输给其他SU，只要CBS强加于该系统的干扰是可以容忍的。</p>
<p> 文中假设，涉及到的信道都是频率平坦慢衰落信道（即为如果信号带宽远小于相干带宽，则可以近似认为在信号的带宽内，信道的功率谱包络是平的（幅度增益为常数），此时称信号经历了平坦衰落）</p>
<p> 给出了SUi，SUj和其他能量收集SU接收到的信号以及CBS施加在PUm上的干扰信号表达式。并对相关参数进行了假设。</p>
</li>
<li><p>模型设定</p>
<p> 先提了线性能量收集模型。由于实际中，功率转换效率与输入功率水平有很大关系。特别是，效率首先随着输入功率的增加而增加，然后在一个常数处饱和。此外，最大可能的收获效率也有限制。引出了本文的更偏向于实际的非线性能量收集模型。这里引入了逻辑斯蒂函数，进而描述了由硬件限制引起的各种非线性现象的联合效应。</p>
<p> 这些模型表示的是RF到直流(DC)转换电路的关系。</p>
</li>
<li><p>问题的约束与提出</p>
<p> 最小传输速率、最大干扰功率、每个单元的收获能量最大。假定了SUi比SUj的信道条件差，这里SUi信道条件差，基站发送信号时提供更大的功率。进而给出了各自的信息解码速率。同时还要保证其各自的速率要满足不小于最小值。</p>
<p> 而对于SUj对于本要SUi解码的信息进行解码的速率也有限制，因为要实现连续干扰消除，需要先处理功率更强的信号，需要对其解码重构，而这个操作是有速度要求的。同样，由前面提到可知，这里CBS对于PU的干扰必须要在允许范围内。</p>
<p> 由以上条件，Pi和Pj是最优变量，为了最大化每个收集能量的次级用户收集的能量，得出了一个多目标优化问题。</p>
<p> 这里的MOOP最优解构成一个可行的最优区域，定义为Pareto最优(多目标规划问题最优解)，即当且仅当存在唯一一组解，使得每个次级用户收集的能量最大化。</p>
</li>
<li><p>问题的变形</p>
<p> 引入了理想收集能量（Utopia Harvesting Energy），表示每个用户能获得的最大量。上面的多目标优化问题可以表述为在最优参数Pi与Pj下，加上约束条件后，对于每个收集能量的次级用户收集的能量都为最大时的解。</p>
<p> 进一步可以变形为一个关于Pi，Pj的凸问题，可以利用拉格朗日乘数法来解决。进而得到一个最优Pi，Pj分配策略，来获得理想收集能量。同时，提出了一种最优功率分配算法，从而可以获得理想收集能量。</p>
<p> 获得理想收集能量后，多目标优化问题可以通过使用加权切比雪夫方法，转化为单目标优化问题。利用权重关系可以解决前面的多目标优化问题。帕累托最优收集能量，可以通过理想能量加权获得。</p>
<p> 通过代换，设参数，一阶Taylor级数展开，替换约束条件，将问题转化为一个相对于Pi与Pj为凸的问题，从而利用拉格朗日乘数法来解决。进而得到了帕累托最优收集能量。</p>
</li>
<li><p>仿真结果</p>
<p> 利用文献33与35设置非线性能量收集参数。也设置了一个线性能量收集模型，加上前面的约束条件，进行了测试。所有涉及的信道都被假定为瑞利平坦衰落。</p>
<p> a. 仿真测试了不同PU干扰容限值下，理想收集功率与迭代次数的关系。该算法仅需少量迭代就能收敛到一个常数值。这验证了我们提出的算法的有效性。</p>
<p> b. 也测试了在非线性与线性模型下，最大PU干扰容限值与理想收集效率的关系。可见都随最大干扰容限值而增加。这是因为CBS可以在更宽松的功率约束下，即更大的Γm值下，使用更多的功率将信息传输给SU。<br> 但是可见这里的非线性模型分配方案可以获得更大的理想收集功率。其原因是线性EH模型采用固定功率转换效率ηn=0.5，导致资源分配不匹配。</p>
<p> c. 测试了SUi不同服务质量下的PU最大干扰容限值与理想收集功率的关系。可见理想收集功率随最大容限值增加而增加。这里可以类似地由以下事实来解释：较宽松的干扰约束可以让CBS提供更高的发射功率。这样，SU就能收获更多的功率。<br> 还可以观察到，SUi的QoS较低导致了更大的理想收集功率。这是因为在能量收集和信息传输之间存在着一种平衡。具体来说，当第SUi的QoS增加时，收集功率可能会降低。</p>
<p> d. 测试了用户1的功率分配权重与帕累托收集功率之间的关系。将理想收集功率设置为每个用户收集能量的上限值，从结果可见，随着权重的增大，趋于1，则逐步趋向理想收集功率，帕累托收集功率与权重成正比。</p>
<p> 仿真结果表明，非线性能量采集模型的性能要好于线性能量采集模型下的性能，并且信息解码用户的速率与采集能量之间存在权衡。</p>
<p> 参考：</p>
<ul>
<li>5G移动网络非正交多址接入及相关技术研究_杨正</li>
<li>Non-Orthogonal Multiple Access (NOMA):<ul>
<li>Evolution towards 5G Cellular Networks - 28 April 2016 </li>
</ul>
</li>
<li>基于能量获取的无线通信系统研究</li>
<li>频谱管理的现状及其发展概述（(20180118130630)</li>
<li>多用户信能同传系统的收发机优化设计</li>
<li>多用户无线信能同传系统能效优化方法</li>
<li>基于能量获取的无线通信系统研究</li>
<li>认知MIMO系统下行链路干扰抑制算法研究</li>
<li>认知无线电关键技术研究</li>
<li>认知无线电网络性能分析以及能量收集研究_崔飞</li>
<li>认知无线电中无线频谱感知技术的研究</li>
<li>无线协作中继网络的资源分配和信息能量同传技术的研究</li>
<li><p>信道质量对网络性能的影响</p>
<p>下载链接： </p>
<p>链接: <a href="https://pan.baidu.com/s/1bqzim3H" target="_blank" rel="noopener">https://pan.baidu.com/s/1bqzim3H</a> 密码: xh79</p>
</li>
</ul>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://plart.pw/2018/02/15/ee/认证无线电网络的多目标资源优化-论文阅读/" data-id="cjognmzo8000qzchs6ewqtj51" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/通信/">通信</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-langs/python/多种字体的福的生成" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/15/langs/python/多种字体的福的生成/" class="article-date">
  <time datetime="2018-02-15T10:39:52.000Z" itemprop="datePublished">2018-02-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/编程与生活/">编程与生活</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/15/langs/python/多种字体的福的生成/">生成任意字体的“福”字</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="生成任意字体的“福”字"><a href="#生成任意字体的“福”字" class="headerlink" title="生成任意字体的“福”字"></a>生成任意字体的“福”字</h1><h2 id="具体代码见后，相关不足见下"><a href="#具体代码见后，相关不足见下" class="headerlink" title="具体代码见后，相关不足见下"></a>具体代码见后，相关不足见下</h2><ol>
<li>最大的问题就是 我电脑中的字体很多对于此处代码的中文无法正常显示，如何保证最终的字体图片中只保留正常的图片</li>
<li>使产生不同的福字除了改变字体外还可以使用什么手段</li>
</ol>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 调用cmd</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="comment"># 处理字符串</span></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="comment"># 文字转化为图片</span></span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image, ImageFont, ImageDraw</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出所有的字体文件，主要是用ttf（TrueType字体)文件</span></span><br><span class="line">return_cmd = os.popen(<span class="string">"C: &amp; cd / &amp; cd C:\Windows\Fonts\ &amp; tree /f"</span>)</span><br><span class="line">fonts = return_cmd.read()</span><br><span class="line">print(fonts)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 只保留ttf部分</span></span><br><span class="line">pattern = re.compile(<span class="string">'\S.*?ttf'</span>, re.I)</span><br><span class="line">result_list = pattern.findall(fonts)</span><br><span class="line"><span class="comment"># 去掉中文名称的字体</span></span><br><span class="line">result_list = result_list[<span class="number">1</span>:<span class="number">-9</span>]</span><br><span class="line">print(result_list)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 文字处理</span></span><br><span class="line">text = <span class="string">"福"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定图片保存文件夹</span></span><br><span class="line">path_img = <span class="string">'D:\\编程\\py-font-fu\\img\\'</span></span><br><span class="line"><span class="keyword">if</span> os.path.isdir(path_img):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    os.mkdir(path_img)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制，保存</span></span><br><span class="line"><span class="keyword">for</span> index <span class="keyword">in</span> range(len(result_list)):</span><br><span class="line">    <span class="comment"># 新建一个300*300的空白图像</span></span><br><span class="line">    img = Image.new(<span class="string">"RGB"</span>, (<span class="number">300</span>, <span class="number">300</span>), (<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>))</span><br><span class="line">    <span class="comment"># 创建画笔</span></span><br><span class="line">    drawer = ImageDraw.Draw(img)</span><br><span class="line">    <span class="comment"># 字体</span></span><br><span class="line">    path_font = <span class="string">'C:\\Windows\\Fonts\\'</span> + result_list[index]</span><br><span class="line">    font = ImageFont.truetype(path_font, <span class="number">200</span>)</span><br><span class="line">    drawer.text((<span class="number">10</span>, <span class="number">10</span>), text=text, font=font, fill=(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">    <span class="comment"># 保存</span></span><br><span class="line">    img.save(path_img + result_list[index][<span class="number">0</span>:<span class="number">-3</span>] + <span class="string">'png'</span>)</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://plart.pw/2018/02/15/langs/python/多种字体的福的生成/" data-id="cjognmzv3005szchsc5v3kaaj" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/">python</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/3/">&laquo; 上一页</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/5/">下一页 &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/幻想与现实/">幻想与现实</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/技术与进步/">技术与进步</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/生活与思考/">生活与思考</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/电影与艺术/">电影与艺术</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/编程与生活/">编程与生活</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/记录与总结/">记录与总结</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/C-C/">C++&C</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ChucK/">ChucK</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/R/">R</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/css/">css</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/html/">html</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/org-mode/">org-mode</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python/">python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python3/">python3</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/佳片/">佳片</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/学习/">学习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/工具/">工具</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/开心麻花/">开心麻花</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/影视/">影视</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/总结/">总结</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据结构/">数据结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/校园/">校园</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/汇编/">汇编</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/爬虫/">爬虫</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/爱情/">爱情</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/琐事/">琐事</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/生活/">生活</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/电影/">电影</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/科幻/">科幻</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/计算机原理/">计算机原理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/计算机网络/">计算机网络</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/进阶/">进阶</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/通信/">通信</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/随感/">随感</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/C-C/" style="font-size: 14.29px;">C++&C</a> <a href="/tags/ChucK/" style="font-size: 20px;">ChucK</a> <a href="/tags/Java/" style="font-size: 11.43px;">Java</a> <a href="/tags/Linux/" style="font-size: 10px;">Linux</a> <a href="/tags/R/" style="font-size: 10px;">R</a> <a href="/tags/css/" style="font-size: 10px;">css</a> <a href="/tags/html/" style="font-size: 10px;">html</a> <a href="/tags/org-mode/" style="font-size: 10px;">org-mode</a> <a href="/tags/python/" style="font-size: 18.57px;">python</a> <a href="/tags/python3/" style="font-size: 10px;">python3</a> <a href="/tags/佳片/" style="font-size: 10px;">佳片</a> <a href="/tags/学习/" style="font-size: 17.14px;">学习</a> <a href="/tags/工具/" style="font-size: 11.43px;">工具</a> <a href="/tags/开心麻花/" style="font-size: 10px;">开心麻花</a> <a href="/tags/影视/" style="font-size: 11.43px;">影视</a> <a href="/tags/总结/" style="font-size: 10px;">总结</a> <a href="/tags/数据结构/" style="font-size: 11.43px;">数据结构</a> <a href="/tags/校园/" style="font-size: 10px;">校园</a> <a href="/tags/汇编/" style="font-size: 15.71px;">汇编</a> <a href="/tags/爬虫/" style="font-size: 10px;">爬虫</a> <a href="/tags/爱情/" style="font-size: 10px;">爱情</a> <a href="/tags/琐事/" style="font-size: 10px;">琐事</a> <a href="/tags/生活/" style="font-size: 11.43px;">生活</a> <a href="/tags/电影/" style="font-size: 10px;">电影</a> <a href="/tags/科幻/" style="font-size: 10px;">科幻</a> <a href="/tags/计算机原理/" style="font-size: 12.86px;">计算机原理</a> <a href="/tags/计算机网络/" style="font-size: 10px;">计算机网络</a> <a href="/tags/进阶/" style="font-size: 10px;">进阶</a> <a href="/tags/通信/" style="font-size: 10px;">通信</a> <a href="/tags/随感/" style="font-size: 10px;">随感</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">十一月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">十月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">九月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">八月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">七月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">六月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">五月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">四月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">三月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">二月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">八月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">七月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">三月 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/11/14/ceshi/">ceshi</a>
          </li>
        
          <li>
            <a href="/2018/10/25/ee/上网背后的流程/">上网背后的流程</a>
          </li>
        
          <li>
            <a href="/2018/09/15/life/这些衰败的日子/">这些衰败的日子</a>
          </li>
        
          <li>
            <a href="/2018/08/30/life/如懿如意/">如懿，如意</a>
          </li>
        
          <li>
            <a href="/2018/08/05/life/开心麻花几部电影/">开心麻花</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 Lart Pang<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>
<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>chuck12 | 失乐园</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="unit analyzers   new!!!  declaring connecting controlling over time representing metadata: the UAnaBlob representing complex data performing analysis in UAna networks using events built-in unit analyz">
<meta name="keywords" content="ChucK">
<meta property="og:type" content="article">
<meta property="og:title" content="chuck12">
<meta property="og:url" content="https://plart.pw/2018/02/15/langs/chuck/chuck12/index.html">
<meta property="og:site_name" content="失乐园">
<meta property="og:description" content="unit analyzers   new!!!  declaring connecting controlling over time representing metadata: the UAnaBlob representing complex data performing analysis in UAna networks using events built-in unit analyz">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2018-07-13T12:46:25.276Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="chuck12">
<meta name="twitter:description" content="unit analyzers   new!!!  declaring connecting controlling over time representing metadata: the UAnaBlob representing complex data performing analysis in UAna networks using events built-in unit analyz">
  
    <link rel="alternate" href="/atom.xml" title="失乐园" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">失乐园</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">代码与机器</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://plart.pw"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-langs/chuck/chuck12" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/15/langs/chuck/chuck12/" class="article-date">
  <time datetime="2018-02-15T13:40:10.000Z" itemprop="datePublished">2018-02-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/编程与生活/">编程与生活</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      chuck12
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>unit analyzers </p>
<blockquote>
<p>new!!!</p>
</blockquote>
<pre><code>declaring
connecting
controlling over time
representing metadata: the UAnaBlob
representing complex data
performing analysis in UAna networks
using events
built-in unit analyzers
creating (coming soon) 
</code></pre><p>#Unit Analyzers<br>单元分析器</p>
<blockquote>
<p>Unit Analyzers (<strong>UAnae</strong>) are analyis building blocks, similar in concept to unit generators.They perform analysis functions on audio signals and/or metadata input, and produce metadata analysis results as output.<br>(对音频信号或者元数据输入进行分析，把元数据分析结果作为输出)<br>Unit analyzers can be linked together and with unit generators to form analysis/synthesis networks. Like unit generators, several unit analyzers may run concurrently, each dynamically(动态地) controlled at different rates. Because data passed between UAnae is not necessarily audio samples, and the relationship of UAna computation to time is fundamentally (根本地)different than that of UGens (e.g., UAnae might compute on blocks of samples, or on metadata), <em>the connections between UAnae have a different meaning from the connections between UGens formed with the ChucK operator, <code>=&gt;</code></em>. This difference is reflected in the choice of a new connection operator, the upChucK operator: <code>=^</code>. Another key difference between UGens and UAnae is that <strong>UAnae perform analysis (only) on demand, via the <code>upchuck()</code> function (see below).</strong></p>
</blockquote>
<p>Some more quick facts about ChucK unit analyzers:</p>
<ul>
<li>All ChucK unit analyzers are objects (not primitive(原始的) types). </li>
<li>All ChucK unit analyzers inherit(继承) from the <code>UAna</code> class.</li>
<li>The operation <code>foo =^ yah</code>, where foo and yah are UAnae, connects foo to yah.</li>
<li>Unit analyzer parameters(参数) and behaviors(行为) are controlled by calling / chucking to member functions over time, just like unit generators.</li>
<li>Analysis results are always stored in an object called a <code>UAnaBlob</code>. The <code>UAnaBlob</code> contains a time-stamp(时间标记) indicating(表明) when it was computed, and it may store an array(数组) of floats and/or complex(复杂的) values. <em>Each UAna specifies(指定) what information is present in the <code>UAnaBlob</code> it produces.</em>每个UAna指定它产生的UAnaBlob中的信息</li>
<li>All unit analyzers have the function <code>upchuck()</code>, which when called issues <em>a cascade of(一系列的) analysis computations for the unit analyzer and any “upstream(上游的)” unit analyzers on which its analysis depends.</em> (In the example of <code>foo =^ yah</code>,  <code>yah.upchuck()</code> will result in <code>foo</code> first performing its analysis (possibly requesting analysis results from unit analyzers <em>further upstream</em>), then <code>yah</code>, <em>using <code>foo</code>‘s analysis results in its computation</em>. <em><code>upchuck()</code> returns the analysis results in the form of a <code>UAnaBlob</code>.</em>)</li>
<li><p>Unit analyzers are specially integrated into the virtual(虚拟的) machine such that <em>each unit analyzer performs its analysis on its input whenever it or a downstream (下游的)<code>UAna</code> is <code>upchuck()</code>-ed.</em> Therefore, we have the ability to <em>assert(维护) control over the analysis process at any point in time and at any desired control rate</em>.</p>
<p>  <a href="http://chuck.cs.princeton.edu/doc/program/uana.html" target="_blank" rel="noopener">View a list</a> of ChucK’s built-in(嵌入的) unit analyzer(分解) classes </p>
</li>
</ul>
<p>#declaring</p>
<p><em>Unit analyzers (UAnae) are objects, and they need to be instantiated before they can be used.</em></p>
<p>单元分析器是对象，使用前需要实例化</p>
<p>We declare unit analyzers the same way we declare UGens and other objects.</p>
<pre><code>// instantiate an FFT, assign reference to variable f
FFT f;
</code></pre><p>#connecting</p>
<p>The upChucK operator (<code>=^</code>) is <em>only meaningful(有意义的) for unit analyzers</em>. Similar to the behavior(行为) of the ChucK operator between UGens, <strong>using <code>=^</code> to connect one UAna to another</strong> connects <strong>the analysis results of the first to the analysis input of the second</strong>. </p>
<pre><code>// instantiate FFT and flux objects, 
// connect to allow computation of spectrum(频谱) and spectral flux on adc input
adc =&gt; FFT fft =^ Flux flux =&gt; blackhole;
</code></pre><p><strong>Note</strong> that the last UAna in any chain must be chucked to the <code>blackhole</code> or <code>dac</code> <em>to “pull” audio samples from the <code>adc</code> or other unit generators upstream.</em></p>
<p>It is also possible to linearly(线性的) chain many UAnae together in a single statement(声明).<br>In the example below, the analysis of <code>flux_capacitor</code> depends on the results of <code>flux</code>, so the <code>flux</code> object will always perform its analysis computation before the computation of <code>flux_capacitor</code>.分析计算是先后执行的</p>
<pre><code>// Set up analysis on adc, via an FFT object, a spectral flux object, and a
// made-up object called a FluxCapacitor that operates on the flux value.
adc =&gt; FFT f =^ Flux flux =^ FluxCapacitor flux_capacitor =&gt; blackhole;
</code></pre><p><strong>Very importantly</strong>, it is possible to create connection networks containing both <code>UAane</code> and <code>UGens</code>.<br>In the example below, an <code>FFT</code> transforms(改变) two (added) sinusoidal(正弦曲线的) inputs, one of which has reverb(混响) added. An <code>IFFT</code> transforms the spectrum(频谱) back into the time domain(频域转换为时域), and the result is processed(处理) with a third sinusoid(正弦曲线) by a gain object before being played through the <code>dac</code>(被通过dac播放).<br>(No, this example is not supposed to do anything musically interesting, only help you get a feel for the syntax(语法).)<br><strong>Notice</strong> that any connection through which <em>audio samples are passed</em> is denoted(表示) with the <code>=&gt;</code> operator, and the connection through which <em>spectral data is passed (from the FFT to the IFFT)</em> is denoted with the <code>=^</code> operator.</p>
<pre><code>//Chain a sine into a reverb, then perform FFT, then IFFT, then apply gain, then output
SinOsc s =&gt; JCRev r =&gt; FFT f =^ IFFT i =&gt; Gain g =&gt; dac;
// Chuck a second sine into the FFT
SinOsc s2 =&gt; f;
// Chuck a third sine into the final gain
SinOsc s3 =&gt; g;
</code></pre><p><code>FFT</code>, <code>IFFT</code>, and other UAnae that perform transforms between the audio domain and another domain play a special role, as illustrated above(正如上文所述).</p>
<ul>
<li><code>FFT</code> takes audio samples(样品) as input, so unit generators connect to it with the ChucK operator <code>=&gt;</code>. </li>
<li>However, it outputs(输出) analysis results in the spectral domain, so it connects to other <em>UAnae</em> with the upChucK operator <code>=^</code>. </li>
<li>Conversely(相反的), UAnae producing spectral domain output connect to the <code>IFFT</code> using <code>=^</code>, and <code>IFFT</code> can connect to the <code>dac</code> or other <em>UGens</em> using <code>=&gt;</code>. </li>
</ul>
<p>This syntax(语法) allows the programmer to clearly reason about the expected behavior(行为) of <em>an analysis/synthesis(分析综合，分解重构) network</em>, while <strong>it hides the internal mechanics(内部机制) of ChucK timing and sample buffering from the programmer</strong>.</p>
<p>Finally, just as with unit generators, it is possible to dynamically (动态地)<strong>disconnect</strong> (拆开)unit analyzers, using the UnChucK operator (<code>=&lt;</code> or <code>!=&gt;</code>).</p>
<p>#controlling (over time)</p>
<p><strong>In any ChucK program, it is necessary to advance time in order to pull audio samples(样品) through the UGen network and create sound</strong>. Additionally(此外), <em>it is necessary to trigger(引发) analysis computations(计算) explicitly(显式地) in order for any analysis to be performed</em>, and for sound synthesis(合成) that depends on analysis results (e.g., <code>IFFT</code>) to be performed.<br>To explicitly trigger computation at a point in time, the UAna’s <code>upchuck()</code> member function is called. </p>
<p><code>upchuck()</code>：显式引发计算</p>
<p>In the example below, an FFT computation is triggered(引发) <em>every 1024 samples</em>.</p>
<pre><code>adc =&gt; FFT fft =&gt; dac;
// set the FFT to be of of size 2048 samples
2048 =&gt; fft.size;

while (true) {
// let 1024 samples pass
1024::samp =&gt; now;
// trigger the FFT computation on the last 2048 samples (the FFT size)
fft.upchuck();
}
</code></pre><p>In the example above, because the <code>FFT</code> size is 2048 samples, the while-loop causes a standard “sliding-window(滑动窗)” <code>FFT</code> to be computed, where the hop size(步进值) is equal to half a window.<br>However, ChucK allows you to perform analysis using nonstandard, dynamically(动态地) set, or even multiple hop sizes with the same object. 非标准的动态设定或者甚至多倍的步进大小<br>For example, in the code below, the <code>FFT</code> object <code>fft</code> performs computation every 5 seconds as triggered by <code>shred1</code>, and it additionally performs computation at a variable(可变的) rate as triggered by <code>shred2</code>.</p>
<pre><code>adc =&gt; FFT fft =&gt; dac;
2048 =&gt; fft.size;

// spork two shreds: shred1 and shred2
spork ~shred1();
spork ~shred2(); 

// shred1 computes FFT every 5 seconds
fun void shred1() {
    while (true) {
    5::second =&gt; now;
    fft.upchuck();
    }
}

// shred2 computes FFT every n seconds, where n is a random number between 1 and 10
fun void shred2() {
    while (true) {
    Std.rand2f(1, 10)::second =&gt; now;
    fft.upchuck();
    }
}
</code></pre><p>Parameters(参数) of unit analyzers may be controlled and altered at any point in time and at any control rate. We only have to assert(维护) control at the appropriate(适当的) points as we move through time, by setting various parameters of the unit analyzer.<br><em>To set the a value for a parameter of a <code>UAna</code>, a value of the proper type should be ChucKed to the corresponding control function.</em></p>
<pre><code>// connect the input to an FFT
adc =&gt; FFT fft =&gt; blackhole;

//start with a size of 1024 and a Blackman-Harris window
1024 =&gt; fft.size;
Windowing.blackmanHarris(512) =&gt; fft.window;

//advance time and compute FFT
1::minute =&gt; now;
fft.upchuck();

// change window to Hamming
Windowing.hamming(512) =&gt; fft.window;

// let time pass... and carry on.
</code></pre><p><em>Since the control functions are member functions of the unit analyzer, the above syntax(语法) is equilavent to calling functions.</em> For example, the line below could <strong>alternatively(作为选择)</strong> be used to change the FFT window to a Hamming window, as above.</p>
<pre><code>fft.window(Windowing.hamming(512));
</code></pre><p>For a list of unit analyzers and their control methods, consult(查阅) <a href="http://chuck.cs.princeton.edu/doc/program/uana.html" target="_blank" rel="noopener">UAna reference</a>.</p>
<p>Just like unit generators, to read the current value of certain parameters of a <code>Uana</code>, we may call an overloaded function of the same name.就像单元发生器，读取当前Uana的某个参数的值，可以调用重载的同名函数<br>Additionally, assignments(分配) can be chained together when assigning(分配) one value to multiple targets.给多的目标分配一个值时，可以串联起来</p>
<pre><code>// connect adc to FFT
adc =&gt; FFT fft =&gt; blackhole;

// store the current value of the FFT size
fft.size() =&gt; int fft_size;
</code></pre><p>What if a <code>UAna</code> that performs analysis on a group of audio samples(样品) is <code>upchuck()</code>-ed before its internal(内部的) buffer(缓冲区) is filled? This is possible if an FFT of size 1024 is instantiated(实例化), then <code>upchuck()</code>-ed after only 1000 samples, for example. In this case, the empty buffer slots(位置) are treated as 0’s (that is, zero-padding(补零) is applied空的缓存区会被置零). This same behavior(行为) will occur if the FFT object’s size is increased from 1024 to 2048, and then only 1023 samples pass after this change is applied; the last sample in the new (larger) buffer will be 0. <em>Keep in mind</em>, then, that certain analysis computations near the beginning of time and analysis computations after certain parameters(参数) have changed will logically(逻辑上) involve(包含) a short “transient(短暂的)” period.</p>
<pre><code>// connect adc to FFT to blackhole
adc =&gt; FFT fft =&gt; blackhole;
// set the FFT size to 1024 samples
1024 =&gt; fft.size;

// allow 1000 samples to pass
1000::samp =&gt; now;

// compute the FFT: the last 24 spots in the FFT buffer haven&apos;t been filled, so they are zero-ed out归零，置零
// the computation is nevertheless valid and proceeds.计算仍然是有效又有收益的。
fft.upchuck(); 

1::minute =&gt; now; // let time pass for a while

// increase the size of the FFT, and therefore the size of the sample buffer it uses
2048 =&gt; fft.size;

// let 1023 samples pass 
// 会填满1023个缓存点
1023::samp =&gt; now;

// at this point, only 2047 of the 2048 buffer spots have been filled
// 这处，2048中只有2047个缓存位置被填满——怎么算的？1000+24+1023
// the following computation therefore zeros out the last audio buffer spot
// 此句置零了最后一个音频缓存点
fft.upchuck();

1::minute =&gt; now; //let time pass for a while

// now the buffer is happy and full
fft.upchuck(); // proceeds normally on a full buffer
</code></pre><p>#representing metadata: the <code>UAnaBlob</code></p>
<p>It is great to be able to trigger(引发) analysis computations like we’ve been doing above, but what if you want to actually <em>use</em> the analysis results? Luckily, calling the <code>upchuck()</code> function on a <code>UAna</code> returns a reference to <em>an object that stores the results of any <code>UAna</code> analysis</em>, called a <code>UanaBlob</code>. <code>UanaBlob</code>s can contain <strong>an array of floats</strong>, and/or <strong>an array of complex numbers</strong> (see the next section). The meaning and formatting(格式化) of the <code>UanaBlob</code> fields(字段) is different for each <code>UAna</code> subtype(子类型). <code>FFT</code>, for example (see <a href="chuck.cs.princeton.edu/doc/program/uana_full.html#FFT">specification</a>), fills in the complex array with the spectrum(频谱的复数数组) and the floating point array with the magnitude spectrum(振幅谱的浮点数组). Additionally, all <code>UanaBlob</code>s store the time when the <code>blob</code> was last computed.</p>
<p>The example below demonstrates(证明) how one might access(访问) the results of an FFT:</p>
<pre><code>adc =&gt; FFT fft =&gt; blackhole;
// ... set FFT parameters here ...

UAnaBlob blob;

while (true) {
    500::ms =&gt; now; // use hop size of 50 ms
    fft.upchuck() @=&gt; blob; // `store` the result in blob.
    blob.fvals() @=&gt; float mag_spec[]; // get the magnitude spectrum as float array
    blob.cvals() @=&gt; complex spec[]; // get the whole spectrum as complex array
    // get `the first bin`(这个指什么？？？) of the magnitude spectrum
    mag_spec[0] =&gt; float first_mag; 
    blob.fval(0) =&gt; float first_mag2; // equivalent way to get first bin of mag spectrum
    fft.upchuck().fval(0) =&gt; float first_mag3; // yet another equivalent way

    fft.upchuck().cval(0) =&gt; complex first_spec; // similarly, get 1st spectrum bin

    blob.when() =&gt; time when_computed; // get the time it was computed
} 
</code></pre><p><strong>Beware</strong>: whenever a <code>UAna</code> is <code>upchuck()</code>-ed, the contents of its previous <code>UAnaBlob</code> are overwritten.<br>In the following code, <code>blob1</code> and <code>blob2</code> refer to <em>the same <code>UAnaBlob</code></em>. When <code>fft.upchuck()</code> is called the second time, the contents of the <code>UAnaBlob</code> referred to by <code>blob1</code> are overwritten.</p>
<pre><code>adc =&gt; FFT fft =&gt; blackhole;

UAnaBlob blob1, blob2;
1::minute =&gt; now; //let time pass for a while
fft.upchuck() @=&gt; blob1; // blob1 points to `the analysis results`
1::minute =&gt; now; // let time pass again
fft.upchuck() @=&gt; blob2; 
// now both blob1 and blob2 refer to the same object: **the new results!**
</code></pre><p>Also <strong>beware</strong>: if time is not advanced between subsequent(后来的) <code>upchuck()</code>s of a <code>UAna</code>, any <code>upchuck()</code> after the first <em>will not re-compute the analysis</em>, even if <code>UAna</code> parameters have been changed.<br>After the code below, <code>blob</code> refers to a <code>UAnaBlob</code> that is the result of computing the first (size 1024) FFT.指向第一次计算的结果的UAnaBlob</p>
<pre><code>adc =&gt; FFT fft =&gt; blackhole;
1024 =&gt; fft.size;

UAnaBlob blob;
1::minute =&gt; now; //let time pass for a while
fft.upchuck() @=&gt; blob; // blob holds the result of the FFT

512 =&gt; fft.size;
fft.upchuck() @=&gt; blob; 
// time hasn&apos;t advanced since the last computation, so no re-computation is done
</code></pre><p>#representing complex data: the complex and polar types</p>
<p>In order to represent complex data, such as the output of an <code>FFT</code>, two new datatypes have been added to ChucK: complex and polar.</p>
<p>#performing analysis in UAna networks</p>
<p>Often, the computation of one <code>UAna</code> will depend on the computation results of “upstream” <code>UAnae</code>. For example, in the UAna network below, the spectral flux(频谱流量) is computed using the results of an <code>FFT</code>.</p>
<pre><code>adc =&gt; FFT fft =^ Flux flux =&gt; blackhole;
</code></pre><p>The flow of computation in <code>UAna</code> networks is set up(设置) so that every time a <code>UAna</code> <code>a</code> is <code>upchuck()</code>-ed, each <code>UAna</code> whose output is connected to <code>a</code>‘s input via <code>=^</code> is <code>upchuck()</code>-ed first, passing the results to <code>a</code> for it to use.<br>For example, a call to <code>flux.upchuck()</code> will first force <code>fft</code> to compute an FFT on the audio samples in its buffer,<br>then <code>flux</code> will use the <code>UanaBlob</code> from <code>fft</code> to compute the spectral flux.<br>This flow of computation is handled <em>internally by ChucK</em>; you should understand the flow of control, but you don’t need to do <code>fft.upchuck()</code> explicitly. Just writing code like that below will do the trick:</p>
<pre><code>adc =&gt; FFT fft =^ Flux flux =&gt; blackhole;
UAnaBlob blob;
while (true) {
    100::ms =&gt; now;
    flux.upchuck() @=&gt; blob; // causes fft to compute, then computes flux and stores result in blob
}
</code></pre><p>Additionally, each time a <code>UAna</code> <code>upchuck()</code>s, its results are cached(缓存) until time passes. <em>This means that a <code>UAna</code> will only perform its computation once for a particular point in time.</em></p>
<pre><code>adc =&gt; FFT fft =^ Flux flux =&gt; blackhole;
fft =^ Centroid c =&gt; blackhole;

UAnaBlob blob, blob2;
while (true) {
    100::ms =&gt; now;
    flux.upchuck() @=&gt; blob; // causes fft to compute, then computes flux and stores result in blob
    c.upchuck() @=&gt; blob2; // uses cached fft results from previous line to compute centroid
}
</code></pre><p><em>When no <code>upchuck()</code> is performed on a <code>UAna</code>, or on <code>UAnae</code> that depend on it</em>, it will not do computation. For example, in the network below, the flux is never computed.</p>
<pre><code>adc =&gt; FFT fft =^ Flux flux =&gt; blackhole;
UAnaBlob blob;
while (true) {
    100::ms =&gt; now;
    fft.upchuck() @=&gt; blob; // compute fft only
}
</code></pre><p>The combination of  this “compute-on-demand” behavior(这种按需计算行为的组合) and <code>UAna</code> caching means that different <code>UAnae</code> in a network can be <code>upchuck()</code>-ed at various/varying control rates, with maximum efficiency. In the example below, the <code>FFT</code>, <code>centroid</code>, and <code>flux</code> are all <em>computed at different rates</em>. When the analysis times for <code>flux</code> and <code>fft</code> or <code>centroid</code> and <code>fft</code> overlap(同时发生), <code>fft</code> is computed <em>just once</em> due to its <em>internal caching</em>.<br>When it is an analysis time point for <code>fft</code> but not for <code>flux</code>, <code>flux</code> will not be computed.</p>
<pre><code>adc =&gt; FFT fft =^ Flux flux =&gt; blackhole;
fft =^ Centroid c =&gt; blackhole;
UAnaBlob blob1, blob2, blob3;

spork ~do_fft();
spork ~do_flux();
spork ~do_centroid();

while (true) {
    //Keep parent shred going
    1::minute =&gt; now;
    //感觉是多进程必要的一段代码
}

fun void do_fft() {
    while (true) {
        50::ms =&gt; now;
        fft.upchuck() @=&gt; blob1;
    }
}

fun void do_flux() {
    while (true) {
        110::ms =&gt; now;
        flux.upchuck() @=&gt; blob2;
    }
}

fun void do_centroid() {
    while (true) {
        250::ms =&gt; now;
        c.upchuck() @=&gt; blob3;
    }
}
</code></pre><p>An easy way to synchronize analysis of many <code>UAnae</code> is to <code>upchuck()</code> an “agglomerator(凝聚剂)” <code>UAna</code>.<br>In the example below, <code>agglom.upchuck()</code> triggers analysis of <em>all upstream UAnae</em> in the network.<br>Because <code>agglom</code> is only a member of the <code>UAna</code> base class, it does no computation of its own.<br>However, after <code>agglom.upchuck()</code>, all other <code>UAnae</code> will have up-to-date <em>results that are synchronized, computed, and cached</em> so that they are available to be accessed via <code>upchuck()</code> on each <code>UAna</code> (possibly by <em>a different shred</em> waiting for an event– see below).</p>
<pre><code>adc =&gt; FFT fft =^ Flux flux =^ UAna agglom =&gt; blackhole;
fft =^ Centroid centroid =^ agglom;
// could add arbitrarily(反复地) many more UAnae that connect to agglom via =^

while (true) {
100::ms =&gt; now;
    agglom.upchuck(); // forces computation of both centroid and flux (and therefore fft, too)
}
</code></pre><p><em>Because of the dependency and caching behavior of <code>upchuck()</code>-ing in <code>UAna</code> networks, <code>UAna</code> feedback loops should be used with caution</em>. In the network below, each time <code>c</code> is <code>upchuck()</code>-ed, it forces <code>b</code> to compute, which forces <code>a</code> to compute, which then recognizes that <code>b</code> has been traversed(遍历) in this upChucK path but has not been able to complete its computation– thereby(因此) recognizing <code>a</code> loop in the network.<br><code>a</code> then uses <code>b</code>‘s <em>last computed</em> <code>UAnaBlob</code> to perform its computation.<br>This may or may not be desirable, so be careful.可能不理想</p>
<pre><code>adc =&gt; UAna a =^ UAna b =^ Uana c =&gt; blackhole;
b =^ a; // creates a feedback loop

while (true) {
    100::ms =&gt; now;
    c.upchuck(); // involves a using b&apos;s analysis results from 100 ms ago
}
</code></pre><p>Another handy(方便的) UAna for synchronizing feature extraction(同步特征提取) is the <code>FeatureCollector</code>. Calling <code>upchuck()</code> on a <code>FeatureCollector</code> triggers computation of all upstream UAnae, and it concatenates(连接) their output blob data(BLOB二进制大数据) into a feature vector that can be used as input to a classifier(分类器), for example using <a href="http://smirk.cs.princeton.edu/" target="_blank" rel="noopener">smirk</a>.</p>
<pre><code>adc =&gt; FFT fft =^ Flux flux =^ FeatureCollector fc =&gt; blackhole;
fft =^ Centroid centroid =^ fc;
// could add abitrarily many more UAnae that connect to fc via =^

while (true) {
    100::ms =&gt; now;
    // forces computation of both centroid and flux (and therefore fft, too)
    // an vectorBlob&apos;s fvals and cvals will be a concatenation(连接) of the feature values
    fc.upchuck() @=&gt; UAnaBlob vectorBlob; 
}
</code></pre><p>#built-in unit analyzers</p>
<p>ChucK has a number of built-in UAna classes. These classes perform many basic transform(变换) functions (FFT, IFFT) and feature extraction(特征提取) methods (both spectral and time-domain features(频域时域特征)). A list of built-in ChucK <em>unit analyzers</em> can be found <a href="http://chuck.cs.princeton.edu/doc/program/uana.html" target="_blank" rel="noopener">here</a>.</p>
<p>#creating</p>
<p>( someday soon you will be able to implement your own unit analyzers! )<br>单元分析器的个人实现</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://plart.pw/2018/02/15/langs/chuck/chuck12/" data-id="cjogni4di002gqshse5b5i8kr" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ChucK/">ChucK</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2018/02/15/langs/chuck/chuck3/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          chuck3
        
      </div>
    </a>
  
  
    <a href="/2018/02/15/langs/chuck/chuck13/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">chuck13</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/幻想与现实/">幻想与现实</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/技术与进步/">技术与进步</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/生活与思考/">生活与思考</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/电影与艺术/">电影与艺术</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/编程与生活/">编程与生活</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/记录与总结/">记录与总结</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/C-C/">C++&C</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ChucK/">ChucK</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/R/">R</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/css/">css</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/html/">html</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/org-mode/">org-mode</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python/">python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python3/">python3</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/佳片/">佳片</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/学习/">学习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/工具/">工具</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/开心麻花/">开心麻花</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/影视/">影视</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/总结/">总结</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据结构/">数据结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/校园/">校园</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/汇编/">汇编</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/爬虫/">爬虫</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/爱情/">爱情</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/琐事/">琐事</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/生活/">生活</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/电影/">电影</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/科幻/">科幻</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/计算机原理/">计算机原理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/计算机网络/">计算机网络</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/进阶/">进阶</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/通信/">通信</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/随感/">随感</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/C-C/" style="font-size: 14.29px;">C++&C</a> <a href="/tags/ChucK/" style="font-size: 20px;">ChucK</a> <a href="/tags/Java/" style="font-size: 11.43px;">Java</a> <a href="/tags/Linux/" style="font-size: 10px;">Linux</a> <a href="/tags/R/" style="font-size: 10px;">R</a> <a href="/tags/css/" style="font-size: 10px;">css</a> <a href="/tags/html/" style="font-size: 10px;">html</a> <a href="/tags/org-mode/" style="font-size: 10px;">org-mode</a> <a href="/tags/python/" style="font-size: 18.57px;">python</a> <a href="/tags/python3/" style="font-size: 10px;">python3</a> <a href="/tags/佳片/" style="font-size: 10px;">佳片</a> <a href="/tags/学习/" style="font-size: 17.14px;">学习</a> <a href="/tags/工具/" style="font-size: 11.43px;">工具</a> <a href="/tags/开心麻花/" style="font-size: 10px;">开心麻花</a> <a href="/tags/影视/" style="font-size: 11.43px;">影视</a> <a href="/tags/总结/" style="font-size: 10px;">总结</a> <a href="/tags/数据结构/" style="font-size: 11.43px;">数据结构</a> <a href="/tags/校园/" style="font-size: 10px;">校园</a> <a href="/tags/汇编/" style="font-size: 15.71px;">汇编</a> <a href="/tags/爬虫/" style="font-size: 10px;">爬虫</a> <a href="/tags/爱情/" style="font-size: 10px;">爱情</a> <a href="/tags/琐事/" style="font-size: 10px;">琐事</a> <a href="/tags/生活/" style="font-size: 11.43px;">生活</a> <a href="/tags/电影/" style="font-size: 10px;">电影</a> <a href="/tags/科幻/" style="font-size: 10px;">科幻</a> <a href="/tags/计算机原理/" style="font-size: 12.86px;">计算机原理</a> <a href="/tags/计算机网络/" style="font-size: 10px;">计算机网络</a> <a href="/tags/进阶/" style="font-size: 10px;">进阶</a> <a href="/tags/通信/" style="font-size: 10px;">通信</a> <a href="/tags/随感/" style="font-size: 10px;">随感</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">十一月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">十月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">九月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">八月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">七月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">六月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">五月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">四月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">三月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">二月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">八月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">七月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">三月 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/11/14/ceshi/">ceshi</a>
          </li>
        
          <li>
            <a href="/2018/10/25/ee/上网背后的流程/">上网背后的流程</a>
          </li>
        
          <li>
            <a href="/2018/09/15/life/这些衰败的日子/">这些衰败的日子</a>
          </li>
        
          <li>
            <a href="/2018/08/30/life/如懿如意/">如懿，如意</a>
          </li>
        
          <li>
            <a href="/2018/08/05/life/开心麻花几部电影/">开心麻花</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 Lart Pang<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>